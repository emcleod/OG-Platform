diff --git a/deployment-template/config/dbtoolcontext/dbtoolcontext-postgres-fin.properties b/deployment-template/config/dbtoolcontext/dbtoolcontext-postgres-fin.properties
index 21e4970..c14620d 100644
--- a/deployment-template/config/dbtoolcontext/dbtoolcontext-postgres-fin.properties
+++ b/deployment-template/config/dbtoolcontext/dbtoolcontext-postgres-fin.properties
@@ -7,7 +7,7 @@ db.url = jdbc:postgresql://REPLACE-POSTGRES-FIN-SERVER/og_financial
 db.username = REPLACE-POSTGRES-FIN-USERNAME
 db.password = REPLACE-POSTGRES-FIN-PASSWORD
 
-db.schemaNames = cfg,cnv,eng,exg,pos,prt,sec,snp,usr,len
+db.schemaNames = cfg,cnv,eng,exg,pos,prt,secb,snp,usr,len
 
 db.scriptsResource = classpath:db
 
diff --git a/deployment-template/config/fullstack/fullstack.ini b/deployment-template/config/fullstack/fullstack.ini
index c1fdab3..81fce08 100644
--- a/deployment-template/config/fullstack/fullstack.ini
+++ b/deployment-template/config/fullstack/fullstack.ini
@@ -161,7 +161,7 @@ jmsChangeManagerTopic = OpenGamma.MasterChange.MarketDataSnapshotMaster.central-
 enforceSchemaVersion = ${component.master.enforceSchemaVersion}
 
 [dbSecurityMaster]
-factory = com.opengamma.component.factory.master.DbSecurityMasterComponentFactory
+factory = com.opengamma.component.factory.master.DbSecurityBeanMasterComponentFactory
 classifier = central
 dbConnector = ::sec
 cacheManager = ::standard
@@ -506,6 +506,9 @@ remoteCalcNode = CalcNodeSocketConfiguration::main
 availableOutputs = AvailableOutputsProvider::main
 viewProcessor = ViewProcessor::main
 activeMQ = ${activeMQ.brokerURL}
+liveDataClient.subscriptionTopic = ${liveDataClient.subscriptionTopic}
+liveDataClient.entitlementTopic = ${liveDataClient.entitlementTopic}
+liveDataClient.heartbeatTopic = ${liveDataClient.heartbeatTopic}
 conventionBundleSource = ConventionBundleSource::shared
 conventionSource = ConventionSource::shared
 legalEntitySource = LegalEntitySource::shared
diff --git a/deployment-template/config/fullstack/fullstack.properties b/deployment-template/config/fullstack/fullstack.properties
index 53422db..c3bbe27 100644
--- a/deployment-template/config/fullstack/fullstack.properties
+++ b/deployment-template/config/fullstack/fullstack.properties
@@ -39,6 +39,9 @@ component.master.enforceSchemaVersion = true
 temptarget.path = data/temptarget
 
 livedata.availability.topic = OpenGamma.LiveData.availability
+liveDataClient.subscriptionTopic = BloombergSubscriptionRequestTopic
+liveDataClient.entitlementTopic = BloombergEntitlementRequestTopic
+liveDataClient.heartbeatTopic = BloombergHeartbeatTopic
 
 #Global
 time.zone = Europe/London
diff --git a/deployment-template/config/marketdata/marketdata.ini b/deployment-template/config/marketdata/marketdata.ini
index 8cd247e..b5f63ef 100644
--- a/deployment-template/config/marketdata/marketdata.ini
+++ b/deployment-template/config/marketdata/marketdata.ini
@@ -7,7 +7,7 @@ time.zone = ${time.zone}
 # Infrastructure
 
 [standardBloombergReferenceDataStatistics]
-factory = com.opengamma.bbg.component.BloombergReferenceDataStatisticsComponentFactory
+factory = com.opengamma.bbg.component.DefaultBloombergReferenceDataStatisticsComponentFactory
 classifier = standard
 
 [standardBloombergConnector]
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/function/ExampleStandardFunctionConfiguration.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/function/ExampleStandardFunctionConfiguration.java
index 91492b4..9e88cd2 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/function/ExampleStandardFunctionConfiguration.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/function/ExampleStandardFunctionConfiguration.java
@@ -477,6 +477,6 @@ public class ExampleStandardFunctionConfiguration extends StandardFunctionConfig
 
   @Override
   protected FunctionConfigurationSource createObject() {
-    return CombiningFunctionConfigurationSource.of(super.createObject(), curveFunctions());
+    return CombiningFunctionConfigurationSource.of(super.createObject(), curveFunctions(), multicurvePricingFunctions());
   }
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AUDSwapPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AUDSwapPortfolioGeneratorTool.java
index b561246..61c8e69 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AUDSwapPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AUDSwapPortfolioGeneratorTool.java
@@ -53,7 +53,7 @@ public class AUDSwapPortfolioGeneratorTool extends AbstractPortfolioGeneratorToo
   /** Semi-annual frequency */
   private static final Frequency SEMI_ANNUAL = PeriodFrequency.SEMI_ANNUAL;
   /** The region */
-  private static final ExternalId REGION =  ExternalSchemes.financialRegionId("AU");
+  private static final ExternalId REGION = ExternalSchemes.financialRegionId("AU");
   /** Following business day convention */
   private static final BusinessDayConvention FOLLOWING = BusinessDayConventions.FOLLOWING;
   /** The notional */
@@ -96,7 +96,7 @@ public class AUDSwapPortfolioGeneratorTool extends AbstractPortfolioGeneratorToo
 
   @Override
   public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
-    final SecurityGenerator<SwapSecurity> securities = createSwapSecurityGenerator();
+    final SecurityGenerator<SwapSecurity> securities = new CollectionSecurityGenerator<>(SWAPS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("AUD Swaps"), positions, 4);
@@ -105,28 +105,28 @@ public class AUDSwapPortfolioGeneratorTool extends AbstractPortfolioGeneratorToo
 
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int portfolioSize) {
-    final SecurityGenerator<SwapSecurity> securities = createSwapSecurityGenerator();
+    final SecurityGenerator<SwapSecurity> securities = new CollectionSecurityGenerator<>(SWAPS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("Swaps"), positions, 4);
   }
 
-  private SecurityGenerator<SwapSecurity> createSwapSecurityGenerator() {
-    final SecurityGenerator<SwapSecurity> securities = new SecurityGenerator<SwapSecurity>() {
-      private int _count;
-
-      @SuppressWarnings("synthetic-access")
-      @Override
-      public SwapSecurity createSecurity() {
-        if (_count > 3) {
-          throw new IllegalStateException("Should not ask for more than 4 securities");
-        }
-        final SwapSecurity swap = SWAPS[_count++];
-        return swap;
-      }
-
-    };
-    configure(securities);
-    return securities;
-  }
+  //  private SecurityGenerator<SwapSecurity> createSwapSecurityGenerator() {
+  //    final SecurityGenerator<SwapSecurity> securities = new SecurityGenerator<SwapSecurity>() {
+  //      private int _count;
+  //
+  //      @SuppressWarnings("synthetic-access")
+  //      @Override
+  //      public SwapSecurity createSecurity() {
+  //        if (_count > 3) {
+  //          throw new IllegalStateException("Should not ask for more than 4 securities");
+  //        }
+  //        final SwapSecurity swap = SWAPS[_count++];
+  //        return swap;
+  //      }
+  //
+  //    };
+  //    configure(securities);
+  //    return securities;
+  //  }
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AbstractSecuritiesGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AbstractSecuritiesGeneratorTool.java
new file mode 100644
index 0000000..69c3121
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/AbstractSecuritiesGeneratorTool.java
@@ -0,0 +1,312 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.util.List;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.opengamma.OpenGammaRuntimeException;
+import com.opengamma.financial.generator.InMemorySecurityPersister;
+import com.opengamma.financial.generator.MasterSecurityPersister;
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.financial.generator.SecurityPersister;
+import com.opengamma.financial.tool.ToolContext;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.master.security.SecurityDocument;
+import com.opengamma.master.security.SecuritySearchRequest;
+import com.opengamma.master.security.SecuritySearchResult;
+import com.opengamma.util.ArgumentChecker;
+
+/**
+ * @author emcleod
+ *
+ * Utility for generating a list of securities.
+ */
+public abstract class AbstractSecuritiesGeneratorTool {
+  /**
+   * Command line option to specify to write to the database masters.
+   */
+  public static final String WRITE_OPT = "write";
+  /**
+   * Command line option to specifying the asset class to generate the portfolio for.
+   */
+  public static final String GENERATOR_OPT = "generator";
+  /** The logger */
+  private static final Logger s_logger = LoggerFactory.getLogger(SyntheticSecuritiesGeneratorTool.class);
+  /** The tool context */
+  private ToolContext _toolContext;
+  /** The class context */
+  private Class<? extends AbstractSecuritiesGeneratorTool> _classContext;
+  /** The object context */
+  private AbstractSecuritiesGeneratorTool _objectContext;
+  /** The security persister */
+  private SecurityPersister _securityPersister;
+
+  /**
+   * Sets the class context to the sub-class.
+   */
+  public AbstractSecuritiesGeneratorTool() {
+    _classContext = getClass();
+  }
+
+  /**
+   * Must be overridden by sub-classes. The securities generator creates
+   * the list of securities.
+   * @return The securities generator
+   * @throws UnsupportedOperationException This method must be overridden
+   * by the sub-class
+   */
+  public SecuritiesGenerator createSecuritiesGenerator() {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Creates a list of {@link ManageableSecurity} from the securities generator.
+   * @return The list of securities
+   */
+  public List<ManageableSecurity> createSecurities() {
+    return createSecuritiesGenerator().createManageableSecurities();
+  }
+
+  /**
+   * Runs this tool given a tool context and command line options. The -s option
+   * is required (this sets the name of the securities generator), and -w will
+   * save the securities to the security master.
+   * @param context The tool context, not null
+   * @param commandLine The command line options, not null
+   */
+  public void run(final ToolContext context, final CommandLine commandLine) {
+    ArgumentChecker.notNull(context, "context");
+    ArgumentChecker.notNull(commandLine, "commandLine");
+    run(context, commandLine.getOptionValue(GENERATOR_OPT), commandLine.hasOption(WRITE_OPT));
+  }
+
+  /**
+   * Runs this tool given a tool context, the securities generator name and a flag
+   * indicating whether or not to write the securities to the database.
+   * @param context The tool context, not null
+   * @param generatorName The securities generator name, not null
+   * @param write True if the securities are to be written to the security master
+   */
+  public void run(final ToolContext context, final String generatorName, final boolean write) {
+    ArgumentChecker.notNull(context, "context");
+    ArgumentChecker.notNull(generatorName, "generatorName");
+    final AbstractSecuritiesGeneratorTool instance = getInstance(getClassContext(), generatorName);
+    instance.setToolContext(context);
+    if (write) {
+      s_logger.info("Creating database security writer");
+      instance.setSecurityPersister(new MasterSecurityPersister(context.getSecurityMaster()));
+    } else {
+      s_logger.info("Using dummy security writer");
+      final InMemorySecurityPersister securityPersister = new InMemorySecurityPersister();
+      instance.setSecurityPersister(securityPersister);
+    }
+    final List<ManageableSecurity> securities = instance.createSecurities();
+    if (write) {
+      s_logger.info("Writing securities to the database");
+      for (final ManageableSecurity security : securities) {
+        final SecuritySearchRequest request = new SecuritySearchRequest();
+        request.setName(security.getName());
+        final SecuritySearchResult result = context.getSecurityMaster().search(request);
+        SecurityDocument document = result.getFirstDocument();
+        if (document != null) {
+          s_logger.warn("Overwriting security {}", document.getUniqueId());
+          document.setSecurity(security);
+          context.getSecurityMaster().update(document);
+        } else {
+          document = new SecurityDocument(security);
+          context.getSecurityMaster().add(document);
+        }
+      }
+    }
+  }
+
+  /**
+   * Gets the tool context.
+   * @return The tool context
+   */
+  public ToolContext getToolContext() {
+    return _toolContext;
+  }
+
+  /**
+   * Sets the tool context.
+   * @param toolContext The tool context
+   */
+  public void setToolContext(final ToolContext toolContext) {
+    _toolContext = toolContext;
+  }
+
+  /**
+   * Gets the security persister.
+   * @return The security persister
+   */
+  public SecurityPersister getSecurityPersister() {
+    return _securityPersister;
+  }
+
+  /**
+   * Sets the security persister.
+   * @param securityPersister The security persister, not null
+   */
+  public void setSecurityPersister(final SecurityPersister securityPersister) {
+    ArgumentChecker.notNull(securityPersister, "securityPersister");
+    _securityPersister = securityPersister;
+  }
+
+  /**
+   * Configures the tool context. If the tool context has been set, sets<p>
+   * <ul>
+   * <li> config source
+   * <li> convention source
+   * <li> convention bundle source
+   * <li> holiday source
+   * <li> historical source
+   * <li> exchange master
+   * <li> region source
+   * <li> legal entity source
+   * <li> security master
+   * <li> historical time series master
+   * </ul>
+   * @param securityGenerator The security generator, not null if the tool context is not null
+   */
+  protected final void configure(final SecurityGenerator<?> securityGenerator) {
+    if (getToolContext() != null) {
+      ArgumentChecker.notNull(securityGenerator, "securityGenerator");
+      securityGenerator.setConfigSource(getToolContext().getConfigSource());
+      securityGenerator.setConventionSource(getToolContext().getConventionSource());
+      securityGenerator.setConventionBundleSource(getToolContext().getConventionBundleSource());
+      securityGenerator.setHolidaySource(getToolContext().getHolidaySource());
+      securityGenerator.setHistoricalSource(getToolContext().getHistoricalTimeSeriesSource());
+      securityGenerator.setExchangeMaster(getToolContext().getExchangeMaster());
+      securityGenerator.setRegionSource(getToolContext().getRegionSource());
+      securityGenerator.setLegalEntitySource(getToolContext().getLegalEntitySource());
+      securityGenerator.setSecurityMaster(getToolContext().getSecurityMaster());
+      securityGenerator.setHistoricalTimeSeriesMaster(getToolContext().getHistoricalTimeSeriesMaster());
+    }
+    configureChain(securityGenerator);
+  }
+
+  /**
+   * Configures the chain for this tool and security generator
+   * @param securityGenerator The security generator, not null if the object context is not null
+   */
+  protected void configureChain(final SecurityGenerator<?> securityGenerator) {
+    if (getObjectContext() != null) {
+      ArgumentChecker.notNull(securityGenerator, "securityGenerator");
+      getObjectContext().configureChain(securityGenerator);
+    }
+  }
+
+  /**
+   * Configures the chain for this tool by setting the tool context and security persister.
+   * @param tool The tool, not null
+   */
+  protected void configure(final AbstractSecuritiesGeneratorTool tool) {
+    if (getToolContext() != null) {
+      ArgumentChecker.notNull(tool, "tool");
+      tool.setToolContext(getToolContext());
+    }
+    if (getSecurityPersister() != null) {
+      ArgumentChecker.notNull(tool, "tool");
+      tool.setSecurityPersister(getSecurityPersister());
+    }
+  }
+
+  /**
+   * Sets the class context and the object context for this tool.
+   * @param classContext The class context
+   * @param objectContext The object context
+   */
+  private void setContext(final Class<? extends AbstractSecuritiesGeneratorTool> classContext, final AbstractSecuritiesGeneratorTool objectContext) {
+    _classContext = classContext;
+    _objectContext = objectContext;
+  }
+
+  /**
+   * Gets the class context. 
+   * @return The class context
+   */
+  private Class<? extends AbstractSecuritiesGeneratorTool> getClassContext() {
+    return _classContext;
+  }
+
+  /**
+   * Gets the object context.
+   * @return The object context
+   */
+  private AbstractSecuritiesGeneratorTool getObjectContext() {
+    return _objectContext;
+  }
+
+  /**
+   * Gets an instance of the tool given its class and name. If the generator name is not a 
+   * full path (i.e. contains a "."), this tool looks in the directory of this class for a 
+   * class named [generatorName]SecuritiesGeneratorTool or [generatorName]SecurityGeneratorTool. 
+   * If the class is not found, tries the superclass of the required tool. 
+   * @param clazz The class of the required securities generator tool
+   * @param generatorName The name
+   * @return The tool
+   * @throws OpenGammaRuntimeException If the securities generator cannot be found or instantiated
+   */
+  private AbstractSecuritiesGeneratorTool getInstance(final Class<?> clazz, final String generatorName) {
+    if (!AbstractSecuritiesGeneratorTool.class.isAssignableFrom(clazz)) {
+      throw new OpenGammaRuntimeException("Couldn't find securites generator tool class for " + generatorName);
+    }
+    try {
+      final String className;
+      String alternativeClassName = null;
+      final int i = generatorName.indexOf('.');
+      if (i < 0) {
+        className = clazz.getPackage().getName() + "." + generatorName + "SecuritiesGeneratorTool";
+        alternativeClassName = clazz.getPackage().getName() + "." + generatorName + "SecurityGeneratorTool";
+      } else {
+        className = generatorName;
+      }
+      Class<?> instanceClass;
+      try {
+        s_logger.debug("Trying class {}", className);
+        instanceClass = Class.forName(className);
+      } catch (final ClassNotFoundException e) {
+        try {
+          s_logger.debug("Trying class {}", alternativeClassName);
+          instanceClass = Class.forName(alternativeClassName);
+        } catch (final ClassNotFoundException e1) {
+          return getInstance(clazz.getSuperclass(), generatorName);
+        }
+      }
+      s_logger.info("Loading {}", className);
+      final AbstractSecuritiesGeneratorTool tool = (AbstractSecuritiesGeneratorTool) instanceClass.newInstance();
+      tool.setContext(getClassContext(), this);
+      return tool;
+    } catch (final Exception e) {
+      throw new OpenGammaRuntimeException("Couldn't create securities generator tool instance for " + generatorName, e);
+    }
+  }
+
+  /**
+   * Sets the required field on an option to true.
+   * @param option The option 
+   * @return The option with the required field set to true
+   */
+  private static Option required(final Option option) {
+    option.setRequired(true);
+    return option;
+  }
+
+  /**
+   * Sets the options for this tool: -s for the security generator name, -w to write to the 
+   * security master
+   * @param options The options
+   */
+  public void createOptions(final Options options) {
+    options.addOption(required(new Option("s", GENERATOR_OPT, true, "selects the security generator")));
+    options.addOption(new Option("w", WRITE_OPT, false, "writes the securities to the master"));
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondCurveSecuritiesGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondCurveSecuritiesGeneratorTool.java
new file mode 100644
index 0000000..7801c69
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondCurveSecuritiesGeneratorTool.java
@@ -0,0 +1,95 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import org.threeten.bp.LocalDate;
+import org.threeten.bp.ZoneOffset;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.financial.analytics.ircurve.strips.BillNode;
+import com.opengamma.financial.analytics.ircurve.strips.BondNode;
+import com.opengamma.financial.convention.daycount.DayCount;
+import com.opengamma.financial.convention.daycount.DayCounts;
+import com.opengamma.financial.convention.frequency.Frequency;
+import com.opengamma.financial.convention.frequency.PeriodFrequency;
+import com.opengamma.financial.convention.yield.SimpleYieldConvention;
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.financial.security.bond.BillSecurity;
+import com.opengamma.financial.security.bond.BondSecurity;
+import com.opengamma.financial.security.bond.GovernmentBondSecurity;
+import com.opengamma.id.ExternalId;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.masterdb.legalentity.DbLegalEntityBeanMaster;
+import com.opengamma.util.i18n.Country;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.Expiry;
+import com.opengamma.util.time.Tenor;
+
+/**
+ * @author emcleod
+ *
+ * Generates bill and bond securities that are required for construction of curves
+ * containing {@link BillNode} and {@link BondNode}. These securities must be 
+ * present in the security database for successful curve construction.
+ */
+public class BondCurveSecuritiesGeneratorTool extends AbstractSecuritiesGeneratorTool {
+  /** The bills and bonds */
+  private static final List<ManageableSecurity> SECURITIES = new ArrayList<>();
+
+  static {
+    final ExternalId region = ExternalSchemes.countryRegionId(Country.US);
+    DayCount dayCount = DayCounts.ACT_360;
+    final Frequency frequency = PeriodFrequency.SEMI_ANNUAL;
+    final ExternalId legalEntityId = ExternalId.of(DbLegalEntityBeanMaster.IDENTIFIER_SCHEME_DEFAULT, "US Government");
+    final ZonedDateTime referenceDate = LocalDate.now().atStartOfDay(ZoneOffset.UTC);
+    for (int i = 6; i <= 18; i += 6) {
+      final Tenor tenor = Tenor.ofMonths(i);
+      final BillSecurity bill = new BillSecurity(Currency.USD, new Expiry(referenceDate.plus(tenor.getPeriod())), referenceDate,
+          100, 2, region, SimpleYieldConvention.INTERESTATMTY, dayCount, legalEntityId);
+      String suffix;
+      if (i < 10) {
+        suffix = "00" + Integer.toString(i);
+      } else {
+        suffix = "0" + Integer.toString(i);
+      }
+      final String isin = "USB000000" + suffix;
+      bill.setName(isin);
+      bill.setExternalIdBundle(ExternalSchemes.syntheticSecurityId(isin).toBundle());
+      SECURITIES.add(bill);
+    }
+    final Random rng = new Random(457);
+    dayCount = DayCounts.ACT_ACT_ICMA;
+    for (final int i : new int[] {2, 3, 5, 7, 10, 20, 30 }) {
+      final double coupon = (i > 7 ? 0.5 * i : 0.2 * i) + rng.nextDouble();
+      final Tenor tenor = Tenor.ofYears(i);
+      final BondSecurity bond = new GovernmentBondSecurity("US TREASURY N/B", "Sovereign", "US", "US GOVERNMENT", Currency.USD, SimpleYieldConvention.US_STREET,
+          new Expiry(referenceDate.plus(tenor.getPeriod())), "FIXED", coupon, frequency, dayCount, referenceDate, referenceDate, referenceDate.plusMonths(6),
+          100., 1000000, 100, 100, 100, 100);
+      String suffix;
+      if (i < 10) {
+        suffix = "00" + Integer.toString(i);
+      } else if (i < 100) {
+        suffix = "0" + Integer.toString(i);
+      } else {
+        suffix = Integer.toString(i);
+      }
+      final String isin = "UST000000" + suffix;
+      bond.setName(isin);
+      bond.setExternalIdBundle(ExternalSchemes.syntheticSecurityId(isin).toBundle());
+      SECURITIES.add(bond);
+    }
+  }
+
+  @Override
+  public SecuritiesGenerator createSecuritiesGenerator() {
+    final SecurityGenerator<ManageableSecurity> securityGenerator = new CollectionSecurityGenerator<>(SECURITIES);
+    configure(securityGenerator);
+    return new SecuritiesGenerator(securityGenerator, SECURITIES.size());
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondPortfolioGeneratorTool.java
index ed734b4..d17c9b3 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/BondPortfolioGeneratorTool.java
@@ -36,7 +36,7 @@ import com.opengamma.util.time.DateUtils;
 import com.opengamma.util.time.Expiry;
 
 /**
- * Generates a portfolio of AUD swaps.
+ * Generates a portfolio of US government bonds.
  */
 public class BondPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool {
   /** The counterparty */
@@ -64,57 +64,65 @@ public class BondPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool {
     final GovernmentBondSecurity bond1 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2019, 2, 15)), couponType, 2.75, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2009, 2, 15),
         DateUtils.getUTCDate(2009, 2, 15), DateUtils.getUTCDate(2009, 8, 15), 98.3, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond1.setName("T 2 3/4 02/15/19");
-    bond1.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000004")));
+    String name = "T 2 3/4 02/15/19";
+    bond1.setName(name);
+    bond1.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[0] = bond1;
     AMOUNTS[0] = -140000;
     final GovernmentBondSecurity bond2 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2017, 12, 15)), couponType, 2.75, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2010, 12, 31),
         DateUtils.getUTCDate(2010, 12, 31), DateUtils.getUTCDate(2011, 6, 30), 99.4, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond2.setName("T 2 3/4 12/15/17");
-    bond2.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000002")));
+    name = "T 2 3/4 12/15/17";
+    bond2.setName(name);
+    bond2.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[1] = bond2;
     AMOUNTS[1] = 350000;
     final GovernmentBondSecurity bond3 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2018, 4, 30)), couponType, 2.625, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2011, 4, 30),
         DateUtils.getUTCDate(2011, 4, 30), DateUtils.getUTCDate(2011, 10, 31), 99.4, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond3.setName("T 2 5/8 04/30/18");
-    bond3.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000003")));
+    name = "T 2 5/8 04/30/18";
+    bond3.setName(name);
+    bond3.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[2] = bond3;
     AMOUNTS[2] = 650000;
     final GovernmentBondSecurity bond4 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2021, 5, 15)), couponType, 3.125, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2011, 5, 15),
         DateUtils.getUTCDate(2011, 5, 15), DateUtils.getUTCDate(2011, 11, 15), 101.3, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond4.setName("T 3 1/8 15/05/21");
-    bond4.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000006")));
+    name = "T 3 1/8 15/05/21";
+    bond4.setName(name);
+    bond4.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[3] = bond4;
     AMOUNTS[3] = -100000;
     final GovernmentBondSecurity bond5 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2040, 8, 15)), couponType, 3.875, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2010, 8, 15),
         DateUtils.getUTCDate(2010, 8, 15), DateUtils.getUTCDate(2011, 2, 15), 100.4, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond5.setName("T 3 7/8 08/15/40");
-    bond5.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000008")));
+    name = "T 3 7/8 08/15/40";
+    bond5.setName(name);
+    bond5.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[4] = bond5;
     AMOUNTS[4] = -130000;
     final GovernmentBondSecurity bond6 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2017, 11, 30)), couponType, 2.5, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2010, 11, 30),
         DateUtils.getUTCDate(2010, 11, 30), DateUtils.getUTCDate(2011, 5, 31), 100., totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond6.setName("T 2 1/2 11/30/17");
-    bond6.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000001")));
+    name = "T 2 1/2 11/30/17";
+    bond6.setName(name);
+    bond6.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[5] = bond6;
     AMOUNTS[5] = 120000;
     final GovernmentBondSecurity bond7 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2039, 5, 15)), couponType, 4.25, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2009, 5, 15),
         DateUtils.getUTCDate(2009, 5, 15), DateUtils.getUTCDate(2009, 11, 15), 99.1, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond7.setName("T 4 1/4 05/15/39");
-    bond7.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000007")));
+    name = "T 4 1/4 05/15/39";
+    bond7.setName(name);
+    bond7.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[6] = bond7;
     AMOUNTS[6] = 230000;
     final GovernmentBondSecurity bond8 = new GovernmentBondSecurity(issuerName, issuerType, issuerDomicile, market, currency,
         yieldConvention, new Expiry(DateUtils.getUTCDate(2019, 11, 15)), couponType, 3.375, couponFrequency, dayCountConvention, DateUtils.getUTCDate(2009, 11, 15),
         DateUtils.getUTCDate(2009, 11, 15), DateUtils.getUTCDate(2010, 5, 15), 96.9, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
-    bond8.setName("T 3 3/8 11/15/19");
-    bond8.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId("US0000000005")));
+    name = "T 3 3/8 11/15/19";
+    bond8.setName(name);
+    bond8.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
     BONDS[7] = bond8;
     AMOUNTS[7] = -250000;
   }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/CollectionSecurityGenerator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/CollectionSecurityGenerator.java
new file mode 100644
index 0000000..23a528d
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/CollectionSecurityGenerator.java
@@ -0,0 +1,50 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.util.ArgumentChecker;
+
+/**
+ * @author emcleod
+ *
+ * Security generator that wraps a collection of securities. The securities are generated
+ * with repeated calls to {{@link #createSecurity()} and an exception is thrown if more
+ * securities are requested than were provided in the original collection. The order in
+ * which the securities are returned depends on the original collection.
+ * @param <T>
+ */
+public class CollectionSecurityGenerator<T extends ManageableSecurity> extends SecurityGenerator<T> {
+  /** The iterator */
+  private final Iterator<T> _iterator;
+
+  /**
+   * @param securities The securities, not null
+   */
+  public CollectionSecurityGenerator(final Collection<T> securities) {
+    ArgumentChecker.notNull(securities, "securities");
+    _iterator = securities.iterator();
+  }
+
+  /**
+   * @param securities The securities, not null
+   */
+  public CollectionSecurityGenerator(final T[] securities) {
+    ArgumentChecker.notNull(securities, "securities");
+    _iterator = Arrays.asList(securities).iterator();
+  }
+
+  @Override
+  public T createSecurity() {
+    if (_iterator.hasNext()) {
+      return _iterator.next();
+    }
+    throw new IllegalStateException("Asked for more securities than were provided to the generator");
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FXVolatilitySwapPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FXVolatilitySwapPortfolioGeneratorTool.java
index e22e33e..c1627fb 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FXVolatilitySwapPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FXVolatilitySwapPortfolioGeneratorTool.java
@@ -71,7 +71,7 @@ public class FXVolatilitySwapPortfolioGeneratorTool extends AbstractPortfolioGen
 
   @Override
   public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
-    final SecurityGenerator<ManageableSecurity> securities = createFXVolatilitySwapSecurityGenerator(FX_VOLATILITY_SWAPS.size());
+    final SecurityGenerator<ManageableSecurity> securities = new CollectionSecurityGenerator<>(FX_VOLATILITY_SWAPS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Volatility Swaps"), positions, FX_VOLATILITY_SWAPS.size());
@@ -80,33 +80,10 @@ public class FXVolatilitySwapPortfolioGeneratorTool extends AbstractPortfolioGen
 
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int portfolioSize) {
-    final SecurityGenerator<ManageableSecurity> securities = createFXVolatilitySwapSecurityGenerator(FX_VOLATILITY_SWAPS.size());
+    final SecurityGenerator<ManageableSecurity> securities = new CollectionSecurityGenerator<>(FX_VOLATILITY_SWAPS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Volatility Swaps"), positions, FX_VOLATILITY_SWAPS.size());
   }
 
-  /**
-   * Creates a security generator that loops over the list of FX volatility swaps.
-   * @size The expected size of the portfolio
-   * @return The security generator
-   */
-  private SecurityGenerator<ManageableSecurity> createFXVolatilitySwapSecurityGenerator(final int size) {
-    final SecurityGenerator<ManageableSecurity> securities = new SecurityGenerator<ManageableSecurity>() {
-      private int _count;
-
-      @SuppressWarnings("synthetic-access")
-      @Override
-      public ManageableSecurity createSecurity() {
-        if (_count > size - 1) {
-          throw new IllegalStateException("Should not ask for more than " + size + " securities");
-        }
-        final ManageableSecurity fxVolatilitySwap = FX_VOLATILITY_SWAPS.get(_count++);
-        return fxVolatilitySwap;
-      }
-
-    };
-    configure(securities);
-    return securities;
-  }
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FxForwardPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FxForwardPortfolioGeneratorTool.java
index a85f1d8..0c5fda2 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FxForwardPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/FxForwardPortfolioGeneratorTool.java
@@ -89,7 +89,7 @@ public class FxForwardPortfolioGeneratorTool extends AbstractPortfolioGeneratorT
 
   @Override
   public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
-    final SecurityGenerator<FXForwardSecurity> securities = createFXForwardSecurityGenerator();
+    final SecurityGenerator<FXForwardSecurity> securities = new CollectionSecurityGenerator<>(FX_FORWARDS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Forwards"), positions, FX_FORWARDS.size());
@@ -98,26 +98,10 @@ public class FxForwardPortfolioGeneratorTool extends AbstractPortfolioGeneratorT
 
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int portfolioSize) {
-    final SecurityGenerator<FXForwardSecurity> securities = createFXForwardSecurityGenerator();
+    final SecurityGenerator<FXForwardSecurity> securities = new CollectionSecurityGenerator<>(FX_FORWARDS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Forwards"), positions, FX_FORWARDS.size());
   }
 
-  private SecurityGenerator<FXForwardSecurity> createFXForwardSecurityGenerator() {
-    final SecurityGenerator<FXForwardSecurity> securities = new SecurityGenerator<FXForwardSecurity>() {
-      private int _count;
-
-      @SuppressWarnings("synthetic-access")
-      @Override
-      public FXForwardSecurity createSecurity() {
-        final FXForwardSecurity fxForward = FX_FORWARDS.get(_count++);
-        return fxForward;
-      }
-
-    };
-    configure(securities);
-    return securities;
-  }
-
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexPortfolioGeneratorTool.java
index c90839e..2ef21d7 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexPortfolioGeneratorTool.java
@@ -27,8 +27,10 @@ import com.opengamma.util.time.Tenor;
 
 /**
  * Creates a portfolio of indices. 
+ * @deprecated The index portfolio is only created to load the index securities. {@link IndexSecuritiesGeneratorTool} should be
+ * used for this, as it does not create an unnecessary portfolio.
  */
-// TODO what is the best way to do load these index securities? There is no need to create the portfolio 
+@Deprecated
 public class IndexPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool {
   /** The indices */
   private static final List<ManageableSecurity> INDICES = new ArrayList<>();
@@ -65,30 +67,10 @@ public class IndexPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool
 
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int size) {
-    final SecurityGenerator<ManageableSecurity> securities = createIndexSecurityGenerator();
+    final SecurityGenerator<ManageableSecurity> securities = new CollectionSecurityGenerator<>(INDICES);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("Indices"), positions, INDICES.size());
   }
 
-  /**
-   * Creates a security generator that loops over the list of indices.
-   * @return The security generator
-   */
-  private SecurityGenerator<ManageableSecurity> createIndexSecurityGenerator() {
-    final SecurityGenerator<ManageableSecurity> securities = new SecurityGenerator<ManageableSecurity>() {
-      private int _count;
-
-      @SuppressWarnings("synthetic-access")
-      @Override
-      public ManageableSecurity createSecurity() {
-        final ManageableSecurity index = INDICES.get(_count++);
-        return index;
-      }
-
-    };
-    configure(securities);
-    return securities;
-  }
-
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexSecuritiesGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexSecuritiesGeneratorTool.java
new file mode 100644
index 0000000..49b4292
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/IndexSecuritiesGeneratorTool.java
@@ -0,0 +1,79 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.financial.convention.InMemoryConventionBundleMaster;
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.financial.security.index.IborIndex;
+import com.opengamma.financial.security.index.OvernightIndex;
+import com.opengamma.financial.security.index.SwapIndex;
+import com.opengamma.id.ExternalId;
+import com.opengamma.id.ExternalIdBundle;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.util.time.Tenor;
+
+/**
+ * Creates a list of indices. 
+ */
+public class IndexSecuritiesGeneratorTool extends AbstractSecuritiesGeneratorTool {
+  /** The indices */
+  private static final List<ManageableSecurity> INDICES = new ArrayList<>();
+
+  static {
+    final String[] currencies = new String[] {"USD", "EUR", "JPY", "CHF", "GBP" };
+    final String[] overnightTickers = new String[] {"USDFF", "EONIA", "TONAR", "TOISTOIS", "SONIO" };
+    Tenor[] tenors = new Tenor[] {Tenor.ONE_MONTH, Tenor.TWO_MONTHS, Tenor.THREE_MONTHS, Tenor.FOUR_MONTHS, Tenor.FIVE_MONTHS, Tenor.SIX_MONTHS };
+    for (final Tenor tenor : tenors) {
+      final String iborTicker = "EUREURIBOR" + tenor.toFormattedString();
+      final String referenceRateTicker = " EURIBOR " + tenor.toFormattedString().substring(1).toLowerCase();
+      final ExternalId iborIndexId = ExternalSchemes.syntheticSecurityId(iborTicker);
+      final ExternalId iborIndexReferenceRateId = ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, referenceRateTicker);
+      final IborIndex iborIndex = new IborIndex(iborTicker, tenor, iborIndexId);
+      iborIndex.setExternalIdBundle(ExternalIdBundle.of(iborIndexId, iborIndexReferenceRateId));
+      iborIndex.setName(iborTicker);
+      INDICES.add(iborIndex);
+    }
+    for (int i = 0; i < currencies.length; i++) {
+      final String currency = currencies[i];
+      final String overnightTicker = overnightTickers[i];
+      for (final Tenor tenor : tenors) {
+        final String iborTicker = currency + "LIBOR" + tenor.toFormattedString();
+        final String referenceRateTicker = currency + " LIBOR " + tenor.toFormattedString().substring(1).toLowerCase();
+        final ExternalId iborIndexId = ExternalSchemes.syntheticSecurityId(iborTicker);
+        final ExternalId iborIndexReferenceRateId = ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, referenceRateTicker);
+        final IborIndex iborIndex = new IborIndex(iborTicker, tenor, iborIndexId);
+        iborIndex.setExternalIdBundle(ExternalIdBundle.of(iborIndexId, iborIndexReferenceRateId));
+        iborIndex.setName(iborTicker);
+        INDICES.add(iborIndex);
+      }
+      final ExternalId overnightIndexId = ExternalSchemes.syntheticSecurityId(overnightTickers[i]);
+      final OvernightIndex overnightIndex = new OvernightIndex(overnightTicker, overnightIndexId);
+      overnightIndex.setExternalIdBundle(overnightIndexId.toBundle());
+      overnightIndex.setName(overnightTicker);
+      INDICES.add(overnightIndex);
+    }
+    tenors = new Tenor[] {Tenor.ONE_YEAR, Tenor.TWO_YEARS, Tenor.THREE_YEARS, Tenor.FIVE_YEARS, Tenor.TEN_YEARS };
+    for (final Tenor tenor : tenors) {
+      final String swapIndexTicker = "USDISDA" + 10 + tenor.toFormattedString().toUpperCase();
+      final SwapIndex swapIndex = new SwapIndex(swapIndexTicker, tenor, ExternalSchemes.syntheticSecurityId("USD ISDA Fixing"));
+      swapIndex.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(swapIndexTicker)));
+      swapIndex.setName(swapIndexTicker);
+      INDICES.add(swapIndex);
+    }
+  }
+
+  @Override
+  public SecuritiesGenerator createSecuritiesGenerator() {
+    final SecurityGenerator<ManageableSecurity> securityGenerator = new CollectionSecurityGenerator<>(INDICES);
+    configure(securityGenerator);
+    return new SecuritiesGenerator(securityGenerator, INDICES.size());
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/MixedBondPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/MixedBondPortfolioGeneratorTool.java
new file mode 100644
index 0000000..bbcdea1
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/MixedBondPortfolioGeneratorTool.java
@@ -0,0 +1,188 @@
+/**
+ *
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+
+import org.threeten.bp.LocalDate;
+import org.threeten.bp.ZoneOffset;
+import org.threeten.bp.ZonedDateTime;
+import org.threeten.bp.format.DateTimeFormatter;
+
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.core.position.Counterparty;
+import com.opengamma.core.position.PortfolioNode;
+import com.opengamma.core.position.Position;
+import com.opengamma.core.position.impl.SimplePortfolioNode;
+import com.opengamma.financial.convention.daycount.DayCount;
+import com.opengamma.financial.convention.daycount.DayCounts;
+import com.opengamma.financial.convention.frequency.Frequency;
+import com.opengamma.financial.convention.frequency.PeriodFrequency;
+import com.opengamma.financial.convention.yield.YieldConventionFactory;
+import com.opengamma.financial.generator.AbstractPortfolioGeneratorTool;
+import com.opengamma.financial.generator.LeafPortfolioNodeGenerator;
+import com.opengamma.financial.generator.NameGenerator;
+import com.opengamma.financial.generator.PortfolioGenerator;
+import com.opengamma.financial.generator.PortfolioNodeGenerator;
+import com.opengamma.financial.generator.PositionGenerator;
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.financial.generator.SimplePositionGenerator;
+import com.opengamma.financial.generator.StaticNameGenerator;
+import com.opengamma.financial.security.bond.BondSecurity;
+import com.opengamma.financial.security.bond.GovernmentBondSecurity;
+import com.opengamma.id.ExternalId;
+import com.opengamma.id.ExternalIdBundle;
+import com.opengamma.master.position.ManageableTrade;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.Expiry;
+
+/**
+ * @author emcleod
+ * Generates a portfolio of fixed-coupon bonds.
+ */
+public class MixedBondPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool {
+  /** The counterparty */
+  private static final String COUNTERPARTY = "Cpty";
+  /** Bonds */
+  private static final List<BondSecurity> BONDS = new ArrayList<>();
+  /** Amounts of each bond */
+  private static final List<Double> AMOUNTS = new ArrayList<>();
+  /** List of (issuer domicile, currency, issuer name, issuer type, market, yield convention name, coupon type, issuer prefix) */
+  private static final List<List<String>> ISSUERS = new ArrayList<>();
+
+  static {
+    ISSUERS.add(Arrays.asList("US", "USD", "US TREASURY N/B", "Sovereign", "US GOVERNMENT", "US street", "FIXED", "T "));
+    final Frequency couponFrequency = PeriodFrequency.SEMI_ANNUAL;
+    final DayCount dayCountConvention = DayCounts.ACT_ACT_ICMA;
+    final double totalAmountIssued = 10000000000.;
+    final double minimumAmount = 100;
+    final double minimumIncrement = 100;
+    final double parAmount = 100;
+    final double redemptionValue = 100;
+    final int nBonds = 100;
+    final Random rng = new Random(345);
+    final LocalDate referenceDate = LocalDate.now().minusYears(1).withMonth(2).withDayOfMonth(15);
+    for (int i = 0; i < nBonds; i++) {
+      final List<String> issuer = ISSUERS.get(rng.nextInt(ISSUERS.size()));
+      final int monthsAhead = 18 + rng.nextInt(50) * 6;
+      final ZonedDateTime maturity = referenceDate.plusMonths(monthsAhead).atStartOfDay(ZoneOffset.UTC);
+      final int tenor = monthsAhead + 6 * (1 + rng.nextInt(20));
+      final ZonedDateTime startDate = maturity.minusMonths(tenor);
+      final double coupon = (1 + rng.nextInt(39)) / 8.;
+      final double issuePrice = 100 - 3 * rng.nextDouble();
+      final GovernmentBondSecurity bond = new GovernmentBondSecurity(issuer.get(2), issuer.get(3), issuer.get(0), issuer.get(4), Currency.of(issuer.get(1)),
+          YieldConventionFactory.of(issuer.get(5)), new Expiry(maturity), issuer.get(6), coupon, couponFrequency, dayCountConvention,
+          startDate, startDate, startDate.plusMonths(6), issuePrice, totalAmountIssued, minimumAmount, minimumIncrement, parAmount, redemptionValue);
+      final String name = generateName(issuer.get(7), maturity.toLocalDate(), coupon);
+      bond.setName(name);
+      bond.setExternalIdBundle(ExternalIdBundle.of(ExternalSchemes.syntheticSecurityId(name)));
+      BONDS.add(bond);
+      AMOUNTS.add(10000. * (1 + rng.nextInt(200)));
+    }
+  }
+
+  /**
+   * Generates a ticker / coupon / maturity name for a bond.
+   * @param issuerPrefix The bond prefix for an issuer 
+   * @param maturity The bond maturity date
+   * @param coupon The (fixed) coupon
+   * @return The T/C/M
+   */
+  private static String generateName(final String issuerPrefix, final LocalDate maturity, final double coupon) {
+    final StringBuilder sb = new StringBuilder(issuerPrefix);
+    final int floor = (int) Math.floor(coupon);
+    final double remainder = coupon - floor;
+    final StringBuilder couponString = new StringBuilder(Integer.toString(floor));
+    couponString.append(" ");
+    if (Double.compare(floor, coupon) != 0) {
+      boolean remainderSet = false;
+      for (int i = 2; i <= 8; i *= 2) {
+        final double scaled = remainder * i;
+        if (scaled == Math.round(remainder * i)) {
+          couponString.append(Integer.toString((int) scaled));
+          couponString.append("/");
+          couponString.append(Integer.toString(i));
+          remainderSet = true;
+          break;
+        }
+      }
+      if (!remainderSet) {
+        throw new IllegalArgumentException("Coupon was not expressed in 8ths");
+      }
+    }
+    sb.append(couponString);
+    sb.append(" ");
+    sb.append(maturity.toString(DateTimeFormatter.ofPattern("MM/dd/yy")));
+    return sb.toString();
+  }
+
+  @Override
+  public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
+    final BondSecurityAndPositionGenerator securitiesAndPositions = new BondSecurityAndPositionGenerator(BONDS, AMOUNTS);
+    configure(securitiesAndPositions);
+    final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("Bonds"), securitiesAndPositions, BONDS.size());
+    return new PortfolioGenerator(rootNode, portfolioNameGenerator);
+  }
+
+  @Override
+  public PortfolioNodeGenerator createPortfolioNodeGenerator(final int portfolioSize) {
+    final BondSecurityAndPositionGenerator securitiesAndPositions = new BondSecurityAndPositionGenerator(BONDS, AMOUNTS);
+    configure(securitiesAndPositions);
+    return new LeafPortfolioNodeGenerator(new StaticNameGenerator("Bonds"), securitiesAndPositions, BONDS.size());
+  }
+
+  /**
+   * Creates a security, position and portfolio node for list of government bond securities.
+   */
+  private class BondSecurityAndPositionGenerator extends SecurityGenerator<BondSecurity> implements PortfolioNodeGenerator, PositionGenerator {
+    /** The securities */
+    private final List<BondSecurity> _securities;
+    /** The amounts */
+    private final List<Double> _amounts;
+    /** The security count */
+    private int _securityCount;
+    /** The position count */
+    private int _positionCount;
+
+    /**
+     * @param securities The government bond securities
+     * @param amounts The amount in each position
+     */
+    public BondSecurityAndPositionGenerator(final List<BondSecurity> securities, final List<Double> amounts) {
+      _securities = securities;
+      _amounts = amounts;
+    }
+
+    @Override
+    public PortfolioNode createPortfolioNode() {
+      final SimplePortfolioNode node = new SimplePortfolioNode("Bonds");
+      for (int i = 0; i < _securities.size(); i++) {
+        node.addPosition(createPosition());
+      }
+      return node;
+    }
+
+    @Override
+    public BondSecurity createSecurity() {
+      return _securities.get(_securityCount++);
+    }
+
+    @Override
+    public Position createPosition() {
+      final BigDecimal n = new BigDecimal(_amounts.get(_positionCount));
+      final BondSecurity bond = _securities.get(_positionCount++);
+      final ZonedDateTime tradeDate = bond.getSettlementDate();
+      final ManageableTrade trade = new ManageableTrade(n, getSecurityPersister().storeSecurity(bond), tradeDate.toLocalDate(),
+          tradeDate.toOffsetDateTime().toOffsetTime(), ExternalId.of(Counterparty.DEFAULT_SCHEME, COUNTERPARTY));
+      trade.setPremium(bond.getIssuancePrice());
+      trade.setPremiumCurrency(bond.getCurrency());
+      trade.setPremiumDate(tradeDate.toLocalDate());
+      return SimplePositionGenerator.createPositionFromTrade(trade);
+    }
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SecuritiesGenerator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SecuritiesGenerator.java
new file mode 100644
index 0000000..d3b0ab8
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SecuritiesGenerator.java
@@ -0,0 +1,85 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang.ObjectUtils;
+
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.util.ArgumentChecker;
+
+/**
+ * @author emcleod
+ *
+ * Utility class for generating a list of securities.
+ */
+public class SecuritiesGenerator {
+  /** The security generator */
+  private final SecurityGenerator<? extends ManageableSecurity> _securityGenerator;
+  /** The number of securities to generate */
+  private final int _numberOfSecurities;
+
+  /**
+   * @param securityGenerator The security generator, not null
+   * @param numberOfSecurities The number of securities to generate
+   */
+  public SecuritiesGenerator(final SecurityGenerator<? extends ManageableSecurity> securityGenerator, final int numberOfSecurities) {
+    ArgumentChecker.notNull(securityGenerator, "securityGenerator");
+    _securityGenerator = securityGenerator;
+    _numberOfSecurities = numberOfSecurities;
+  }
+
+  /**
+   * Generates a list of securities. This method attempts to generate the number of {{@link #_numberOfSecurities} 
+   * without checking that this is possible. It is the responsibility of the underlying security generator to 
+   * perform this check.
+   * @return A list of manageable securities
+   */
+  public List<ManageableSecurity> createManageableSecurities() {
+    final List<ManageableSecurity> securities = new ArrayList<>();
+    for (int i = 0; i < _numberOfSecurities; i++) {
+      securities.add(_securityGenerator.createSecurity());
+    }
+    return securities;
+  }
+
+  /**
+   * Gets the security generator.
+   * @return The security generator
+   */
+  protected SecurityGenerator<? extends ManageableSecurity> getSecurityGenerator() {
+    return _securityGenerator;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + _numberOfSecurities;
+    result = prime * result + _securityGenerator.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!(obj instanceof SecuritiesGenerator)) {
+      return false;
+    }
+    final SecuritiesGenerator other = (SecuritiesGenerator) obj;
+    if (_numberOfSecurities != other._numberOfSecurities) {
+      return false;
+    }
+    if (!ObjectUtils.equals(_securityGenerator, other._securityGenerator)) {
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SwaptionPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SwaptionPortfolioGeneratorTool.java
index 42b5bf8..cb16fda 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SwaptionPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SwaptionPortfolioGeneratorTool.java
@@ -77,7 +77,7 @@ public class SwaptionPortfolioGeneratorTool extends AbstractPortfolioGeneratorTo
   @Override
   public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
     final SwaptionSecurity[] swaptions = createSwaptions(PORTFOLIO_SIZE);
-    final SecurityGenerator<SwaptionSecurity> securities = createSwaptionSecurityGenerator(swaptions, PORTFOLIO_SIZE);
+    final SecurityGenerator<SwaptionSecurity> securities = new CollectionSecurityGenerator<>(swaptions);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("Swaptions"), positions, PORTFOLIO_SIZE);
@@ -87,7 +87,7 @@ public class SwaptionPortfolioGeneratorTool extends AbstractPortfolioGeneratorTo
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int size) {
     final SwaptionSecurity[] swaptions = createSwaptions(size);
-    final SecurityGenerator<SwaptionSecurity> securities = createSwaptionSecurityGenerator(swaptions, size);
+    final SecurityGenerator<SwaptionSecurity> securities = new CollectionSecurityGenerator<>(swaptions);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("Swaptions"), positions, size);
@@ -146,20 +146,4 @@ public class SwaptionPortfolioGeneratorTool extends AbstractPortfolioGeneratorTo
     return swaptions;
   }
 
-  private SecurityGenerator<SwaptionSecurity> createSwaptionSecurityGenerator(final SwaptionSecurity[] swaptions, final int size) {
-    final SecurityGenerator<SwaptionSecurity> securities = new SecurityGenerator<SwaptionSecurity>() {
-      private int _count;
-
-      @Override
-      public SwaptionSecurity createSecurity() {
-        if (_count > size - 1) {
-          throw new IllegalStateException("Should not ask for more than " + size + " securities");
-        }
-        return swaptions[_count++];
-      }
-    };
-    configure(securities);
-    return securities;
-  };
-
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticPortfolioGeneratorTool.java
index 2164620..10deb07 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticPortfolioGeneratorTool.java
@@ -5,8 +5,6 @@
  */
 package com.opengamma.examples.simulated.generator;
 
-import com.opengamma.lambdava.functions.Function2;
-
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.Options;
 
@@ -16,10 +14,11 @@ import com.opengamma.financial.generator.AbstractPortfolioGeneratorTool;
 import com.opengamma.financial.generator.SecurityGenerator;
 import com.opengamma.financial.tool.ToolContext;
 import com.opengamma.id.ExternalId;
+import com.opengamma.lambdava.functions.Function2;
 import com.opengamma.util.money.Currency;
 
 /**
- * Utility for generating a portfolio of securities with OG_SYNTHETIC_TICKER tickers.
+ * Utility for generating a portfolio of securities with {@link ExternalSchemes#OG_SYNTHETIC_TICKER} tickers.
  */
 public class SyntheticPortfolioGeneratorTool extends AbstractPortfolioGeneratorTool {
 
@@ -41,20 +40,36 @@ public class SyntheticPortfolioGeneratorTool extends AbstractPortfolioGeneratorT
     });
   }
 
-  public static void main(final String[] args) { // CSIGNORE
-    AbstractTool<ToolContext> tool = new AbstractTool<ToolContext>() {
+  /**
+   * Main method. 
+   * @param args Uses the command line args<p>
+   * <ul>
+   * <li> h - help
+   * <li> c - config
+   * <li> l - logback
+   * <li> p - sets the name of the portfolio (required)
+   * <li> s - sets the name of the security generator (required)
+   * <li> w - writes the portfolio and securities to the database
+   * <li> cp - sets the name of the counterparty
+   * </ul>
+   */
+  public static void main(final String[] args) {
+    final AbstractTool<ToolContext> tool = new AbstractTool<ToolContext>() {
       private final SyntheticPortfolioGeneratorTool _instance = new SyntheticPortfolioGeneratorTool();
+
       @Override
-      protected Options createOptions(boolean mandatoryConfigArg) {
+      protected Options createOptions(final boolean mandatoryConfigArg) {
         final Options options = super.createOptions(mandatoryConfigArg);
         _instance.createOptions(options);
         return options;
       }
+
       @Override
       protected void doRun() throws Exception {
         final CommandLine commandLine = getCommandLine();
         _instance.run(getToolContext(), commandLine);
       }
+
       @Override
       protected Class<?> getEntryPointClass() {
         return SyntheticPortfolioGeneratorTool.class;
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticSecuritiesGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticSecuritiesGeneratorTool.java
new file mode 100644
index 0000000..75068e5
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/SyntheticSecuritiesGeneratorTool.java
@@ -0,0 +1,63 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Options;
+
+import com.opengamma.component.tool.AbstractTool;
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.financial.tool.ToolContext;
+
+/**
+ * @author emcleod
+ * 
+ * Utility for generating a list of securities with {@link ExternalSchemes#OG_SYNTHETIC_TICKER} tickers.
+ */
+public class SyntheticSecuritiesGeneratorTool extends AbstractSecuritiesGeneratorTool {
+
+  @Override
+  protected void configureChain(final SecurityGenerator<?> securityGenerator) {
+    super.configureChain(securityGenerator);
+    securityGenerator.setPreferredScheme(ExternalSchemes.OG_SYNTHETIC_TICKER);
+  }
+
+  /**
+   * Main method. 
+   * @param args Uses the command line args<p>
+   * <ul>
+   * <li> h - help
+   * <li> c - config
+   * <li> l - logback
+   * <li> s - sets the name of the security generator (required)
+   * <li> w - writes the portfolio and securities to the database
+   * </ul>
+   */
+  public static void main(final String[] args) { // CSIGNORE
+    final AbstractTool<ToolContext> tool = new AbstractTool<ToolContext>() {
+      private final SyntheticSecuritiesGeneratorTool _instance = new SyntheticSecuritiesGeneratorTool();
+
+      @Override
+      protected Options createOptions(final boolean mandatoryConfigArg) {
+        final Options options = super.createOptions(mandatoryConfigArg);
+        _instance.createOptions(options);
+        return options;
+      }
+
+      @Override
+      protected void doRun() throws Exception {
+        final CommandLine commandLine = getCommandLine();
+        _instance.run(getToolContext(), commandLine);
+      }
+
+      @Override
+      protected Class<?> getEntryPointClass() {
+        return SyntheticSecuritiesGeneratorTool.class;
+      }
+    };
+    tool.invokeAndTerminate(args);
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/VanillaFXOptionPortfolioGeneratorTool.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/VanillaFXOptionPortfolioGeneratorTool.java
index 8a035dff..a9fb8e6 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/VanillaFXOptionPortfolioGeneratorTool.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/generator/VanillaFXOptionPortfolioGeneratorTool.java
@@ -94,7 +94,7 @@ public class VanillaFXOptionPortfolioGeneratorTool extends AbstractPortfolioGene
 
   @Override
   public PortfolioGenerator createPortfolioGenerator(final NameGenerator portfolioNameGenerator) {
-    final SecurityGenerator<FXOptionSecurity> securities = createFXOptionSecurityGenerator();
+    final SecurityGenerator<FXOptionSecurity> securities = new CollectionSecurityGenerator<>(FX_OPTIONS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     final PortfolioNodeGenerator rootNode = new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Options"), positions, FX_OPTIONS.size());
@@ -103,25 +103,10 @@ public class VanillaFXOptionPortfolioGeneratorTool extends AbstractPortfolioGene
 
   @Override
   public PortfolioNodeGenerator createPortfolioNodeGenerator(final int portfolioSize) {
-    final SecurityGenerator<FXOptionSecurity> securities = createFXOptionSecurityGenerator();
+    final SecurityGenerator<FXOptionSecurity> securities = new CollectionSecurityGenerator<>(FX_OPTIONS);
     configure(securities);
     final PositionGenerator positions = new SimplePositionGenerator<>(securities, getSecurityPersister(), getCounterPartyGenerator());
     return new LeafPortfolioNodeGenerator(new StaticNameGenerator("FX Options"), positions, FX_OPTIONS.size());
   }
 
-  private SecurityGenerator<FXOptionSecurity> createFXOptionSecurityGenerator() {
-    final SecurityGenerator<FXOptionSecurity> securities = new SecurityGenerator<FXOptionSecurity>() {
-      private int _count;
-
-      @SuppressWarnings("synthetic-access")
-      @Override
-      public FXOptionSecurity createSecurity() {
-        final FXOptionSecurity fxOption = FX_OPTIONS.get(_count++);
-        return fxOption;
-      }
-
-    };
-    configure(securities);
-    return securities;
-  }
 }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleBondCurveSecuritiesLoader.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleBondCurveSecuritiesLoader.java
new file mode 100644
index 0000000..9ef6df4
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleBondCurveSecuritiesLoader.java
@@ -0,0 +1,18 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.loader;
+
+import com.opengamma.financial.generator.AbstractPortfolioGeneratorTool;
+import com.opengamma.financial.security.bond.BillSecurity;
+import com.opengamma.financial.security.bond.BondSecurity;
+
+/**
+ * @author emcleod
+ * Adds the {@link BillSecurity} and {@link BondSecurity} objects to the security master. These
+ * securities must be present in the database for the curves to be constructed. The definitions
+ * are created in {@link ExampleUSBondCurveConfigurationsPopulator}.
+ */
+public class ExampleBondCurveSecuritiesLoader extends AbstractPortfolioGeneratorTool {
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleCurveConfigurationsPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleCurveConfigurationsPopulator.java
index 6331c58..72083dc 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleCurveConfigurationsPopulator.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleCurveConfigurationsPopulator.java
@@ -116,6 +116,7 @@ public class ExampleCurveConfigurationsPopulator {
    * referencing a curve called "[CURRENCY_STRING] [TENOR] Forward Ibor", and is called 
    * "Default [CURRENCY_STRING] Curves". 
    * @param currency The currency
+   * @param tenor The ibor tenor
    * @return The configuration
    */
   private static CurveConstructionConfiguration makeCurveConstructionConfigurationForCurrency(final String currency, final Tenor tenor) {
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleExposureFunctionConfigPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleExposureFunctionConfigPopulator.java
index 8491dd6..9577a7a 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleExposureFunctionConfigPopulator.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleExposureFunctionConfigPopulator.java
@@ -11,6 +11,7 @@ import java.util.List;
 import java.util.Map;
 
 import com.opengamma.core.config.impl.ConfigItem;
+import com.opengamma.financial.analytics.curve.exposure.ExposureFunction;
 import com.opengamma.financial.analytics.curve.exposure.ExposureFunctions;
 import com.opengamma.id.ExternalId;
 import com.opengamma.master.config.ConfigMaster;
@@ -40,10 +41,17 @@ public class ExampleExposureFunctionConfigPopulator {
     ExposureFunctions exposureFunctions = new ExposureFunctions(name, exposureFunctionNames, idsToNames);
     ConfigMasterUtils.storeByName(configMaster, makeConfig(exposureFunctions));
     name = "Bond Exposures";
-    exposureFunctionNames = Arrays.asList("Currency");
+    exposureFunctionNames = Arrays.asList("Security / Region", "Security / Currency", "Currency");
     idsToNames = new HashMap<>();
-    idsToNames.put(ExternalId.of(Currency.OBJECT_SCHEME, "UGX"), "UG Government Bond Configuration");
+    idsToNames.put(ExternalId.of(ExposureFunction.SECURITY_IDENTIFIER, "BOND_US"), "US Government Bond Configuration");
     idsToNames.put(ExternalId.of(Currency.OBJECT_SCHEME, "USD"), "Default USD Curves");
+    idsToNames.put(ExternalId.of(Currency.OBJECT_SCHEME, "UGX"), "UG Government Bond Configuration");
+    exposureFunctions = new ExposureFunctions(name, exposureFunctionNames, idsToNames);
+    ConfigMasterUtils.storeByName(configMaster, makeConfig(exposureFunctions));
+    name = "Bond OIS Exposures";
+    exposureFunctionNames = Arrays.asList("Security / Region");
+    idsToNames = new HashMap<>();
+    idsToNames.put(ExternalId.of(ExposureFunction.SECURITY_IDENTIFIER, "BOND_US"), "US Government Bond Configuration (OIS)");
     exposureFunctions = new ExposureFunctions(name, exposureFunctionNames, idsToNames);
     ConfigMasterUtils.storeByName(configMaster, makeConfig(exposureFunctions));
   }
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleLegalEntityLoader.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleLegalEntityLoader.java
new file mode 100644
index 0000000..7693b25
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleLegalEntityLoader.java
@@ -0,0 +1,70 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.loader;
+
+import java.util.Arrays;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.opengamma.component.tool.AbstractTool;
+import com.opengamma.core.legalentity.Rating;
+import com.opengamma.core.obligor.CreditRating;
+import com.opengamma.financial.tool.ToolContext;
+import com.opengamma.id.ExternalId;
+import com.opengamma.id.ExternalIdBundle;
+import com.opengamma.master.legalentity.LegalEntityDocument;
+import com.opengamma.master.legalentity.LegalEntityMaster;
+import com.opengamma.master.legalentity.LegalEntitySearchRequest;
+import com.opengamma.master.legalentity.LegalEntitySearchResult;
+import com.opengamma.master.legalentity.ManageableLegalEntity;
+import com.opengamma.masterdb.legalentity.DbLegalEntityBeanMaster;
+import com.opengamma.scripts.Scriptable;
+
+/**
+ * @author elaine
+ * Simple implementation of a legal entity loader.
+ */
+@Scriptable
+public class ExampleLegalEntityLoader extends AbstractTool<ToolContext> {
+  /** The logger */
+  private static final Logger s_logger = LoggerFactory.getLogger(ExampleLegalEntityLoader.class);
+
+  /**
+   * Main method to run this loader.
+   * @param args The program arguments
+   */
+  public static void main(final String[] args) {
+    new ExampleLegalEntityLoader().invokeAndTerminate(args);
+  }
+
+  @Override
+  protected void doRun() {
+    final ManageableLegalEntity usGovernment = new ManageableLegalEntity("US Government",
+        ExternalIdBundle.of(ExternalId.of(DbLegalEntityBeanMaster.IDENTIFIER_SCHEME_DEFAULT, "US Government")));
+    usGovernment.setRatings(Arrays.asList(new Rating("Moodys", CreditRating.AA, null)));
+    storeLegalEntity(usGovernment);
+  }
+
+  /**
+   * Stores a legal entity in the legal entity database. If the entity is already
+   * present, updates it. Otherwise, adds a new entry.
+   * @param entity The legal entity
+   */
+  private void storeLegalEntity(final ManageableLegalEntity entity) {
+    final LegalEntityMaster master = getToolContext().getLegalEntityMaster();
+    final LegalEntitySearchRequest request = new LegalEntitySearchRequest();
+    request.setName(entity.getName());
+    final LegalEntitySearchResult result = master.search(request);
+    if (result.getFirstDocument() != null) {
+      s_logger.info("Updating {}", entity.getName());
+      final LegalEntityDocument document = result.getFirstDocument();
+      document.setLegalEntity(entity);
+      master.update(document);
+    } else {
+      s_logger.info("Adding {}", entity.getName());
+      master.add(new LegalEntityDocument(entity));
+    }
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsLoader.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsLoader.java
new file mode 100644
index 0000000..b765db6
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsLoader.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.examples.simulated.loader;
+
+import com.opengamma.component.tool.AbstractTool;
+import com.opengamma.financial.tool.ToolContext;
+import com.opengamma.master.config.ConfigMaster;
+
+/**
+ * Loads example US bond curve configurations, definitions and curve node id mappers.
+ */
+public class ExampleUSBondCurveConfigurationsLoader extends AbstractTool<ToolContext> {
+
+  /**
+   * Main method to run the tool.
+   * @param args The standard tool arguments, not null
+   */
+  public static void main(final String[] args) {
+    new ExampleUSBondCurveConfigurationsLoader().invokeAndTerminate(args);
+  }
+
+  @Override
+  protected void doRun() throws Exception {
+    final ConfigMaster configMaster = getToolContext().getConfigMaster();
+    ExampleUSBondCurveConfigurationsPopulator.populateConfigAndConventionMaster(configMaster);
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsPopulator.java
new file mode 100644
index 0000000..c6163b4
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUSBondCurveConfigurationsPopulator.java
@@ -0,0 +1,200 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.examples.simulated.loader;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.legalentity.LegalEntity;
+import com.opengamma.analytics.financial.legalentity.LegalEntityFilter;
+import com.opengamma.analytics.financial.legalentity.LegalEntityRegion;
+import com.opengamma.analytics.math.interpolation.Interpolator1DFactory;
+import com.opengamma.core.config.impl.ConfigItem;
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.core.value.MarketDataRequirementNames;
+import com.opengamma.financial.analytics.curve.CurveConstructionConfiguration;
+import com.opengamma.financial.analytics.curve.CurveDefinition;
+import com.opengamma.financial.analytics.curve.CurveGroupConfiguration;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.curve.CurveTypeConfiguration;
+import com.opengamma.financial.analytics.curve.InterpolatedCurveDefinition;
+import com.opengamma.financial.analytics.curve.IssuerCurveTypeConfiguration;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.StaticCurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.strips.BillNode;
+import com.opengamma.financial.analytics.ircurve.strips.BondNode;
+import com.opengamma.financial.analytics.ircurve.strips.CurveNode;
+import com.opengamma.financial.analytics.ircurve.strips.DataFieldType;
+import com.opengamma.id.ExternalId;
+import com.opengamma.master.config.ConfigMaster;
+import com.opengamma.master.config.ConfigMasterUtils;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.i18n.Country;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.Tenor;
+
+/**
+ * Creates a curve construction configurations, interpolated curve definition and curve node id mapper
+ * for US bonds. The ISINs used for the bill nodes follow the form "USB000000NNN" where "NNN" is equal
+ * to the number of months until bill maturity. Bond nodes follow the form "UST000000NNN" where "NNN" 
+ * is equal to the number of months until bond maturity. 
+ * <p>
+ * The bond curve contains bill nodes from 6 months to 18 months in six month increments and bond nodes 
+ * from 7 bonds with tenors {2y, 3y, 5y, 7y, 10y, 20y, 30y}, and uses the yield quote to construct the curve.
+ */
+public class ExampleUSBondCurveConfigurationsPopulator {
+  /** The bond curve construction configuration name */
+  private static final String BOND_CURVE_CONSTRUCTION_CONFIG_NAME = "US Government Bond Configuration";
+  /** The OIS curve construction configuration name */
+  private static final String OIS_CURVE_CONSTRUCTION_CONFIG_NAME = "US Government Bond Configuration (OIS)";
+  /** The curve name */
+  private static final String CURVE_NAME = "US Government Bond";
+  /** The curve node id mapper name */
+  private static final String CURVE_NODE_ID_MAPPER_NAME = "US Government Bond ISIN";
+
+  /**
+   * Populates a config master with curve configurations, curve definitions
+   * and curve node id mappers.
+   * @param configMaster The config master, not null
+   */
+  public static void populateConfigAndConventionMaster(final ConfigMaster configMaster) {
+    ArgumentChecker.notNull(configMaster, "configMaster");
+    final Collection<CurveConstructionConfiguration> curveConstructionConfigs = makeCurveConstructionConfiguration();
+    for (final CurveConstructionConfiguration config : curveConstructionConfigs) {
+      ConfigMasterUtils.storeByName(configMaster, makeConfig(config));
+    }
+    ConfigMasterUtils.storeByName(configMaster, makeConfig(makeCurveNodeIdMapper()));
+    ConfigMasterUtils.storeByName(configMaster, makeConfig(makeCurveDefinition()));
+  }
+
+  /**
+   * Creates two curve construction configuration for US bonds; one consisting of a single government bond curve
+   * which matches against USD and uses the two-curve configuration as an exogenous discounting curve, and another
+   * that will discount all cash-flows using the OIS curve.
+   * @return The configuration
+   */
+  private static Collection<CurveConstructionConfiguration> makeCurveConstructionConfiguration() {
+    final Set<Object> keys = Sets.<Object>newHashSet(Currency.USD);
+    final LegalEntityRegion regionFilter = new LegalEntityRegion(false, false, Collections.<Country>emptySet(), true, Collections.singleton(Currency.USD));
+    final Set<LegalEntityFilter<LegalEntity>> filters = new HashSet<>();
+    filters.add(regionFilter);
+    final IssuerCurveTypeConfiguration issuerCurveType = new IssuerCurveTypeConfiguration(keys, filters);
+    final Map<String, List<? extends CurveTypeConfiguration>> bondCurveTypes = new HashMap<>();
+    bondCurveTypes.put(CURVE_NAME, Arrays.asList(issuerCurveType));
+    final CurveGroupConfiguration bondGroup = new CurveGroupConfiguration(0, bondCurveTypes);
+    final List<CurveGroupConfiguration> bondGroups = Arrays.asList(bondGroup);
+    final Map<String, List<? extends CurveTypeConfiguration>> issuerCurveTypes = new HashMap<>();
+    issuerCurveTypes.put("USD Discounting", Arrays.asList(issuerCurveType));
+    final CurveGroupConfiguration oisGroup = new CurveGroupConfiguration(0, issuerCurveTypes);
+    final List<CurveGroupConfiguration> oisGroups = Arrays.asList(oisGroup);
+    final List<String> exogenousConfigs = Collections.singletonList("Default USD Curves");
+    final CurveConstructionConfiguration bondCurveConfig = new CurveConstructionConfiguration(BOND_CURVE_CONSTRUCTION_CONFIG_NAME, bondGroups, exogenousConfigs);
+    final CurveConstructionConfiguration oisCurveConfig = new CurveConstructionConfiguration(OIS_CURVE_CONSTRUCTION_CONFIG_NAME, oisGroups, exogenousConfigs);
+    return Arrays.asList(bondCurveConfig, oisCurveConfig);
+  }
+
+  /**
+   * Creates an interpolated curve definition containing 3 bills with tenors from 6 months to 18 months
+   * in six month intervals and 7 bonds with tenors {2y, 3y, 5y, 7y, 10y, 20y, 30y}. 
+   * The interpolator is double quadratic with linear extrapolation on both sides.
+   * @return The curve definition
+   */
+  private static CurveDefinition makeCurveDefinition() {
+    final Set<CurveNode> curveNodes = new LinkedHashSet<>();
+    for (int i = 6; i <= 18; i += 6) {
+      curveNodes.add(new BillNode(Tenor.ofMonths(i), CURVE_NODE_ID_MAPPER_NAME));
+    }
+    for (final int i : new int[] {2, 3, 5, 7, 10, 20, 30 }) {
+      curveNodes.add(new BondNode(Tenor.ofYears(i), CURVE_NODE_ID_MAPPER_NAME));
+    }
+    final CurveDefinition curveDefinition = new InterpolatedCurveDefinition(CURVE_NAME, curveNodes,
+        Interpolator1DFactory.DOUBLE_QUADRATIC, Interpolator1DFactory.LINEAR_EXTRAPOLATOR, Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
+    return curveDefinition;
+  }
+
+  /**
+   * Creates a curve node id mapper containing ISINs for 3 bills with tenors from 6 months to 18 months
+   * in six month intervals and 7 bonds with tenors {2y, 3y, 5y, 7y, 10y, 20y, 30y}.
+   * @return The curve node id mapper
+   */
+  private static CurveNodeIdMapper makeCurveNodeIdMapper() {
+    final Map<Tenor, CurveInstrumentProvider> billNodes = new HashMap<>();
+    final Map<Tenor, CurveInstrumentProvider> bondNodes = new HashMap<>();
+    for (int i = 6; i < 24; i += 6) {
+      final Tenor tenor = Tenor.ofMonths(i);
+      String suffix;
+      if (i < 10) {
+        suffix = "00" + Integer.toString(i);
+      } else {
+        suffix = "0" + Integer.toString(i);
+      }
+      final ExternalId isin = ExternalSchemes.syntheticSecurityId("USB000000" + suffix);
+      final CurveInstrumentProvider instrumentProvider = new StaticCurveInstrumentProvider(isin, MarketDataRequirementNames.YIELD_YIELD_TO_MATURITY_MID, DataFieldType.OUTRIGHT);
+      billNodes.put(tenor, instrumentProvider);
+    }
+    for (final int i : new int[] {2, 3, 5, 7, 10, 20, 30 }) {
+      final Tenor tenor = Tenor.ofYears(i);
+      String suffix;
+      if (i < 10) {
+        suffix = "00" + Integer.toString(i);
+      } else if (i < 100) {
+        suffix = "0" + Integer.toString(i);
+      } else {
+        suffix = Integer.toString(i);
+      }
+      final ExternalId isin = ExternalSchemes.syntheticSecurityId("UST000000" + suffix);
+      final CurveInstrumentProvider instrumentProvider = new StaticCurveInstrumentProvider(isin, MarketDataRequirementNames.YIELD_YIELD_TO_MATURITY_MID, DataFieldType.OUTRIGHT);
+      bondNodes.put(tenor, instrumentProvider);
+    }
+    final CurveNodeIdMapper curveNodeIdMapper = CurveNodeIdMapper.builder()
+        .name(CURVE_NODE_ID_MAPPER_NAME)
+        .billNodeIds(billNodes)
+        .bondNodeIds(bondNodes)
+        .build();
+    return curveNodeIdMapper;
+  }
+
+  /**
+   * Creates a config item from a curve construction configuration object.
+   * @param curveConfig The curve construction configuration
+   * @return The config item
+   */
+  private static ConfigItem<CurveConstructionConfiguration> makeConfig(final CurveConstructionConfiguration curveConfig) {
+    final ConfigItem<CurveConstructionConfiguration> config = ConfigItem.of(curveConfig);
+    config.setName(curveConfig.getName());
+    return config;
+  }
+
+  /**
+   * Creates a config item from a curve node id mapper object.
+   * @param curveNodeIdMapper The curve node id mapper
+   * @return The config item
+   */
+  private static ConfigItem<CurveNodeIdMapper> makeConfig(final CurveNodeIdMapper curveNodeIdMapper) {
+    final ConfigItem<CurveNodeIdMapper> config = ConfigItem.of(curveNodeIdMapper);
+    config.setName(curveNodeIdMapper.getName());
+    return config;
+  }
+
+  /**
+   * Creates a config item from a curve definition object.
+   * @param curveDefinition The curve definition
+   * @return The config item
+   */
+  private static ConfigItem<CurveDefinition> makeConfig(final CurveDefinition curveDefinition) {
+    final ConfigItem<CurveDefinition> config = ConfigItem.of(curveDefinition);
+    config.setName(curveDefinition.getName());
+    return config;
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUgandanBondCurveConfigurationsPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUgandanBondCurveConfigurationsPopulator.java
index fdf4e3a..6c416d3 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUgandanBondCurveConfigurationsPopulator.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleUgandanBondCurveConfigurationsPopulator.java
@@ -45,8 +45,9 @@ import com.opengamma.util.time.Tenor;
 /**
  * Creates a curve construction configuration, interpolated curve definition and curve node id mapper
  * for Ugandan bonds to be used for pricing the example Ugandan TRS portfolio. The ISINs used 
- * follow the form "UG0000000XXX" where "XXX" is equal to the number of months until bond maturity. 
+ * follow the form "UG0000000NNN" where "NNN" is equal to the number of months until bond maturity. 
  * The bond curve contains only bond nodes from 1y to 10y6m in 6m increments and uses the bond yield
+ * <b>(labelled as the market and last price in the market data and historical data files respectively)</b>
  * to construct the curve.
  */
 public class ExampleUgandanBondCurveConfigurationsPopulator {
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleViewsPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleViewsPopulator.java
index 63131c1..4e00cb3 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleViewsPopulator.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/loader/ExampleViewsPopulator.java
@@ -10,6 +10,7 @@ import static com.opengamma.engine.value.ValuePropertyNames.CURRENCY;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE_CALCULATION_CONFIG;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE_CALCULATION_METHOD;
+import static com.opengamma.engine.value.ValuePropertyNames.CURVE_CONSTRUCTION_CONFIG;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE_CURRENCY;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE_EXPOSURES;
 import static com.opengamma.engine.value.ValuePropertyNames.CURVE_SENSITIVITY_CURRENCY;
@@ -18,6 +19,7 @@ import static com.opengamma.engine.value.ValueRequirementNames.ASSET_LEG_PV;
 import static com.opengamma.engine.value.ValueRequirementNames.BOND_DETAILS;
 import static com.opengamma.engine.value.ValueRequirementNames.BUCKETED_PV01;
 import static com.opengamma.engine.value.ValueRequirementNames.CLEAN_PRICE;
+import static com.opengamma.engine.value.ValueRequirementNames.CONVEXITY;
 import static com.opengamma.engine.value.ValueRequirementNames.DELTA;
 import static com.opengamma.engine.value.ValueRequirementNames.FAIR_VALUE;
 import static com.opengamma.engine.value.ValueRequirementNames.FORWARD;
@@ -58,6 +60,7 @@ import static com.opengamma.engine.value.ValueRequirementNames.YIELD_CURVE;
 import static com.opengamma.engine.value.ValueRequirementNames.YIELD_CURVE_JACOBIAN;
 import static com.opengamma.engine.value.ValueRequirementNames.YIELD_CURVE_NODE_SENSITIVITIES;
 import static com.opengamma.engine.value.ValueRequirementNames.YTM;
+import static com.opengamma.engine.value.ValueRequirementNames.Z_SPREAD;
 import static com.opengamma.examples.simulated.tool.ExampleDatabasePopulator.AUD_SWAP_PORFOLIO_NAME;
 import static com.opengamma.examples.simulated.tool.ExampleDatabasePopulator.BOND_TRS_PORTFOLIO_NAME;
 import static com.opengamma.examples.simulated.tool.ExampleDatabasePopulator.EQUITY_OPTION_PORTFOLIO_NAME;
@@ -119,7 +122,6 @@ import com.opengamma.financial.security.capfloor.CapFloorCMSSpreadSecurity;
 import com.opengamma.financial.security.capfloor.CapFloorSecurity;
 import com.opengamma.financial.security.equity.EquitySecurity;
 import com.opengamma.financial.security.future.FutureSecurity;
-import com.opengamma.financial.security.future.IndexFutureSecurity;
 import com.opengamma.financial.security.fx.FXForwardSecurity;
 import com.opengamma.financial.security.fx.FXVolatilitySwapSecurity;
 import com.opengamma.financial.security.option.EquityOptionSecurity;
@@ -242,6 +244,7 @@ public class ExampleViewsPopulator extends AbstractTool<ToolContext> {
     storeViewDefinition(getBondTotalReturnSwapViewDefinition(BOND_TRS_PORTFOLIO_NAME, "Bond TRS View"));
     storeViewDefinition(getEquityTotalReturnSwapViewDefinition(EQUITY_TRS_PORTFOLIO_NAME, "Equity TRS View"));
     storeViewDefinition(getOISViewDefinition(OIS_PORTFOLIO_NAME, "OIS View"));
+    storeViewDefinition(getMultiCountryBondViewDefinition("Bond Portfolio", "Bond Portfolio View"));
   }
 
   private ViewDefinition getEquityViewDefinition(final String portfolioName) {
@@ -761,13 +764,13 @@ public class ExampleViewsPopulator extends AbstractTool<ToolContext> {
     viewDefinition.setMinDeltaCalculationPeriod(500L);
     viewDefinition.setMinFullCalculationPeriod(500L);
     final ViewCalculationConfiguration defaultCalConfig = new ViewCalculationConfiguration(viewDefinition, DEFAULT_CALC_CONFIG);
-    addValueRequirements(defaultCalConfig, IndexFutureSecurity.SECURITY_TYPE, new String[] {PRESENT_VALUE, PV01, VALUE_DELTA, VALUE_RHO, FORWARD });
+    addValueRequirements(defaultCalConfig, FutureSecurity.SECURITY_TYPE, new String[] {PRESENT_VALUE, PV01, VALUE_DELTA, VALUE_RHO, FORWARD });
     viewDefinition.addViewCalculationConfiguration(defaultCalConfig);
     return viewDefinition;
   }
 
   /**
-   * Creates a bond view that calculated various clean price, modified and Macaulay durations using
+   * Creates a bond view that calculates clean price, modified and Macaulay durations using
    * both the clean price and the market yield quote, and present value and yield to maturity from 
    * the clean price.
    * @param portfolioName The name of the portfolio
@@ -926,6 +929,80 @@ public class ExampleViewsPopulator extends AbstractTool<ToolContext> {
   }
 
   /**
+   * Creates a bond view that calculates clean price, modified and Macaulay durations using
+   * both the clean price and the market yield quote, and present value and yield to maturity from 
+   * the clean price.
+   * @param portfolioName The name of the portfolio
+   * @param viewName The name of the view
+   * @return The view definition
+   */
+  private ViewDefinition getMultiCountryBondViewDefinition(final String portfolioName, final String viewName) {
+    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
+    final ViewDefinition viewDefinition = new ViewDefinition(viewName, portfolioId, UserPrincipal.getTestUser());
+    viewDefinition.setDefaultCurrency(Currency.USD);
+    viewDefinition.setMaxDeltaCalculationPeriod(500L);
+    viewDefinition.setMaxFullCalculationPeriod(500L);
+    viewDefinition.setMinDeltaCalculationPeriod(500L);
+    viewDefinition.setMinFullCalculationPeriod(500L);
+    ViewCalculationConfiguration config = new ViewCalculationConfiguration(viewDefinition, "Bond Curves");
+    ValueProperties properties = ValueProperties.builder()
+        .with(PROPERTY_CURVE_TYPE, "Discounting")
+        .with(CURVE_EXPOSURES, "Bond Exposures")
+        .with(CALCULATION_METHOD, "Curves")
+        .get();
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, PRESENT_VALUE, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, CLEAN_PRICE, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, CONVEXITY, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, BOND_DETAILS, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, MACAULAY_DURATION, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, MODIFIED_DURATION, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, YTM, properties);
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, GAMMA_PV01, properties);
+    final String[] curveNames = new String[] {"USD Discounting", "US Government Bond" };
+    for (final String curveName : curveNames) {
+      final ValueProperties curveProperties = properties.copy()
+          .with(CURVE, curveName)
+          .get();
+      config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, PV01, curveProperties);
+      config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, BUCKETED_PV01, curveProperties);
+    }
+    final ValueProperties thetaProperties = properties.copy()
+        .with(PROPERTY_DAYS_TO_MOVE_FORWARD, "1")
+        .with(PROPERTY_THETA_CALCULATION_METHOD, THETA_CONSTANT_SPREAD)
+        .get();
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, VALUE_THETA, thetaProperties);
+    final ValueProperties zSpreadProperties = ValueProperties.builder()
+        .with(PROPERTY_CURVE_TYPE, "Discounting")
+        .with(CURVE_EXPOSURES, "Bond Exposures")
+        .with(CALCULATION_METHOD, "Yield")
+        .with(CURVE, "US Government Bond")
+        .get();
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, Z_SPREAD, zSpreadProperties);
+    ValueProperties curveProperties = ValueProperties.builder()
+        .with(PROPERTY_CURVE_TYPE, "Discounting")
+        .with(CURVE, "US Government Bond")
+        .with(CURVE_CONSTRUCTION_CONFIG, "US Government Bond Configuration")
+        .get();
+    config.addSpecificRequirement(new ValueRequirement(YIELD_CURVE, ComputationTargetSpecification.NULL, curveProperties));
+    viewDefinition.addViewCalculationConfiguration(config);
+    config = new ViewCalculationConfiguration(viewDefinition, "OIS Curves");
+    properties = ValueProperties.builder()
+        .with(PROPERTY_CURVE_TYPE, "Discounting")
+        .with(CURVE_EXPOSURES, "Bond OIS Exposures")
+        .with(CALCULATION_METHOD, "Curves")
+        .get();
+    curveProperties = ValueProperties.builder()
+        .with(PROPERTY_CURVE_TYPE, "Discounting")
+        .with(CURVE_CONSTRUCTION_CONFIG, "Default USD Curves")
+        .with(CURVE, "USD Discounting")
+        .get();
+    config.addPortfolioRequirement(BondSecurity.SECURITY_TYPE, PRESENT_VALUE, properties);
+    config.addSpecificRequirement(new ValueRequirement(YIELD_CURVE, ComputationTargetSpecification.NULL, curveProperties));
+    viewDefinition.addViewCalculationConfiguration(config);
+    return viewDefinition;
+  }
+
+  /**
    * Adds value requirements to a view calculation configuration for a particular security type.
    * @param calcConfiguration The calculation configuration
    * @param securityType The security type
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/ExampleDatabasePopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/ExampleDatabasePopulator.java
index d4fec04..9b0372d 100644
--- a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/ExampleDatabasePopulator.java
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/ExampleDatabasePopulator.java
@@ -26,6 +26,7 @@ import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.component.tool.AbstractTool;
 import com.opengamma.examples.simulated.convention.SyntheticInMemoryConventionMasterInitializer;
 import com.opengamma.examples.simulated.generator.SyntheticPortfolioGeneratorTool;
+import com.opengamma.examples.simulated.generator.SyntheticSecuritiesGeneratorTool;
 import com.opengamma.examples.simulated.loader.ExampleCurrencyConfigurationLoader;
 import com.opengamma.examples.simulated.loader.ExampleCurveAndSurfaceDefinitionLoader;
 import com.opengamma.examples.simulated.loader.ExampleCurveConfigurationLoader;
@@ -38,7 +39,9 @@ import com.opengamma.examples.simulated.loader.ExampleFXImpliedCurveConfiguratio
 import com.opengamma.examples.simulated.loader.ExampleFunctionConfigurationPopulator;
 import com.opengamma.examples.simulated.loader.ExampleHistoricalDataGeneratorTool;
 import com.opengamma.examples.simulated.loader.ExampleHolidayLoader;
+import com.opengamma.examples.simulated.loader.ExampleLegalEntityLoader;
 import com.opengamma.examples.simulated.loader.ExampleTimeSeriesRatingLoader;
+import com.opengamma.examples.simulated.loader.ExampleUSBondCurveConfigurationsLoader;
 import com.opengamma.examples.simulated.loader.ExampleUgandanBondCurveConfigurationsLoader;
 import com.opengamma.examples.simulated.loader.ExampleViewsPopulator;
 import com.opengamma.financial.generator.AbstractPortfolioGeneratorTool;
@@ -118,8 +121,14 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
    */
   public static final String US_GOVERNMENT_BOND_PORTFOLIO_NAME = "Government Bonds";
   /**
+   * The name of a bond portfolio.
+   */
+  public static final String BONDS_PORTFOLIO_NAME = "Bond Portfolio";
+  /**
    * The name of an index portfolio.
+   * @deprecated The index portfolio is no longer loaded
    */
+  @Deprecated
   public static final String INDEX_PORTFOLIO_NAME = "Index Portfolio";
   /**
    * The name of a bond total return swap portfolio.
@@ -158,6 +167,7 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     loadExchanges();
     loadHolidays();
     loadConventions();
+    loadLegalEntities();
     loadCurrencyConfiguration();
     loadCurveAndSurfaceDefinitions();
     loadCurveCalculationConfigurations();
@@ -172,12 +182,12 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     loadEquityOptionPortfolio();
     loadFuturePortfolio();
     loadBondPortfolio();
+    loadMultiCountryBondPortfolio();
     loadSwaptionPortfolio();
     loadEURFixedIncomePortfolio();
     loadFXForwardPortfolio();
     loadERFuturePortfolio();
     loadFXVolatilitySwapPortfolio();
-    loadIndexPortfolio();
     loadBondTotalReturnSwapPortfolio();
     loadEquityTotalReturnSwapPortfolio();
     loadOISPortfolio();
@@ -187,6 +197,9 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     loadFXImpliedCurveConfigurations();
     loadCurveConfigurations();
     loadUgandanBondCurveConfigurations();
+    loadUSBondCurveConfigurations();
+    loadIndexSecurities();
+    loadBondCurveSecurities();
     loadViews();
   }
 
@@ -209,16 +222,19 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     /** The string */
     private final String _str;
 
-    private Log(final String str) {
+    @SuppressWarnings("synthetic-access")
+    Log(final String str) {
       s_logger.info("{}", str);
       _str = str;
     }
 
-    private void done() {
+    @SuppressWarnings("synthetic-access")
+    void done() {
       s_logger.debug("{} - finished", _str);
     }
 
-    private void fail(final RuntimeException e) {
+    @SuppressWarnings("synthetic-access")
+    void fail(final RuntimeException e) {
       s_logger.error("{} - failed - {}", _str, e.getMessage());
       throw e;
     }
@@ -348,6 +364,10 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     return tool;
   }
 
+  private SyntheticSecuritiesGeneratorTool securitiesGeneratorTool() {
+    return new SyntheticSecuritiesGeneratorTool();
+  }
+
   private void loadMultiCurrencySwapPortfolio() {
     final Log log = new Log("Creating example multi currency swap portfolio");
     try {
@@ -411,16 +431,6 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     }
   }
 
-  private void loadIndexPortfolio() {
-    final Log log = new Log("Creating example indices");
-    try {
-      portfolioGeneratorTool().run(getToolContext(), INDEX_PORTFOLIO_NAME, "Index", true, null);
-      log.done();
-    } catch (final RuntimeException t) {
-      log.fail(t);
-    }
-  }
-
   private void loadSwaptionPortfolio() {
     final Log log = new Log("Creating example swaption portfolio");
     try {
@@ -461,8 +471,11 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     }
   }
 
+  /**
+   * Adds a portfolio containing US government bonds.
+   */
   private void loadBondPortfolio() {
-    final Log log = new Log("Creating example bond portfolio");
+    final Log log = new Log("Creating example US government bond portfolio");
     try {
       portfolioGeneratorTool().run(getToolContext(), US_GOVERNMENT_BOND_PORTFOLIO_NAME, "Bond", true, null);
       log.done();
@@ -472,6 +485,19 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
   }
 
   /**
+   * Adds a portfolio containing government bonds.
+   */
+  private void loadMultiCountryBondPortfolio() {
+    final Log log = new Log("Creating example bond portfolio");
+    try {
+      portfolioGeneratorTool().run(getToolContext(), BONDS_PORTFOLIO_NAME, "MixedBond", true, null);
+      log.done();
+    } catch (final RuntimeException t) {
+      log.fail(t);
+    }
+  }
+
+  /**
    * Loads a portfolio of bond TRS.
    */
   private void loadBondTotalReturnSwapPortfolio() {
@@ -554,6 +580,20 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
   }
 
   /**
+   * Loads example US bond curve construction configurations.
+   */
+  private void loadUSBondCurveConfigurations() {
+    final Log log = new Log("Creating US bond curve construction configurations");
+    try {
+      final ExampleUSBondCurveConfigurationsLoader loader = new ExampleUSBondCurveConfigurationsLoader();
+      loader.run(getToolContext());
+      log.done();
+    } catch (final RuntimeException t) {
+      log.fail(t);
+    }
+  }
+
+  /**
    * Loads an example OIS portfolio.
    */
   private void loadOISPortfolio() {
@@ -577,6 +617,35 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     }
   }
 
+  /**
+   * Loads a list of index securities.
+   */
+  private void loadIndexSecurities() {
+    final Log log = new Log("Creating example indices");
+    try {
+      securitiesGeneratorTool().run(getToolContext(), "Index", true);
+      log.done();
+    } catch (final RuntimeException t) {
+      log.fail(t);
+    }
+  }
+
+  /**
+   * Loads a list of bond securities used in curves.
+   */
+  private void loadBondCurveSecurities() {
+    final Log log = new Log("Creating bond curve securities");
+    try {
+      securitiesGeneratorTool().run(getToolContext(), "BondCurve", true);
+      log.done();
+    } catch (final RuntimeException t) {
+      log.fail(t);
+    }
+  }
+
+  /**
+   * Loads hard-coded exchange data.
+   */
   private void loadExchanges() {
     final Log log = new Log("Creating exchange data");
     try {
@@ -588,6 +657,9 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     }
   }
 
+  /**
+   * Loads hard-coded holidays.
+   */
   private void loadHolidays() {
     final Log log = new Log("Creating holiday data");
     try {
@@ -599,8 +671,18 @@ public class ExampleDatabasePopulator extends AbstractTool<ToolContext> {
     }
   }
 
-  private static Set<Currency> getAllCurrencies() {
-    return s_currencies;
+  /**
+   * Loads hard-coded legal entity data.
+   */
+  private void loadLegalEntities() {
+    final Log log = new Log("Creating legal entity data");
+    try {
+      final ExampleLegalEntityLoader loader = new ExampleLegalEntityLoader();
+      loader.run(getToolContext());
+      log.done();
+    } catch (final RuntimeException t) {
+      log.fail(t);
+    }
   }
 
   //-------------------------------------------------------------------------
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveConfigurationsConverter.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveConfigurationsConverter.java
new file mode 100644
index 0000000..e2e588b
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveConfigurationsConverter.java
@@ -0,0 +1,839 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.threeten.bp.LocalDate;
+import org.threeten.bp.Period;
+
+import com.opengamma.component.tool.AbstractTool;
+import com.opengamma.core.config.impl.ConfigItem;
+import com.opengamma.core.id.ExternalSchemes;
+import com.opengamma.engine.ComputationTargetSpecification;
+import com.opengamma.financial.analytics.curve.CurveConstructionConfiguration;
+import com.opengamma.financial.analytics.curve.CurveGroupConfiguration;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.curve.CurveTypeConfiguration;
+import com.opengamma.financial.analytics.curve.DiscountingCurveTypeConfiguration;
+import com.opengamma.financial.analytics.curve.IborCurveTypeConfiguration;
+import com.opengamma.financial.analytics.curve.InterpolatedCurveDefinition;
+import com.opengamma.financial.analytics.curve.OvernightCurveTypeConfiguration;
+import com.opengamma.financial.analytics.fxforwardcurve.FXForwardCurveDefinition;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.FixedIncomeStrip;
+import com.opengamma.financial.analytics.ircurve.StaticCurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.financial.analytics.ircurve.SyntheticFutureCurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.SyntheticIdentifierCurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.YieldCurveDefinition;
+import com.opengamma.financial.analytics.ircurve.calcconfig.MultiCurveCalculationConfig;
+import com.opengamma.financial.analytics.ircurve.strips.CashNode;
+import com.opengamma.financial.analytics.ircurve.strips.CurveNode;
+import com.opengamma.financial.analytics.ircurve.strips.DataFieldType;
+import com.opengamma.financial.analytics.ircurve.strips.FRANode;
+import com.opengamma.financial.analytics.ircurve.strips.RateFutureNode;
+import com.opengamma.financial.analytics.ircurve.strips.SwapNode;
+import com.opengamma.financial.analytics.model.curve.interestrate.FXImpliedYieldCurveFunction;
+import com.opengamma.financial.analytics.model.curve.interestrate.MultiYieldCurvePropertiesAndDefaults;
+import com.opengamma.financial.convention.initializer.PerCurrencyConventionHelper;
+import com.opengamma.financial.tool.ToolContext;
+import com.opengamma.id.ExternalId;
+import com.opengamma.id.VersionCorrection;
+import com.opengamma.master.config.ConfigDocument;
+import com.opengamma.master.config.ConfigMaster;
+import com.opengamma.master.config.ConfigMasterUtils;
+import com.opengamma.master.config.ConfigSearchRequest;
+import com.opengamma.master.config.impl.ConfigSearchIterator;
+import com.opengamma.util.time.Tenor;
+import com.opengamma.util.tuple.Pair;
+import com.opengamma.util.tuple.Pairs;
+
+public class CurveConfigurationsConverter extends AbstractTool<ToolContext> {
+  private static final Logger s_logger = LoggerFactory.getLogger(CurveConfigurationsConverter.class);
+  private static final Map<String, String> YCD_NAME_REMAPPER = new HashMap<>();
+  private static final Map<String, String> CSBC_NAME_REMAPPER = new HashMap<>();
+  //TODO pull this information from the securities database
+  private static final Map<String, ExternalId> OVERNIGHT_CURVE_REFERENCES = new HashMap<>();
+
+  static {
+    YCD_NAME_REMAPPER.put("SECONDARY", "Single");
+    CSBC_NAME_REMAPPER.put("SECONDARY", "Default");
+    OVERNIGHT_CURVE_REFERENCES.put("USD", ExternalId.of(ExternalSchemes.OG_SYNTHETIC_TICKER, "USDFF"));
+    OVERNIGHT_CURVE_REFERENCES.put("EUR", ExternalId.of(ExternalSchemes.OG_SYNTHETIC_TICKER, "EONIA"));
+    OVERNIGHT_CURVE_REFERENCES.put("GBP", ExternalId.of(ExternalSchemes.OG_SYNTHETIC_TICKER, "SONIO"));
+    OVERNIGHT_CURVE_REFERENCES.put("JPY", ExternalId.of(ExternalSchemes.OG_SYNTHETIC_TICKER, "TONAR"));
+    OVERNIGHT_CURVE_REFERENCES.put("CHF", ExternalId.of(ExternalSchemes.OG_SYNTHETIC_TICKER, "TOISTOIS"));
+  }
+
+  public static void main(final String[] args) {
+    new CurveConfigurationsConverter().invokeAndTerminate(args);
+  }
+
+  @Override
+  protected void doRun() {
+    final ConfigMaster configMaster = getToolContext().getConfigMaster();
+    final ConfigSearchRequest<MultiCurveCalculationConfig> mcccSearchRequest = new ConfigSearchRequest<>();
+    mcccSearchRequest.setType(MultiCurveCalculationConfig.class);
+    mcccSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+    final ConfigSearchRequest<YieldCurveDefinition> ycdSearchRequest = new ConfigSearchRequest<>();
+    ycdSearchRequest.setType(YieldCurveDefinition.class);
+    ycdSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+    final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+    csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+    csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+    final ConfigSearchRequest<FXForwardCurveDefinition> ffcdSearchRequest = new ConfigSearchRequest<>();
+    ffcdSearchRequest.setType(FXForwardCurveDefinition.class);
+    ffcdSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+    final Map<Pair<String, String>, CurveSpecificationBuilderConfiguration> csbcMap = new HashMap<>();
+    for (final ConfigDocument mcccDocument : ConfigSearchIterator.iterable(configMaster, mcccSearchRequest)) {
+      final MultiCurveCalculationConfig mccc = ((ConfigItem<MultiCurveCalculationConfig>) mcccDocument.getConfig()).getValue();
+      final CurveConstructionConfiguration ccc = convertMultiCurveCalculationConfig(configMaster, mccc);
+      if (ccc != null) {
+        final ConfigItem<CurveConstructionConfiguration> cccConfig = ConfigItem.of(ccc);
+        cccConfig.setName(ccc.getName());
+        ConfigMasterUtils.storeByName(configMaster, cccConfig);
+        final ComputationTargetSpecification target = mccc.getTarget();
+        final String currency = target.getUniqueId().getValue();
+        final String[] curveNames = mccc.getCurveNames();
+        final String calculationMethod = mccc.getCalculationMethod();
+        if (MultiYieldCurvePropertiesAndDefaults.PAR_RATE_STRING.equals(calculationMethod) || MultiYieldCurvePropertiesAndDefaults.PRESENT_VALUE_STRING.equals(calculationMethod)) {
+          final String currencyString = target.getUniqueId().getValue();
+          for (final String ycdName : curveNames) {
+            ycdSearchRequest.setName(ycdName + "_" + currencyString);
+            for (final ConfigDocument ycdDocument : ConfigSearchIterator.iterable(configMaster, ycdSearchRequest)) {
+              final YieldCurveDefinition ycd = ((ConfigItem<YieldCurveDefinition>) ycdDocument.getConfig()).getValue();
+              final InterpolatedCurveDefinition definition = convertYieldCurveDefinition(configMaster, ycd, currencyString);
+              final ConfigItem<InterpolatedCurveDefinition> icdConfig = ConfigItem.of(definition);
+              icdConfig.setName(definition.getName());
+              ConfigMasterUtils.storeByName(configMaster, icdConfig);
+              for (final FixedIncomeStrip strip : ycd.getStrips()) {
+                final String csbcName = strip.getConventionName();
+                csbcSearchRequest.setName(csbcName + "_" + currencyString);
+                for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+                  final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+                  csbcMap.put(Pairs.of(currency, csbcName + "_" + currencyString), csbc);
+                }
+              }
+            }
+          }
+        } else if (FXImpliedYieldCurveFunction.FX_IMPLIED.equals(calculationMethod)) { //TODO size of curve name array
+          final String currencyPairString = target.getUniqueId().getValue();
+          for (final String ffcdName : curveNames) {
+            ffcdSearchRequest.setName(ffcdName + "_" + currencyPairString);
+            for (final ConfigDocument ffcdDocument : ConfigSearchIterator.iterable(configMaster, ffcdSearchRequest)) {
+              final FXForwardCurveDefinition ffcd = ((ConfigItem<FXForwardCurveDefinition>) ffcdDocument.getConfig()).getValue();
+              s_logger.error("\t\tFX forward curve definition: {}", ffcdDocument.getName());
+            }
+          }
+        }
+      }
+    }
+    final Map<String, CurveNodeIdMapper.Builder> cnimBuilders = convertCurveSpecificationBuilderConfigurations(csbcMap);
+    for (final Map.Entry<String, CurveNodeIdMapper.Builder> entry : cnimBuilders.entrySet()) {
+      final ConfigItem<CurveNodeIdMapper> config = ConfigItem.of(entry.getValue().build());
+      config.setName(entry.getKey());
+      ConfigMasterUtils.storeByName(configMaster, config);
+    }
+  }
+
+  private static CurveConstructionConfiguration convertMultiCurveCalculationConfig(final ConfigMaster configMaster, final MultiCurveCalculationConfig oldConfig) {
+    final LocalDate unused = LocalDate.now();
+    final String oldName = oldConfig.getCalculationConfigName();
+    String name;
+    if (oldName.contains("Config")) {
+      name = oldName.substring(0, oldName.indexOf("Config"));
+    } else {
+      name = oldName;
+    }
+    final Map<String, List<? extends CurveTypeConfiguration>> curveTypeConfigurations = new HashMap<>();
+    final String currency = oldConfig.getTarget().getUniqueId().getValue();
+    if (oldConfig.getYieldCurveNames().length == 1) {
+      final List<CurveTypeConfiguration> list = new ArrayList<>();
+      list.add(new DiscountingCurveTypeConfiguration(currency));
+      if (OVERNIGHT_CURVE_REFERENCES.containsKey(currency)) {
+        list.add(new OvernightCurveTypeConfiguration(OVERNIGHT_CURVE_REFERENCES.get(currency)));
+      }
+      final String oldCurveName = oldConfig.getYieldCurveNames()[0];
+      final Pattern p = Pattern.compile("\\d+");
+      final Matcher m = p.matcher(oldCurveName);
+      final Tenor iborTenor;
+      if (m.find()) {
+        iborTenor = Tenor.ofMonths(Integer.parseInt(m.group()));
+      } else {
+        iborTenor = currency.equals("USD") || currency.equals("CAD") ? Tenor.THREE_MONTHS : Tenor.SIX_MONTHS;
+      }
+      final CurveTypeConfiguration iborCurveTypeConfiguration = getIborCurveTypeConfiguration(configMaster, oldConfig, unused, oldCurveName, currency, iborTenor);
+      if (iborCurveTypeConfiguration != null) {
+        list.add(iborCurveTypeConfiguration);
+      }
+      String curveName = oldCurveName;
+      if (YCD_NAME_REMAPPER.containsKey(name)) {
+        curveName = YCD_NAME_REMAPPER.get(name);
+      }
+      curveName += " " + currency;
+      curveTypeConfigurations.put(curveName, list);
+    } else if (oldConfig.getYieldCurveNames().length == 2) {
+      final List<CurveTypeConfiguration> list = new ArrayList<>();
+      list.add(new DiscountingCurveTypeConfiguration(currency));
+      if (OVERNIGHT_CURVE_REFERENCES.containsKey(currency)) {
+        list.add(new OvernightCurveTypeConfiguration(OVERNIGHT_CURVE_REFERENCES.get(currency)));
+      }
+      String oldCurveName = oldConfig.getYieldCurveNames()[0];
+      String curveName = oldCurveName;
+      if (YCD_NAME_REMAPPER.containsKey(name)) {
+        curveName = YCD_NAME_REMAPPER.get(name);
+      }
+      curveName += " " + currency;
+      curveTypeConfigurations.put(oldCurveName, list);
+      oldCurveName = oldConfig.getYieldCurveNames()[1];
+      final Pattern p = Pattern.compile("\\d+");
+      final Matcher m = p.matcher(oldCurveName);
+      final Tenor iborTenor;
+      if (m.find()) {
+        iborTenor = Tenor.ofMonths(Integer.parseInt(m.group()));
+      } else {
+        iborTenor = currency.equals("USD") || currency.equals("CAD") ? Tenor.THREE_MONTHS : Tenor.SIX_MONTHS;
+      }
+      final CurveTypeConfiguration iborCurveTypeConfiguration = getIborCurveTypeConfiguration(configMaster, oldConfig, unused, oldCurveName, currency, iborTenor);
+      if (iborCurveTypeConfiguration != null) {
+        list.add(iborCurveTypeConfiguration);
+      }
+      curveName = oldCurveName;
+      if (YCD_NAME_REMAPPER.containsKey(name)) {
+        curveName = YCD_NAME_REMAPPER.get(name);
+      }
+      curveName += " " + currency;
+      curveTypeConfigurations.put(curveName, list);
+    } else {
+      s_logger.error("Cannot handle MultiCurveCalculationConfiguration {}: too many curves ({})", oldName, oldConfig.getYieldCurveNames().length);
+      return null;
+    }
+    final CurveGroupConfiguration group = new CurveGroupConfiguration(0, curveTypeConfigurations);
+    final List<String> exogenousCurveNames = oldConfig.getExogenousConfigData() == null ? new ArrayList<String>() : new ArrayList<>(oldConfig.getExogenousConfigData().keySet());
+    return new CurveConstructionConfiguration(name, Arrays.asList(group), exogenousCurveNames);
+  }
+
+  private static CurveTypeConfiguration getIborCurveTypeConfiguration(final ConfigMaster configMaster, final MultiCurveCalculationConfig oldConfig,
+      final LocalDate unused, final String oldCurveName, final String currency, final Tenor iborTenor) {
+    final ConfigSearchRequest<YieldCurveDefinition> ycdSearchRequest = new ConfigSearchRequest<>();
+    ycdSearchRequest.setType(YieldCurveDefinition.class);
+    ycdSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+    ycdSearchRequest.setName(oldCurveName + "_" + currency);
+    for (final ConfigDocument ycdDocument : ConfigSearchIterator.iterable(configMaster, ycdSearchRequest)) {
+      final YieldCurveDefinition ycd = ((ConfigItem<YieldCurveDefinition>) ycdDocument.getConfig()).getValue();
+      for (final FixedIncomeStrip strip : ycd.getStrips()) {
+        if (strip.getCurveNodePointTime().equals(iborTenor)) {
+          final String csbcName = strip.getConventionName();
+          final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+          csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+          csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+          csbcSearchRequest.setName(csbcName + "_" + currency);
+          ExternalId underlyingIborIdentifier = null;
+          switch (currency) {
+            case "CAD":
+              for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+                final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+                underlyingIborIdentifier = csbc.getCDORSecurity(unused, iborTenor);
+              }
+              break;
+            case "DKK":
+              for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+                final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+                underlyingIborIdentifier = csbc.getCiborSecurity(unused, iborTenor);
+              }
+              break;
+            case "SEK":
+              for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+                final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+                underlyingIborIdentifier = csbc.getStiborSecurity(unused, iborTenor);
+              }
+              break;
+            case "EUR":
+              for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+                final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+                underlyingIborIdentifier = csbc.getEuriborSecurity(unused, iborTenor);
+              }
+              break;
+            default:
+          }
+          if (underlyingIborIdentifier != null) {
+            return new IborCurveTypeConfiguration(underlyingIborIdentifier, iborTenor);
+          }
+          s_logger.error("Could not get underlying ibor id for " + strip);
+        }
+      }
+    }
+    return null;
+  }
+
+  private static InterpolatedCurveDefinition convertYieldCurveDefinition(final ConfigMaster configMaster, final YieldCurveDefinition oldConfig, final String currency) {
+    final LocalDate unused = LocalDate.now();
+    final Set<FixedIncomeStrip> strips = oldConfig.getStrips();
+    String name = oldConfig.getName().split("_")[0];
+    if (YCD_NAME_REMAPPER.containsKey(name)) {
+      name = YCD_NAME_REMAPPER.get(name);
+    }
+    name += " " + currency;
+
+    final Set<CurveNode> nodes = new LinkedHashSet<>();
+    for (final FixedIncomeStrip strip : strips) {
+      String curveNodeIdMapperName;
+      if (CSBC_NAME_REMAPPER.containsKey(strip.getConventionName())) {
+        curveNodeIdMapperName = CSBC_NAME_REMAPPER.get(strip.getConventionName());
+      } else {
+        curveNodeIdMapperName = strip.getConventionName();
+      }
+      switch (strip.getInstrumentType()) {
+        case BANKERS_ACCEPTANCE:
+          if (currency.equals("CAD")) {
+            final int futureNumber = strip.getNumberOfFuturesAfterTenor();
+            final Tenor startTenor = strip.getCurveNodePointTime();
+            final Tenor futureTenor = Tenor.THREE_MONTHS;
+            final Tenor underlyingTenor = Tenor.THREE_MONTHS;
+            final String csbcName = strip.getConventionName();
+            final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+            csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+            csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+            csbcSearchRequest.setName(csbcName + "_" + currency);
+            ExternalId underlyingIborIdentifier = null;
+            for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+              final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+              underlyingIborIdentifier = csbc.getCDORSecurity(unused, Tenor.THREE_MONTHS);
+            }
+            if (underlyingIborIdentifier == null) {
+              s_logger.error("Could not get external id for " + strip);
+              break;
+            }
+            nodes.add(new RateFutureNode(futureNumber, startTenor, futureTenor, underlyingTenor, underlyingIborIdentifier, curveNodeIdMapperName));
+            break;
+          }
+          s_logger.error("{} config contains BANKERS_ACCEPTANCE: ignoring");
+          break;
+        case CASH: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          String conventionName;
+          if (maturityTenor.equals(Tenor.OVERNIGHT) || maturityTenor.equals(Tenor.DAY) || maturityTenor.equals(Tenor.ONE_DAY)) {
+            conventionName = currency + " Overnight";
+          } else {
+            conventionName = currency + " Deposit";
+          }
+          final ExternalId convention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, conventionName);
+          curveNodeIdMapperName += " " + currency;
+          nodes.add(new CashNode(startTenor, maturityTenor, convention, curveNodeIdMapperName));
+          break;
+        }
+        case CDOR:
+          if (currency.equals("CAD")) {
+            final Tenor startTenor = Tenor.of(Period.ZERO);
+            final Tenor maturityTenor = strip.getCurveNodePointTime();
+            final String csbcName = strip.getConventionName();
+            final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+            csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+            csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+            csbcSearchRequest.setName(csbcName + "_" + currency);
+            ExternalId cdorIdentifier = null;
+            for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+              final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+              cdorIdentifier = csbc.getCDORSecurity(unused, maturityTenor);
+            }
+            if (cdorIdentifier == null) {
+              s_logger.error("Could not get external id for " + strip);
+              break;
+            }
+            curveNodeIdMapperName += " 3m " + currency;
+            nodes.add(new CashNode(startTenor, maturityTenor, cdorIdentifier, curveNodeIdMapperName));
+            break;
+          }
+          s_logger.error("{} config contains CDOR: ignoring");
+          break;
+        case CIBOR:
+          if (currency.equals("DKK")) {
+            final Tenor startTenor = Tenor.of(Period.ZERO);
+            final Tenor maturityTenor = strip.getCurveNodePointTime();
+            final String csbcName = strip.getConventionName();
+            final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+            csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+            csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+            csbcSearchRequest.setName(csbcName + "_" + currency);
+            ExternalId ciborIdentifier = null;
+            for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+              final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+              ciborIdentifier = csbc.getCiborSecurity(unused, maturityTenor);
+            }
+            if (ciborIdentifier == null) {
+              s_logger.error("Could not get external id for " + strip);
+              break;
+            }
+            curveNodeIdMapperName += " 3m " + currency;
+            nodes.add(new CashNode(startTenor, maturityTenor, ciborIdentifier, curveNodeIdMapperName));
+            break;
+          }
+          s_logger.error("{} config contains Cibor: ignoring");
+          break;
+        case EURIBOR:
+          if (currency.equals("EUR")) {
+            final Tenor startTenor = Tenor.of(Period.ZERO);
+            final Tenor maturityTenor = strip.getCurveNodePointTime();
+            final String csbcName = strip.getConventionName();
+            final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+            csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+            csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+            csbcSearchRequest.setName(csbcName + "_" + currency);
+            ExternalId euriborIdentifier = null;
+            for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+              final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+              euriborIdentifier = csbc.getEuriborSecurity(unused, maturityTenor);
+            }
+            if (euriborIdentifier == null) {
+              s_logger.error("Could not get external id for " + strip);
+              break;
+            }
+            curveNodeIdMapperName += " 6m " + currency;
+            nodes.add(new CashNode(startTenor, maturityTenor, euriborIdentifier, curveNodeIdMapperName));
+            break;
+          }
+          s_logger.error("{} config contains Euribor: ignoring");
+          break;
+        case FRA_3M: {
+          final Tenor fixingEnd = strip.getCurveNodePointTime();
+          final Tenor fixingStart = Tenor.of(fixingEnd.getPeriod().minus(Period.ofMonths(3)));
+          final String csbcName = strip.getConventionName();
+          final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+          csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+          csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+          csbcSearchRequest.setName(csbcName + "_" + currency);
+          ExternalId underlyingIborIdentifier = null;
+          for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+            final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+            underlyingIborIdentifier = csbc.getLiborSecurity(unused, Tenor.THREE_MONTHS);
+          }
+          if (underlyingIborIdentifier == null) {
+            s_logger.error("Could not get external id for " + strip);
+            break;
+          }
+          curveNodeIdMapperName += " 3m " + currency;
+          nodes.add(new FRANode(fixingStart, fixingEnd, underlyingIborIdentifier, curveNodeIdMapperName));
+          break;
+        }
+        case FRA_6M: {
+          final Tenor fixingEnd = strip.getCurveNodePointTime();
+          final Tenor fixingStart = Tenor.of(fixingEnd.getPeriod().minus(Period.ofMonths(6)));
+          final String csbcName = strip.getConventionName();
+          final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+          csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+          csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+          csbcSearchRequest.setName(csbcName + "_" + currency);
+          ExternalId underlyingIborIdentifier = null;
+          for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+            final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+            underlyingIborIdentifier = csbc.getLiborSecurity(unused, Tenor.THREE_MONTHS);
+          }
+          if (underlyingIborIdentifier == null) {
+            s_logger.error("Could not get external id for " + strip);
+            break;
+          }
+          curveNodeIdMapperName += " 6m " + currency;
+          nodes.add(new FRANode(fixingStart, fixingEnd, underlyingIborIdentifier, curveNodeIdMapperName));
+          break;
+        }
+        case FUTURE: {
+          final int futureNumber = strip.getNumberOfFuturesAfterTenor();
+          final Tenor startTenor = strip.getCurveNodePointTime();
+          final Tenor futureTenor = Tenor.THREE_MONTHS;
+          final Tenor underlyingTenor = Tenor.THREE_MONTHS;
+          final String csbcName = strip.getConventionName();
+          final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+          csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+          csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+          csbcSearchRequest.setName(csbcName + "_" + currency);
+          ExternalId underlyingIborIdentifier = null;
+          for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+            final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+            if (currency.equals("EUR")) {
+              underlyingIborIdentifier = csbc.getEuriborSecurity(unused, Tenor.THREE_MONTHS);
+            } else {
+              underlyingIborIdentifier = csbc.getLiborSecurity(unused, Tenor.THREE_MONTHS);
+            }
+          }
+          if (underlyingIborIdentifier == null) {
+            s_logger.error("Could not get external id for " + strip);
+            break;
+          }
+          nodes.add(new RateFutureNode(futureNumber, startTenor, futureTenor, underlyingTenor, underlyingIborIdentifier, curveNodeIdMapperName));
+          break;
+        }
+        case LIBOR: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final String csbcName = strip.getConventionName();
+          final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+          csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+          csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+          csbcSearchRequest.setName(csbcName + "_" + currency);
+          ExternalId liborIdentifier = null;
+          for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+            final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+            liborIdentifier = csbc.getLiborSecurity(unused, maturityTenor);
+          }
+          if (liborIdentifier == null) {
+            s_logger.error("Could not get external id for " + strip);
+            break;
+          }
+          if (currency.equals("USD") || currency.equals("CAD")) {
+            curveNodeIdMapperName += " 3m " + currency;
+          } else {
+            curveNodeIdMapperName += " 6m " + currency;
+          }
+          nodes.add(new CashNode(startTenor, maturityTenor, liborIdentifier, curveNodeIdMapperName));
+          break;
+        }
+        case OIS_SWAP: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " OIS Fixed Leg");
+          final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " OIS Overnight Leg");
+          curveNodeIdMapperName += " " + currency;
+          nodes.add(new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName));
+          break;
+        }
+        case STIBOR:
+          if (currency.equals("SEK")) {
+            final Tenor startTenor = Tenor.of(Period.ZERO);
+            final Tenor maturityTenor = strip.getCurveNodePointTime();
+            final String csbcName = strip.getConventionName();
+            final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+            csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+            csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+            csbcSearchRequest.setName(csbcName + "_" + currency);
+            ExternalId stiborIdentifier = null;
+            for (final ConfigDocument csbcDocument : ConfigSearchIterator.iterable(configMaster, csbcSearchRequest)) {
+              final CurveSpecificationBuilderConfiguration csbc = ((ConfigItem<CurveSpecificationBuilderConfiguration>) csbcDocument.getConfig()).getValue();
+              stiborIdentifier = csbc.getEuriborSecurity(unused, maturityTenor);
+            }
+            if (stiborIdentifier == null) {
+              s_logger.error("Could not get external id for " + strip);
+              break;
+            }
+            curveNodeIdMapperName += " 6m " + currency;
+            nodes.add(new CashNode(startTenor, maturityTenor, stiborIdentifier, curveNodeIdMapperName));
+            break;
+          }
+          s_logger.error("{} config contains Stibor: ignoring");
+          break;
+        case SWAP_3M: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+          final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 3M IRS Ibor Leg");
+          curveNodeIdMapperName += " 3m " + currency;
+          nodes.add(new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName));
+          break;
+        }
+        case SWAP_6M: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+          final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 6M IRS Ibor Leg");
+          curveNodeIdMapperName += " 6m " + currency;
+          nodes.add(new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName));
+          break;
+        }
+        case SWAP_12M: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+          final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 12M IRS Ibor Leg");
+          curveNodeIdMapperName += " 12m " + currency;
+          nodes.add(new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName));
+          break;
+        }
+        case SWAP_28D: {
+          final Tenor startTenor = Tenor.of(Period.ZERO);
+          final Tenor maturityTenor = strip.getCurveNodePointTime();
+          final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+          final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 28D IRS Ibor Leg");
+          curveNodeIdMapperName += " 28d " + currency;
+          nodes.add(new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName));
+          break;
+        }
+        case BASIS_SWAP:
+        case CONTINUOUS_ZERO_DEPOSIT:
+        case FRA:
+        case PERIODIC_ZERO_DEPOSIT:
+        case SIMPLE_ZERO_DEPOSIT:
+        case SPREAD:
+        case SWAP:
+        case TENOR_SWAP:
+        default:
+          s_logger.error("Cannot handle strip instrument type {}", strip.getInstrumentType());
+          break;
+      }
+    }
+    return new InterpolatedCurveDefinition(name, nodes, oldConfig.getInterpolatorName(), oldConfig.getRightExtrapolatorName(), oldConfig.getLeftExtrapolatorName());
+  }
+
+  private static Map<String, CurveNodeIdMapper.Builder> convertCurveSpecificationBuilderConfigurations(final Map<Pair<String, String>, CurveSpecificationBuilderConfiguration> oldConfigs) {
+    final Map<String, CurveNodeIdMapper.Builder> result = new HashMap<>();
+    for (final Map.Entry<Pair<String, String>, CurveSpecificationBuilderConfiguration> entry : oldConfigs.entrySet()) {
+      final String currency = entry.getKey().getFirst();
+      String name = entry.getKey().getSecond().split("_")[0];
+      if (CSBC_NAME_REMAPPER.containsKey(name)) {
+        name = CSBC_NAME_REMAPPER.get(name);
+      }
+      final CurveSpecificationBuilderConfiguration oldConfig = entry.getValue();
+      if (oldConfig.getBasisSwapInstrumentProviders() != null) {
+        s_logger.error("Cannot handle basis swaps");
+      }
+      if (oldConfig.getCashInstrumentProviders() != null) {
+        final String newName = name + " " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getCashInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.cashNodeIds(convertInstrumentProviders(oldConfig.getCashInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getCDORInstrumentProviders() != null) {
+        if (currency.equals("CAD")) {
+          final String newName = name + " 3m " + currency;
+          if (result.containsKey(newName)) {
+            result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getCDORInstrumentProviders()));
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getCDORInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        } else {
+          s_logger.error("{} config contains CDOR: ignoring", currency);
+        }
+      }
+      if (oldConfig.getCiborInstrumentProviders() != null) {
+        if (currency.equals("DKK")) {
+          final String newName = name + " 6m " + currency;
+          if (result.containsKey(newName)) {
+            result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getCiborInstrumentProviders()));
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getCiborInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        } else {
+          s_logger.error("{} config contains Cibor: ignoring", currency);
+        }
+      }
+      if (oldConfig.getContinuousZeroDepositInstrumentProviders() != null) {
+        s_logger.error("Cannot handle continuous zero deposits");
+      }
+      if (oldConfig.getEuriborInstrumentProviders() != null) {
+        if (currency.equals("EUR")) {
+          final String newName = name + " 6m " + currency;
+          if (result.containsKey(newName)) {
+            result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getEuriborInstrumentProviders()));
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getEuriborInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        } else {
+          s_logger.error("{} config contains Euribor: ignoring", currency);
+        }
+      }
+      if (oldConfig.getFra3MInstrumentProviders() != null) {
+        final String newName = name + " 3m " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).fraNodeIds(convertInstrumentProviders(oldConfig.getFra3MInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.fraNodeIds(convertInstrumentProviders(oldConfig.getFra3MInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getFra6MInstrumentProviders() != null) {
+        final String newName = name + " 6m " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).fraNodeIds(convertInstrumentProviders(oldConfig.getFra6MInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.fraNodeIds(convertInstrumentProviders(oldConfig.getFra6MInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getFutureInstrumentProviders() != null) {
+        final String newName = name + " " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).rateFutureNodeIds(convertInstrumentProviders(oldConfig.getFutureInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.rateFutureNodeIds(convertInstrumentProviders(oldConfig.getFutureInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getLiborInstrumentProviders() != null) {
+        if (currency.equals("USD") || currency.equals("CAD")) {
+          final String newName = name + " 3m " + currency;
+          if (result.containsKey(newName)) {
+            result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getLiborInstrumentProviders()));
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getLiborInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        } else {
+          final String newName = name + " 6m " + currency;
+          if (result.containsKey(newName)) {
+            result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getLiborInstrumentProviders()));
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getLiborInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        }
+      }
+      if (oldConfig.getOISSwapInstrumentProviders() != null) {
+        final String newName = name + " Overnight " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).swapNodeIds(convertInstrumentProviders(oldConfig.getOISSwapInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.swapNodeIds(convertInstrumentProviders(oldConfig.getOISSwapInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getPeriodicZeroDepositInstrumentProviders() != null) {
+        s_logger.error("Cannot handle periodic zero deposits");
+      }
+      if (oldConfig.getSimpleZeroDepositInstrumentProviders() != null) {
+        s_logger.error("Cannot handle simple zero deposits");
+      }
+      if (oldConfig.getStiborInstrumentProviders() != null) {
+        if (currency.equals("SEK")) {
+          final String newName = name + " 3m " + currency;
+          if (result.containsKey(newName)) {
+            if (result.get(newName).build().getCashNodeIds() != null) {
+              final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+              builder.cashNodeIds(convertInstrumentProviders(oldConfig.getStiborInstrumentProviders()));
+              result.put(newName + " (Stibor)", builder);
+            } else {
+              result.get(newName).cashNodeIds(convertInstrumentProviders(oldConfig.getStiborInstrumentProviders()));
+            }
+          } else {
+            final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+            builder.cashNodeIds(convertInstrumentProviders(oldConfig.getStiborInstrumentProviders()));
+            result.put(newName, builder);
+          }
+        } else {
+          s_logger.error("{} config contains Stibor: ignoring", currency);
+        }
+      }
+      if (oldConfig.getSwap12MInstrumentProviders() != null) {
+        final String newName = name + " 12m " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).swapNodeIds(convertInstrumentProviders(oldConfig.getSwap12MInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.swapNodeIds(convertInstrumentProviders(oldConfig.getSwap12MInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getSwap28DInstrumentProviders() != null) {
+        final String newName = name + " 28d " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).swapNodeIds(convertInstrumentProviders(oldConfig.getSwap28DInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.swapNodeIds(convertInstrumentProviders(oldConfig.getSwap28DInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getSwap3MInstrumentProviders() != null) {
+        final String newName = name + " 3m " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).swapNodeIds(convertInstrumentProviders(oldConfig.getSwap3MInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.swapNodeIds(convertInstrumentProviders(oldConfig.getSwap3MInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getSwap6MInstrumentProviders() != null) {
+        final String newName = name + " 6m " + currency;
+        if (result.containsKey(newName)) {
+          result.get(newName).swapNodeIds(convertInstrumentProviders(oldConfig.getSwap6MInstrumentProviders()));
+        } else {
+          final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(newName);
+          builder.swapNodeIds(convertInstrumentProviders(oldConfig.getSwap6MInstrumentProviders()));
+          result.put(newName, builder);
+        }
+      }
+      if (oldConfig.getTenorSwapInstrumentProviders() != null) {
+        s_logger.error("Cannot handle tenor swaps");
+      }
+    }
+    return result;
+  }
+
+  private static Map<Tenor, CurveInstrumentProvider> convertInstrumentProviders(final Map<Tenor, CurveInstrumentProvider> providers) {
+    final LocalDate unused = LocalDate.now();
+    final Map<Tenor, CurveInstrumentProvider> result = new HashMap<>();
+    for (final Map.Entry<Tenor, CurveInstrumentProvider> entry : providers.entrySet()) {
+      final CurveInstrumentProvider value = entry.getValue();
+      if (value instanceof SyntheticIdentifierCurveInstrumentProvider) {
+        final Tenor tenor = entry.getKey();
+        final SyntheticIdentifierCurveInstrumentProvider provider = (SyntheticIdentifierCurveInstrumentProvider) value;
+        if (provider.getType() == StripInstrumentType.BASIS_SWAP) {
+          //          final ExternalId identifier = provider.getInstrument(unused, tenor, payTenor, receiveTenor, payIndexType, receiveIndexType);
+          //          final String dataField = provider.getMarketDataField();
+          //          final DataFieldType dataType = provider.getDataFieldType();
+          //          result.put(tenor, new StaticCurveInstrumentProvider(identifier, dataField, dataType));
+          s_logger.error("Cannot convert instrument provider for basis swaps");
+          //      @Override
+          //      public ExternalId getInstrument(final LocalDate curveDate, final Tenor tenor, final Tenor payTenor, final Tenor receiveTenor, final IndexType payIndexType,
+          //          final IndexType receiveIndexType) {
+          //        return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + "_" + payIndexType.name() + payTenor.getPeriod().toString() + receiveIndexType.name()
+          //            + receiveTenor.getPeriod().toString() + "_" + tenor.getPeriod().toString());
+          //      }
+        } else if (provider.getType() == StripInstrumentType.PERIODIC_ZERO_DEPOSIT) {
+          s_logger.error("Cannot convert instrument provider for periodic zero deposits");
+          //      @Override
+          //      public ExternalId getInstrument(final LocalDate curveDate, final Tenor tenor, final int periodsPerYear, final boolean isPeriodicZeroDeposit) {
+          //        return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + Integer.toString(periodsPerYear) + tenor.getPeriod().toString());
+          //      }
+        } else if (provider.getType() == StripInstrumentType.FUTURE) {
+          s_logger.error("Cannot convert instrument provider for futures");
+          //      @Override
+          //      public ExternalId getInstrument(final LocalDate curveDate, final Tenor startTenor, final Tenor futureTenor, final int numQuarterlyFuturesFromTenor) {
+          //        return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + startTenor.getPeriod().toString() + futureTenor.getPeriod().toString());
+          //      }
+          //      @Override
+          //      public ExternalId getInstrument(final LocalDate curveDate, final Tenor tenor, final int numQuarterlyFuturesFromTenor) {
+          //        return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + tenor.getPeriod().toString());
+          //      }
+        }
+        final ExternalId identifier = provider.getInstrument(unused, tenor);
+        final String dataField = provider.getMarketDataField();
+        final DataFieldType dataType = provider.getDataFieldType();
+        result.put(tenor, new StaticCurveInstrumentProvider(identifier, dataField, dataType));
+      } else if (value instanceof SyntheticFutureCurveInstrumentProvider) {
+        result.put(entry.getKey(), value);
+      } else {
+        s_logger.error("Cannot handle curve instrument providers of type {}", value.getClass());
+      }
+    }
+    return result;
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverter.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverter.java
new file mode 100644
index 0000000..552b79d
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverter.java
@@ -0,0 +1,169 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter;
+
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.BANKERS_ACCEPTANCE;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.BASIS_SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CASH;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CDOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CONTINUOUS_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.EURIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA_3M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA_6M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FUTURE;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.LIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.OIS_SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.PERIODIC_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SIMPLE_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SPREAD;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.STIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_12M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_28D;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_3M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_6M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.TENOR_SWAP;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.opengamma.examples.simulated.tool.converter.csbc.BasisSwapInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.CashInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.ContinuouslyCompoundedRateInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.DefaultCsbcRenamingFunction;
+import com.opengamma.examples.simulated.tool.converter.csbc.FixedCurrencyCsbcRenamingFunction;
+import com.opengamma.examples.simulated.tool.converter.csbc.FraInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.FutureInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.InstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.NoOpInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.PeriodicZeroDepositInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.SwapInstrumentProviderPopulator;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper.Builder;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.util.result.Function2;
+import com.opengamma.util.time.Tenor;
+import com.opengamma.util.tuple.Pair;
+
+/**
+ * Converts a {@link CurveSpecificationBuilderConfiguration} into {@link CurveNodeIdMapper}.
+ */
+public class CurveSpecificationBuilderConfigurationConverter {
+  private static final Logger s_logger = LoggerFactory.getLogger(CurveSpecificationBuilderConfigurationConverter.class);
+  private static final Map<StripInstrumentType, InstrumentProviderPopulator> CONVERTERS = new EnumMap<>(StripInstrumentType.class);
+
+  static {
+    CONVERTERS.put(BANKERS_ACCEPTANCE, new NoOpInstrumentProviderPopulator(BANKERS_ACCEPTANCE));
+    CONVERTERS.put(BASIS_SWAP, new BasisSwapInstrumentProviderPopulator(BASIS_SWAP));
+    CONVERTERS.put(CASH, new ReflectionStripConverter(CASH, "getCashInstrumentProviders", "cashNodeIds", new DefaultCsbcRenamingFunction()));
+    CONVERTERS.put(CDOR, new CashInstrumentProviderPopulator(CDOR, "getCDORInstrumentProviders", new FixedCurrencyCsbcRenamingFunction("CAD", "CDOR")));
+    CONVERTERS.put(CIBOR, new CashInstrumentProviderPopulator(CIBOR, "getCiborInstrumentProviders", new FixedCurrencyCsbcRenamingFunction("DKK", "Cibor")));
+    CONVERTERS.put(CONTINUOUS_ZERO_DEPOSIT, new ContinuouslyCompoundedRateInstrumentProviderPopulator());
+    CONVERTERS.put(EURIBOR, new CashInstrumentProviderPopulator(EURIBOR, "getEuriborInstrumentProviders", new FixedCurrencyCsbcRenamingFunction("EUR", "Euribor")));
+    CONVERTERS.put(FRA, new NoOpInstrumentProviderPopulator(FRA));
+    CONVERTERS.put(FRA_3M, new FraInstrumentProviderPopulator(FRA_3M, "getFra3MInstrumentProviders", new DefaultCsbcRenamingFunction("3m")));
+    CONVERTERS.put(FRA_6M, new FraInstrumentProviderPopulator(FRA_6M, "getFra6MInstrumentProviders", new DefaultCsbcRenamingFunction("6m")));
+    CONVERTERS.put(FUTURE, new FutureInstrumentProviderPopulator());
+    CONVERTERS.put(LIBOR, new CashInstrumentProviderPopulator(LIBOR, "getLiborInstrumentProviders", new DefaultCsbcRenamingFunction("Libor")));
+    CONVERTERS.put(OIS_SWAP, new SwapInstrumentProviderPopulator(OIS_SWAP, "getOISSwapInstrumentProviders"));
+    CONVERTERS.put(PERIODIC_ZERO_DEPOSIT, new PeriodicZeroDepositInstrumentProviderPopulator());
+    CONVERTERS.put(SIMPLE_ZERO_DEPOSIT, new NoOpInstrumentProviderPopulator(SIMPLE_ZERO_DEPOSIT));
+    CONVERTERS.put(SPREAD, new NoOpInstrumentProviderPopulator(SPREAD));
+    CONVERTERS.put(STIBOR, new CashInstrumentProviderPopulator(STIBOR, "getStiborInstrumentProviders", new FixedCurrencyCsbcRenamingFunction("SEK", "Stibor")));
+    CONVERTERS.put(SWAP, new NoOpInstrumentProviderPopulator(SWAP));
+    CONVERTERS.put(SWAP_28D, new SwapInstrumentProviderPopulator(SWAP_28D, "getSwap28DInstrumentProviders", new DefaultCsbcRenamingFunction("28d")));
+    CONVERTERS.put(SWAP_3M, new SwapInstrumentProviderPopulator(SWAP_3M, "getSwap3MInstrumentProviders", new DefaultCsbcRenamingFunction("3m")));
+    CONVERTERS.put(SWAP_6M, new SwapInstrumentProviderPopulator(SWAP_6M, "getSwap6MInstrumentProviders", new DefaultCsbcRenamingFunction("6m")));
+    CONVERTERS.put(SWAP_12M, new SwapInstrumentProviderPopulator(SWAP_12M, "getSwap12MInstrumentProviders", new DefaultCsbcRenamingFunction("12m")));
+    CONVERTERS.put(TENOR_SWAP, new BasisSwapInstrumentProviderPopulator(TENOR_SWAP));
+  }
+
+  public static Collection<CurveNodeIdMapper> convert(final String currency, final Map<String, CurveSpecificationBuilderConfiguration> configMap) {
+    return convert(currency, configMap, CONVERTERS);
+  }
+
+  public static Collection<CurveNodeIdMapper> convert(final String currency, final Map<String, CurveSpecificationBuilderConfiguration> configMap,
+      final Map<StripInstrumentType, InstrumentProviderPopulator> converters) {
+    final Map<String, CurveNodeIdMapper.Builder> convertedWithNames = new HashMap<>();
+    for (final Map.Entry<String, CurveSpecificationBuilderConfiguration> convertedEntry : configMap.entrySet()) {
+      final String originalName = convertedEntry.getKey();
+      final CurveSpecificationBuilderConfiguration originalConfig = convertedEntry.getValue();
+      for (final Map.Entry<StripInstrumentType, InstrumentProviderPopulator> entry : converters.entrySet()) {
+        final InstrumentProviderPopulator converter = entry.getValue();
+        final Builder remappedNameBuilder = convertedWithNames.get(originalName);
+        final Pair<String, CurveNodeIdMapper.Builder> pair;
+        if (remappedNameBuilder != null) {
+          pair = converter.apply(remappedNameBuilder.build(), originalConfig, currency);
+        } else {
+          pair = converter.apply(CurveNodeIdMapper.builder().name(originalName).build(), originalConfig, currency);
+        }
+        convertedWithNames.put(pair.getFirst(), pair.getSecond());
+      }
+    }
+    final Set<CurveNodeIdMapper> converted = new HashSet<>();
+    for (final Map.Entry<String, CurveNodeIdMapper.Builder> entry : convertedWithNames.entrySet()) {
+      final CurveNodeIdMapper idMapper = entry.getValue().build();
+      if (idMapper.getAllTenors().size() != 0) {
+        converted.add(idMapper);
+      }
+    }
+    return converted;
+  }
+
+  public static class ReflectionStripConverter extends InstrumentProviderPopulator {
+    private final StripInstrumentType _type;
+    private final String _builderMethodName;
+    private final String _builderGetterName;
+
+    public ReflectionStripConverter(final StripInstrumentType type, final String instrumentProviderName, final String builderMethodName,
+        final Function2<String, String, String> renamingFunction) {
+      super(instrumentProviderName, renamingFunction);
+      _type = type;
+      _builderMethodName = builderMethodName;
+      final StringBuilder sb = new StringBuilder("get");
+      sb.append(_builderMethodName.substring(0, 1).toUpperCase());
+      sb.append(_builderMethodName.substring(1));
+      _builderGetterName = sb.toString();
+    }
+
+    public ReflectionStripConverter(final StripInstrumentType type, final String instrumentProviderName, final String builderGetterName,
+        final String builderMethodName, final Function2<String, String, String> renamingFunction) {
+      super(instrumentProviderName, renamingFunction);
+      _type = type;
+      _builderGetterName = builderGetterName;
+      _builderMethodName = builderMethodName;
+    }
+
+    @Override
+    public Builder createBuilder(final CurveNodeIdMapper idMapper, final Map<Tenor, CurveInstrumentProvider> instrumentProviders,
+        final String currency) {
+      try {
+        final Method getMethod = CurveNodeIdMapper.class.getMethod(_builderGetterName, (Class<?>[]) null);
+        if (getMethod.invoke(idMapper, (Object[]) null) != null) {
+          s_logger.warn("Nodes already exist in mapper called {}; overwriting with {}", _type);
+        }
+        final Builder newBuilder = copyToBuilder(idMapper, currency);
+        final Method builderMethod = Builder.class.getMethod(_builderMethodName, Map.class);
+        return (Builder) builderMethod.invoke(newBuilder, instrumentProviders);
+      } catch (final NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+        throw new RuntimeException(e.getMessage());
+      }
+    }
+
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/YieldCurveDefinitionConverter.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/YieldCurveDefinitionConverter.java
new file mode 100644
index 0000000..01424cd
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/YieldCurveDefinitionConverter.java
@@ -0,0 +1,400 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter;
+
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.BANKERS_ACCEPTANCE;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.BASIS_SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CASH;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CDOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.CONTINUOUS_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.EURIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA_3M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FRA_6M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.FUTURE;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.LIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.OIS_SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.PERIODIC_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SIMPLE_ZERO_DEPOSIT;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SPREAD;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.STIBOR;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_12M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_28D;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_3M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.SWAP_6M;
+import static com.opengamma.financial.analytics.ircurve.StripInstrumentType.TENOR_SWAP;
+
+import java.util.EnumMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.threeten.bp.LocalDate;
+import org.threeten.bp.Period;
+
+import com.opengamma.financial.analytics.curve.InterpolatedCurveDefinition;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.FixedIncomeStrip;
+import com.opengamma.financial.analytics.ircurve.IndexType;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.financial.analytics.ircurve.YieldCurveDefinition;
+import com.opengamma.financial.analytics.ircurve.strips.CashNode;
+import com.opengamma.financial.analytics.ircurve.strips.CurveNode;
+import com.opengamma.financial.analytics.ircurve.strips.FRANode;
+import com.opengamma.financial.analytics.ircurve.strips.RateFutureNode;
+import com.opengamma.financial.analytics.ircurve.strips.SwapNode;
+import com.opengamma.financial.convention.initializer.PerCurrencyConventionHelper;
+import com.opengamma.id.ExternalId;
+import com.opengamma.id.VersionCorrection;
+import com.opengamma.master.config.ConfigSearchRequest;
+import com.opengamma.util.time.Tenor;
+
+public class YieldCurveDefinitionConverter {
+  private static final Map<StripInstrumentType, StripConverter> STRIP_CONVERTERS = new EnumMap<>(StripInstrumentType.class);
+
+  static {
+    final StripConverter exceptionConverter = new ExceptionStripConverter();
+    STRIP_CONVERTERS.put(LIBOR, new LiborStripConverter());
+    STRIP_CONVERTERS.put(CASH, new CashStripConverter());
+    STRIP_CONVERTERS.put(FRA, exceptionConverter);
+    STRIP_CONVERTERS.put(FUTURE, new FutureStripConverter());
+    STRIP_CONVERTERS.put(BANKERS_ACCEPTANCE, new BankersAcceptanceStripConverter());
+    STRIP_CONVERTERS.put(SWAP, exceptionConverter);
+    STRIP_CONVERTERS.put(TENOR_SWAP, new TenorSwapStripConverter());
+    STRIP_CONVERTERS.put(BASIS_SWAP, new BasisSwapStripConverter());
+    STRIP_CONVERTERS.put(OIS_SWAP, new OisStripConverter());
+    STRIP_CONVERTERS.put(EURIBOR, new EuriborStripConverter());
+    STRIP_CONVERTERS.put(FRA_3M, new Fra3mStripConverter());
+    STRIP_CONVERTERS.put(FRA_6M, new Fra6mStripConverter());
+    STRIP_CONVERTERS.put(SWAP_3M, new Swap3mStripConverter());
+    STRIP_CONVERTERS.put(SWAP_6M, new Swap6mStripConverter());
+    STRIP_CONVERTERS.put(SWAP_12M, new Swap12mStripConverter());
+    STRIP_CONVERTERS.put(CDOR, new CdorStripConverter());
+    STRIP_CONVERTERS.put(CIBOR, new CiborStripConverter());
+    STRIP_CONVERTERS.put(STIBOR, new StiborStripConverter());
+    STRIP_CONVERTERS.put(SIMPLE_ZERO_DEPOSIT, exceptionConverter);
+    STRIP_CONVERTERS.put(PERIODIC_ZERO_DEPOSIT, exceptionConverter);
+    STRIP_CONVERTERS.put(CONTINUOUS_ZERO_DEPOSIT, exceptionConverter);
+    STRIP_CONVERTERS.put(SPREAD, exceptionConverter);
+    STRIP_CONVERTERS.put(SWAP_28D, new Swap28dStripConverter());
+  }
+
+  public static InterpolatedCurveDefinition convert(final String curveName, final String currency, final YieldCurveDefinition originalDefinition,
+      final Map<String, CurveSpecificationBuilderConfiguration> identifierMap) {
+    final Set<CurveNode> nodes = new HashSet<>();
+    for (final FixedIncomeStrip strip : originalDefinition.getStrips()) {
+      final StripConverter stripConverter = STRIP_CONVERTERS.get(strip.getInstrumentType());
+      if (stripConverter == null) {
+        throw new UnsupportedOperationException();
+      }
+      final CurveSpecificationBuilderConfiguration identifiers = identifierMap.get(strip.getConventionName());
+      if (identifiers == null) {
+        throw new UnsupportedOperationException();
+      }
+      nodes.add(stripConverter.apply(strip, currency, identifiers));
+    }
+    return new InterpolatedCurveDefinition(curveName, nodes, originalDefinition.getInterpolatorName(),
+        originalDefinition.getRightExtrapolatorName(), originalDefinition.getLeftExtrapolatorName());
+  }
+
+  public interface StripConverter {
+
+    public CurveNode apply(FixedIncomeStrip strip, String currency, CurveSpecificationBuilderConfiguration identifiers);
+  }
+
+  private static class ExceptionStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      throw new UnsupportedOperationException();
+    }
+
+  }
+
+  private static class BankersAcceptanceStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      if (!currency.equals("CAD")) {
+        throw new IllegalStateException();
+      }
+      final int futureNumber = strip.getNumberOfFuturesAfterTenor();
+      final Tenor startTenor = strip.getCurveNodePointTime();
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      final Tenor futureTenor = Tenor.THREE_MONTHS;
+      final Tenor underlyingTenor = Tenor.THREE_MONTHS;
+      final ExternalId underlyingIborIdentifier = identifiers.getCDORSecurity(LocalDate.now(), Tenor.THREE_MONTHS);
+      return new RateFutureNode(futureNumber, startTenor, futureTenor, underlyingTenor, underlyingIborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class CashStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      String conventionName;
+      if (maturityTenor.equals(Tenor.OVERNIGHT) || maturityTenor.equals(Tenor.DAY) || maturityTenor.equals(Tenor.ONE_DAY)) {
+        conventionName = currency + " Overnight";
+      } else {
+        conventionName = currency + " Deposit";
+      }
+      final ExternalId convention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, conventionName);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, convention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class CdorStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      if (!currency.equals("CAD")) {
+        throw new IllegalStateException();
+      }
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId cdorIdentifier = identifiers.getCDORSecurity(LocalDate.now(), maturityTenor);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, cdorIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class CiborStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      if (!currency.equals("DKK")) {
+        throw new IllegalStateException();
+      }
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId ciborIdentifier = identifiers.getCiborSecurity(LocalDate.now(), maturityTenor);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, ciborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class EuriborStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      if (!currency.equals("EUR")) {
+        throw new IllegalStateException();
+      }
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId euriborIdentifier = identifiers.getCiborSecurity(LocalDate.now(), maturityTenor);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, euriborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Fra3mStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor fixingEnd = strip.getCurveNodePointTime();
+      final Tenor fixingStart = Tenor.of(fixingEnd.getPeriod().minus(Period.ofMonths(3)));
+      final ExternalId underlyingIborIdentifier = identifiers.getLiborSecurity(LocalDate.now(), Tenor.THREE_MONTHS);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new FRANode(fixingStart, fixingEnd, underlyingIborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Fra6mStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor fixingEnd = strip.getCurveNodePointTime();
+      final Tenor fixingStart = Tenor.of(fixingEnd.getPeriod().minus(Period.ofMonths(6)));
+      final ExternalId underlyingIborIdentifier = identifiers.getLiborSecurity(LocalDate.now(), Tenor.SIX_MONTHS);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new FRANode(fixingStart, fixingEnd, underlyingIborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class FutureStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final int futureNumber = strip.getNumberOfFuturesAfterTenor();
+      final Tenor startTenor = strip.getCurveNodePointTime();
+      final Tenor futureTenor = Tenor.THREE_MONTHS;
+      final Tenor underlyingTenor = Tenor.THREE_MONTHS;
+      final ExternalId underlyingIborIdentifier;
+      if (currency.equals("EUR")) {
+        underlyingIborIdentifier = identifiers.getEuriborSecurity(LocalDate.now(), Tenor.THREE_MONTHS);
+      } else {
+        underlyingIborIdentifier = identifiers.getLiborSecurity(LocalDate.now(), Tenor.THREE_MONTHS);
+      }
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new RateFutureNode(futureNumber, startTenor, futureTenor, underlyingTenor, underlyingIborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class LiborStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final String csbcName = strip.getConventionName();
+      final ConfigSearchRequest<CurveSpecificationBuilderConfiguration> csbcSearchRequest = new ConfigSearchRequest<>();
+      csbcSearchRequest.setType(CurveSpecificationBuilderConfiguration.class);
+      csbcSearchRequest.setVersionCorrection(VersionCorrection.LATEST);
+      csbcSearchRequest.setName(csbcName + "_" + currency);
+      final ExternalId liborIdentifier = identifiers.getLiborSecurity(LocalDate.now(), maturityTenor);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, liborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class OisStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " OIS Fixed Leg");
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " OIS Overnight Leg");
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class StiborStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      if (!currency.equals("SEK")) {
+        throw new IllegalStateException();
+      }
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId stiborIdentifier = identifiers.getEuriborSecurity(LocalDate.now(), maturityTenor);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new CashNode(startTenor, maturityTenor, stiborIdentifier, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Swap3mStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 3M IRS Ibor Leg");
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Swap6mStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 6M IRS Ibor Leg");
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Swap12mStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 12M IRS Ibor Leg");
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class Swap28dStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " IRS Fixed Leg");
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, currency + " 28D IRS Ibor Leg");
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+  }
+
+  private static class BasisSwapStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final Tenor payTenor = strip.getPayTenor();
+      final Tenor receiveTenor = strip.getReceiveTenor();
+      final IndexType indexType = strip.getIndexType();
+      String indexString;
+      switch (indexType) {
+        case Euribor:
+        case Libor:
+        case Tibor:
+          indexString = "Ibor";
+          break;
+        case BBSW:
+        case Swap:
+        default:
+          indexString = indexType.name();
+          break;
+      }
+      final String payLegConventionName = currency + " " + payTenor.getPeriod().toString().substring(1) + " IRS " + indexString + " Leg";
+      final String receiveLegConventionName = currency + " " + receiveTenor.getPeriod().toString().substring(1) + " IRS " + indexString + " Leg";
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, payLegConventionName);
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, receiveLegConventionName);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+
+  }
+
+  private static class TenorSwapStripConverter implements StripConverter {
+
+    @Override
+    public CurveNode apply(final FixedIncomeStrip strip, final String currency, final CurveSpecificationBuilderConfiguration identifiers) {
+      final Tenor startTenor = Tenor.of(Period.ZERO);
+      final Tenor maturityTenor = strip.getCurveNodePointTime();
+      final Tenor payTenor = strip.getPayTenor();
+      final Tenor receiveTenor = strip.getReceiveTenor();
+      final IndexType indexType = strip.getIndexType();
+      String indexString;
+      switch (indexType) {
+        case Euribor:
+        case Libor:
+        case Tibor:
+          indexString = "Ibor";
+          break;
+        case BBSW:
+        case Swap:
+        default:
+          indexString = indexType.name();
+          break;
+      }
+      final String payLegConventionName = currency + " " + payTenor.getPeriod().toString().substring(1) + " IRS " + indexString + " Leg";
+      final String receiveLegConventionName = currency + " " + receiveTenor.getPeriod().toString().substring(1) + " IRS " + indexString + " Leg";
+      final ExternalId payLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, payLegConventionName);
+      final ExternalId receiveLegConvention = ExternalId.of(PerCurrencyConventionHelper.SCHEME_NAME, receiveLegConventionName);
+      final String curveNodeIdMapperName = strip.getConventionName() + " " + currency;
+      return new SwapNode(startTenor, maturityTenor, payLegConvention, receiveLegConvention, curveNodeIdMapperName);
+    }
+
+  }
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunction.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunction.java
new file mode 100644
index 0000000..a2b3960
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunction.java
@@ -0,0 +1,65 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import org.apache.commons.lang.ObjectUtils;
+
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.util.result.Function2;
+
+/**
+ *
+ * The default renaming function for {@link CurveSpecificationBuilderConfiguration}. If
+ * {@link #_name} is null, the new name is "[original name] [ISO currency string]. 
+ * If {@link #_name} is not null, the new name is "[original name] [_name] [ISO currency string]".
+ * 
+ * @author emcleod
+ */
+public class DefaultCsbcRenamingFunction implements Function2<String, String, String> {
+  /** A string containing additional information */
+  private final String _name;
+
+  /**
+   * Sets the additional string to null
+   */
+  public DefaultCsbcRenamingFunction() {
+    this(null);
+  }
+
+  /**
+   * @param name The additional string, can be null
+   */
+  public DefaultCsbcRenamingFunction(final String name) {
+    _name = name;
+  }
+
+  @Override
+  public String apply(final String name, final String currency) {
+    return _name == null ? name + " " + currency : name + " " + _name + " " + currency;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((_name == null) ? 0 : _name.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!(obj instanceof DefaultCsbcRenamingFunction)) {
+      return false;
+    }
+    final DefaultCsbcRenamingFunction other = (DefaultCsbcRenamingFunction) obj;
+    if (!ObjectUtils.equals(_name, other._name)) {
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunction.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunction.java
new file mode 100644
index 0000000..554fe7a
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunction.java
@@ -0,0 +1,76 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import org.apache.commons.lang.ObjectUtils;
+
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.result.Function2;
+
+/**
+ * A renaming function for {@link CurveSpecificationBuilderConfiguration} where the currency
+ * string is fixed upon construction. If {@link #_name} is null, the new name is 
+ * "[original name] [ISO currency string]. If {@link #_name} is not null, the new name is 
+ * "[original name] [_name] [ISO currency string]".
+ *
+ * @author emcleod
+ */
+public class FixedCurrencyCsbcRenamingFunction implements Function2<String, String, String> {
+  /** The currency */
+  private final String _currency;
+  /** A string containing additional information */
+  private final String _name;
+
+  /**
+   * Sets the additional string to null
+   * @param currency The currency string, not null
+   */
+  public FixedCurrencyCsbcRenamingFunction(final String currency) {
+    this(currency, null);
+  }
+
+  /**
+   * @param currency The currency string, not null
+   * @param name The additional string, can be null
+   */
+  public FixedCurrencyCsbcRenamingFunction(final String currency, final String name) {
+    ArgumentChecker.notNull(currency, "currency");
+    _currency = currency;
+    _name = name;
+  }
+
+  @Override
+  public String apply(final String name, final String currency) {
+    return _name == null ? name + " " + _currency : name + " " + _name + " " + _currency;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + _currency.hashCode();
+    result = prime * result + ((_name == null) ? 0 : _name.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!(obj instanceof FixedCurrencyCsbcRenamingFunction)) {
+      return false;
+    }
+    final FixedCurrencyCsbcRenamingFunction other = (FixedCurrencyCsbcRenamingFunction) obj;
+    if (!ObjectUtils.equals(_name, other._name)) {
+      return false;
+    }
+    if (!ObjectUtils.equals(_currency, other._currency)) {
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FutureInstrumentProviderPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FutureInstrumentProviderPopulator.java
new file mode 100644
index 0000000..1111404
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/FutureInstrumentProviderPopulator.java
@@ -0,0 +1,77 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper.Builder;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.financial.analytics.ircurve.strips.RateFutureNode;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.result.Function2;
+import com.opengamma.util.time.Tenor;
+
+/**
+ * Class that populates a curve node id mapper with the curve instrument providers for a
+ * {@link StripInstrumentType#FUTURE} strip. If a map for {@link RateFutureNode}s is 
+ * already present, this class will overwrite that entry.
+ *
+ * @author emcleod
+ */
+public class FutureInstrumentProviderPopulator extends InstrumentProviderPopulator {
+  /** The logger */
+  private static final Logger s_logger = LoggerFactory.getLogger(FutureInstrumentProviderPopulator.class);
+
+  /**
+   * Sets the renaming function to {@link DefaultCsbcRenamingFunction}.
+   */
+  public FutureInstrumentProviderPopulator() {
+    this(new DefaultCsbcRenamingFunction());
+  }
+
+  /**
+   * Sets the getter method name to null, as the getter name for future strips is known.
+   * @param renamingFunction The renaming function, not null
+   */
+  public FutureInstrumentProviderPopulator(final Function2<String, String, String> renamingFunction) {
+    super(null, renamingFunction);
+  }
+
+  /**
+   * Creates a builder from the id mapper, copying any maps that have already been populated,
+   * and populates the rate future node id map. This method will overwrite the rate future
+   * node ids if they are already present in the curve node id mapper.
+   * @param idMapper The id mapper, not null
+   * @param instrumentProviders The instrument provider map, not null
+   * @param mapperName The new name for the mapper, not null
+   * @return A curve node id mapper builder with populated instrument provider maps.
+   */
+  @Override
+  public Builder createBuilder(final CurveNodeIdMapper idMapper, final Map<Tenor, CurveInstrumentProvider> instrumentProviders,
+      final String mapperName) {
+    if (idMapper.getRateFutureNodeIds() != null) {
+      s_logger.warn("Rate future nodes already exist in mapper called {}, overwriting", idMapper.getName());
+    }
+    return copyToBuilder(idMapper, mapperName).rateFutureNodeIds(instrumentProviders);
+  }
+
+  /**
+   * Gets the map of future instrument providers from the curve specification builder configuration
+   * using {@link CurveSpecificationBuilderConfiguration#getFutureInstrumentProviders()}.
+   * @param csbc The curve specification builder configuration, not null
+   * @return A map from tenor to curve instrument provider.
+   */
+  @Override
+  public Map<Tenor, CurveInstrumentProvider> getInstrumentProviders(final CurveSpecificationBuilderConfiguration csbc) {
+    ArgumentChecker.notNull(csbc, "csbc");
+    return csbc.getFutureInstrumentProviders();
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/InstrumentProviderPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/InstrumentProviderPopulator.java
new file mode 100644
index 0000000..fc81674
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/InstrumentProviderPopulator.java
@@ -0,0 +1,195 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.lang.ObjectUtils;
+
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.result.Function2;
+import com.opengamma.util.time.Tenor;
+import com.opengamma.util.tuple.Pair;
+import com.opengamma.util.tuple.Pairs;
+
+/**
+ * Abstract base for classes that help to convert {@link CurveSpecificationBuilderConfiguration} to
+ * {@link CurveNodeIdMapper}. These classes copy the data for each strip type into the appropriate
+ * methods in the node mapper.
+ * <p>
+ * This class provides renaming functions for a given method that returns
+ * the map from {@link Tenor} to {@link CurveInstrumentProvider} in
+ * {@link CurveSpecificationBuilderConfiguration} for a particular {@link StripInstrumentType} e.g. 
+ * {@link CurveSpecificationBuilderConfiguration#getCashInstrumentProviders()}. 
+ * <p>
+ * Once the map has been returned, an empty {@link com.opengamma.financial.analytics.curve.CurveNodeIdMapper.Builder} 
+ * is created if the map is null or empty, or the builder is created with existing maps populated. 
+ * <p>
+ * This class uses reflection to call the correct method, but implementing classes can use
+ * a direct method call if they are intended to be used for a single strip type.
+ */
+public abstract class InstrumentProviderPopulator {
+  /** The getter name to call */
+  private final String _instrumentProviderMethodName;
+  /** The renaming function */
+  private final Function2<String, String, String> _renamingFunction;
+
+  /**
+   * Sets the renaming function to {@link DefaultCsbcRenamingFunction}.
+   * @param instrumentProviderMethodName The instrument provider getter method name, can be null
+   */
+  public InstrumentProviderPopulator(final String instrumentProviderMethodName) {
+    this(instrumentProviderMethodName, new DefaultCsbcRenamingFunction());
+  }
+
+  /**
+   * @param instrumentProviderMethodName The instrument provider getter method name, can be null
+   * @param renamingFunction The renaming function, not null
+   */
+  public InstrumentProviderPopulator(final String instrumentProviderMethodName, final Function2<String, String, String> renamingFunction) {
+    ArgumentChecker.notNull(renamingFunction, "renamingFunction");
+    _instrumentProviderMethodName = instrumentProviderMethodName;
+    //TODO test here that the method name exists?
+    _renamingFunction = renamingFunction;
+  }
+
+  /**
+   * Returns a (name, {@link com.opengamma.financial.analytics.curve.CurveNodeIdMapper.Builder}) 
+   * pair with the id mapper populated with the appropriate (Tenor, CurveInstrumentProvider) map, 
+   * depending on the value of {@link #_instrumentProviderMethodName}. The id mapper argument is
+   * copied, not altered in place.
+   * @param idMapper The id mapper of which to create a copy, not null
+   * @param identifiers The curve specification builder configuration from which to copy the map, not null
+   * @param currency The currency of the curve specification builder configuration, not null
+   * @return A (id mapper name, builder) pair.
+   */
+  public Pair<String, CurveNodeIdMapper.Builder> apply(final CurveNodeIdMapper idMapper, final CurveSpecificationBuilderConfiguration identifiers,
+      final String currency) {
+    ArgumentChecker.notNull(idMapper, "idMapper");
+    ArgumentChecker.notNull(identifiers, "identifiers");
+    ArgumentChecker.notNull(currency, "currency");
+    final Map<Tenor, CurveInstrumentProvider> instrumentProviders = getInstrumentProviders(identifiers);
+    final String mapperName = rename(idMapper.getName(), currency);
+    if (instrumentProviders == null || instrumentProviders.isEmpty()) {
+      return Pairs.of(mapperName, copyToBuilder(idMapper, mapperName));
+    }
+    return Pairs.of(mapperName, createBuilder(idMapper, instrumentProviders, mapperName));
+  }
+
+  /**
+   * Creates a builder from the id mapper, copying any maps that have already been populated,
+   * and populates the appropriate map for the strip instrument type.
+   * @param idMapper The id mapper, not null
+   * @param instrumentProviders The instrument provider map, not null
+   * @param mapperName The new name for the mapper, not null
+   * @return A curve node id mapper builder with populated instrument provider maps.
+   */
+  public abstract CurveNodeIdMapper.Builder createBuilder(CurveNodeIdMapper idMapper, Map<Tenor, CurveInstrumentProvider> instrumentProviders,
+      String mapperName);
+
+  /**
+   * Gets the map of instrument providers from the curve specification builder configuration. 
+   * This method uses reflection to call the correct getter and can be overridden in implementing
+   * classes that only handle one strip instrument type to improve performance.
+   * @param csbc The curve specification builder configuration, not null
+   * @return A map from tenor to curve instrument provider.
+   * @throw RuntimeException If the getter cannot be found or there is a problem calling the getter.
+   */
+  public Map<Tenor, CurveInstrumentProvider> getInstrumentProviders(final CurveSpecificationBuilderConfiguration csbc) {
+    ArgumentChecker.notNull(csbc, "csbc");
+    try {
+      final Method method = csbc.getClass().getMethod(_instrumentProviderMethodName, (Class<?>[]) null);
+      return (Map<Tenor, CurveInstrumentProvider>) method.invoke(csbc, (Object[]) null);
+    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+      throw new RuntimeException(e.getMessage());
+    }
+  }
+
+  /**
+   * Applies a renaming function which generates a name for the curve node id mapper from
+   * the name of the curve specification builder configuration and optionally the currency.
+   * @param name The name of the curve specification builder configuration, not null
+   * @param currency The currency string, not null
+   * @return The name of the curve node id mapper
+   */
+  public String rename(final String name, final String currency) {
+    ArgumentChecker.notNull(name, "name");
+    ArgumentChecker.notNull(currency, "currency");
+    return _renamingFunction.apply(name, currency);
+  }
+
+  /**
+   * Creates a curve node id mapper builder from an original id mapper. The original id mapper
+   * is not changed, and maps in the builder are copies of those in the original. 
+   * <p>
+   * This method copies cash, continuously compounded rate, FRA, periodically compounded rate,
+   * rate future and swap node maps. Other curve node types are not copied, as there is no 
+   * equivalent strip instrument type.
+   * @param mapper The mapper, not null
+   * @param mapperName The new name for the mapper, not null
+   * @return A builder with any non-null maps from the original mapper populated.
+   */
+  protected CurveNodeIdMapper.Builder copyToBuilder(final CurveNodeIdMapper mapper, final String mapperName) {
+    ArgumentChecker.notNull(mapper, "mapper");
+    ArgumentChecker.notNull(mapper, "mapperName");
+    final CurveNodeIdMapper.Builder builder = CurveNodeIdMapper.builder().name(mapperName);
+    if (mapper.getAllTenors().size() == 0) {
+      return builder;
+    }
+    if (mapper.getCashNodeIds() != null) {
+      builder.cashNodeIds(new HashMap<>(mapper.getCashNodeIds()));
+    }
+    if (mapper.getContinuouslyCompoundedRateNodeIds() != null) {
+      builder.continuouslyCompoundedRateNodeIds(new HashMap<>(mapper.getContinuouslyCompoundedRateNodeIds()));
+    }
+    if (mapper.getFRANodeIds() != null) {
+      builder.fraNodeIds(new HashMap<>(mapper.getFRANodeIds()));
+    }
+    if (mapper.getPeriodicallyCompoundedRateNodeIds() != null) {
+      builder.periodicallyCompoundedRateNodeIds(new HashMap<>(mapper.getPeriodicallyCompoundedRateNodeIds()));
+    }
+    if (mapper.getRateFutureNodeIds() != null) {
+      builder.rateFutureNodeIds(new HashMap<>(mapper.getRateFutureNodeIds()));
+    }
+    if (mapper.getSwapNodeIds() != null) {
+      builder.swapNodeIds(new HashMap<>(mapper.getSwapNodeIds()));
+    }
+    return builder;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + (_instrumentProviderMethodName == null ? 0 : _instrumentProviderMethodName.hashCode());
+    result = prime * result + _renamingFunction.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!(obj instanceof InstrumentProviderPopulator)) {
+      return false;
+    }
+    final InstrumentProviderPopulator other = (InstrumentProviderPopulator) obj;
+    if (!ObjectUtils.equals(_instrumentProviderMethodName, other._instrumentProviderMethodName)) {
+      return false;
+    }
+    if (!ObjectUtils.equals(_renamingFunction, other._renamingFunction)) {
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/NoOpInstrumentProviderPopulator.java b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/NoOpInstrumentProviderPopulator.java
new file mode 100644
index 0000000..6a1b94c
--- /dev/null
+++ b/examples/examples-simulated/src/main/java/com/opengamma/examples/simulated/tool/converter/csbc/NoOpInstrumentProviderPopulator.java
@@ -0,0 +1,69 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import java.util.Collections;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper.Builder;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.financial.analytics.ircurve.strips.FRANode;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.time.Tenor;
+
+/**
+ * An instrument provider converter that does not perform conversions: to be used
+ * in cases where a mapping is not possible or desirable for a particular strip 
+ * instrument type, e.g. {@link StripInstrumentType#FRA}, where there is no
+ * information about the reset tenor, and so the {@link FRANode} cannot be created.
+ * 
+ * @author emcleod
+ */
+public class NoOpInstrumentProviderPopulator extends InstrumentProviderPopulator {
+  /** The logger */
+  private static final Logger s_logger = LoggerFactory.getLogger(NoOpInstrumentProviderPopulator.class);
+  /** The strip instrument type */
+  private final StripInstrumentType _type;
+
+  /**
+   * Sets the getter method name to null.
+   * @param type The strip instrument type, not null
+   */
+  public NoOpInstrumentProviderPopulator(final StripInstrumentType type) {
+    super(null);
+    ArgumentChecker.notNull(type, "type");
+    _type = type;
+  }
+
+  /**
+   * Returns an empty map.
+   * @param csbc The curve specification builder configuration, not used
+   * @return An empty map
+   */
+  @Override
+  public Map<Tenor, CurveInstrumentProvider> getInstrumentProviders(final CurveSpecificationBuilderConfiguration csbc) {
+    s_logger.error("Cannot convert strips of type {}", _type);
+    return Collections.emptyMap();
+  }
+
+  /**
+   * Creates a builder from the id mapper but does not populate any maps.
+   * @param idMapper The id mapper, not null
+   * @param instrumentProviders The instrument provider map, not null
+   * @param mapperName The new name for the mapper, not null
+   * @return A curve node id mapper builder with populated instrument provider maps.
+   */
+  @Override
+  public Builder createBuilder(final CurveNodeIdMapper idMapper, final Map<Tenor, CurveInstrumentProvider> instrumentProviders,
+      final String mapperName) {
+    return copyToBuilder(idMapper, mapperName);
+  }
+
+}
diff --git a/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/historical/historical-data.csv b/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/historical/historical-data.csv
index 67fe7dc..ee854ea 100644
--- a/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/historical/historical-data.csv
+++ b/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/historical/historical-data.csv
@@ -1361,11 +1361,44 @@ OG_SYNTHETIC_TICKER,AAPL 12/20/14 P414.0,IMPVOL_CLOSE,89
 OG_SYNTHETIC_TICKER,AAPL 12/20/14 P417.0,IMPVOL_CLOSE,99
 OG_SYNTHETIC_TICKER,AAPL 12/20/14 P420.0,IMPVOL_CLOSE,120
 #Government Bonds,,,
-OG_SYNTHETIC_TICKER,US0000000001,YIELD_CLOSE,1.2325
-OG_SYNTHETIC_TICKER,US0000000002,YIELD_CLOSE,1.1325
-OG_SYNTHETIC_TICKER,US0000000003,YIELD_CLOSE,1.445
-OG_SYNTHETIC_TICKER,US0000000004,YIELD_CLOSE,1.7375
-OG_SYNTHETIC_TICKER,US0000000005,YIELD_CLOSE,1.8425
-OG_SYNTHETIC_TICKER,US0000000006,YIELD_CLOSE,2.455
-OG_SYNTHETIC_TICKER,US0000000007,YIELD_CLOSE,2.89
-OG_SYNTHETIC_TICKER,US0000000008,YIELD_CLOSE,3.125
+OG_SYNTHETIC_TICKER,T 2 1/2 11/30/17,YIELD_CLOSE,1.2325
+OG_SYNTHETIC_TICKER,T 2 3/4 12/15/17,YIELD_CLOSE,1.1325
+OG_SYNTHETIC_TICKER,T 2 5/8 04/30/18,YIELD_CLOSE,1.445
+OG_SYNTHETIC_TICKER,T 2 3/4 02/15/19,YIELD_CLOSE,1.7375
+OG_SYNTHETIC_TICKER,T 3 3/8 11/15/19,YIELD_CLOSE,1.8425
+OG_SYNTHETIC_TICKER,T 3 1/8 15/05/21,YIELD_CLOSE,2.455
+OG_SYNTHETIC_TICKER,T 4 1/4 05/15/39,YIELD_CLOSE,2.89
+OG_SYNTHETIC_TICKER,T 3 7/8 08/15/40,YIELD_CLOSE,3.125
+OG_SYNTHETIC_TICKER,YIELD_CLOSE,0.05
+OG_SYNTHETIC_TICKER,USB000000012,YIELD_CLOSE,0.1
+OG_SYNTHETIC_TICKER,USB000000018,YIELD_CLOSE,0.26
+OG_SYNTHETIC_TICKER,UST000000002,YIELD_CLOSE,0.41
+OG_SYNTHETIC_TICKER,UST000000003,YIELD_CLOSE,0.86
+OG_SYNTHETIC_TICKER,UST000000004,YIELD_CLOSE,1.20
+OG_SYNTHETIC_TICKER,UST000000005,YIELD_CLOSE,1.66
+OG_SYNTHETIC_TICKER,UST000000006,YIELD_CLOSE,1.89
+OG_SYNTHETIC_TICKER,UST000000007,YIELD_CLOSE,2.21
+OG_SYNTHETIC_TICKER,UST000000008,YIELD_CLOSE,2.34
+OG_SYNTHETIC_TICKER,UST000000009,YIELD_CLOSE,2.47
+OG_SYNTHETIC_TICKER,UST000000010,YIELD_CLOSE,2.63
+OG_SYNTHETIC_TICKER,UST000000011,YIELD_CLOSE,2.67
+OG_SYNTHETIC_TICKER,UST000000012,YIELD_CLOSE,2.71
+OG_SYNTHETIC_TICKER,UST000000013,YIELD_CLOSE,2.75
+OG_SYNTHETIC_TICKER,UST000000014,YIELD_CLOSE,2.79
+OG_SYNTHETIC_TICKER,UST000000015,YIELD_CLOSE,2.81
+OG_SYNTHETIC_TICKER,UST000000016,YIELD_CLOSE,2.84
+OG_SYNTHETIC_TICKER,UST000000017,YIELD_CLOSE,2.94
+OG_SYNTHETIC_TICKER,UST000000018,YIELD_CLOSE,2.99
+OG_SYNTHETIC_TICKER,UST000000019,YIELD_CLOSE,3.06
+OG_SYNTHETIC_TICKER,UST000000020,YIELD_CLOSE,3.16
+OG_SYNTHETIC_TICKER,UST000000021,YIELD_CLOSE,3.17
+OG_SYNTHETIC_TICKER,UST000000022,YIELD_CLOSE,3.19
+OG_SYNTHETIC_TICKER,UST000000023,YIELD_CLOSE,3.21
+OG_SYNTHETIC_TICKER,UST000000024,YIELD_CLOSE,3.23
+OG_SYNTHETIC_TICKER,UST000000025,YIELD_CLOSE,3.26
+OG_SYNTHETIC_TICKER,UST000000026,YIELD_CLOSE,3.28
+OG_SYNTHETIC_TICKER,UST000000027,YIELD_CLOSE,3.31
+OG_SYNTHETIC_TICKER,UST000000028,YIELD_CLOSE,3.34
+OG_SYNTHETIC_TICKER,UST000000029,YIELD_CLOSE,3.37
+OG_SYNTHETIC_TICKER,UST000000030,YIELD_CLOSE,3.41
+OG_SYNTHETIC_TICKER,UST000000031,YIELD_CLOSE,3.42
diff --git a/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/livedata/market-data.csv b/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/livedata/market-data.csv
index 1a586db..bb25ad9 100644
--- a/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/livedata/market-data.csv
+++ b/examples/examples-simulated/src/main/resources/com/opengamma/examples/simulated/livedata/market-data.csv
@@ -2906,12 +2906,44 @@ AAPL 12/20/14 P414.0,LAST_IMPVOL,89
 AAPL 12/20/14 P417.0,LAST_IMPVOL,99
 AAPL 12/20/14 P420.0,LAST_IMPVOL,1
 #Government bonds,,
-US0000000001,LAST_YIELD,1.2325
-US0000000002,LAST_YIELD,1.1325
-US0000000003,LAST_YIELD,1.445
-US0000000004,LAST_YIELD,1.7375
-US0000000005,LAST_YIELD,1.8425
-US0000000006,LAST_YIELD,2.455
-US0000000007,LAST_YIELD,2.89
-US0000000008,LAST_YIELD,3.125
-
+T 2 1/2 11/30/17,LAST_YIELD,0.012325
+T 2 3/4 12/15/17,LAST_YIELD,0.011325
+T 2 5/8 04/30/18,LAST_YIELD,0.01445
+T 2 3/4 02/15/19,LAST_YIELD,0.017375
+T 3 3/8 11/15/19,LAST_YIELD,0.018425
+T 3 1/8 15/05/21,LAST_YIELD,0.02455
+T 4 1/4 05/15/39,LAST_YIELD,0.0289
+T 3 7/8 08/15/40,LAST_YIELD,0.03125
+USB000000006,LAST_YIELD,0.0005
+USB000000012,LAST_YIELD,0.001
+USB000000018,LAST_YIELD,0.0026
+UST000000002,LAST_YIELD,0.0041
+UST000000003,LAST_YIELD,0.0086
+UST000000004,LAST_YIELD,0.0120
+UST000000005,LAST_YIELD,0.0166
+UST000000006,LAST_YIELD,0.0189
+UST000000007,LAST_YIELD,0.0221
+UST000000008,LAST_YIELD,0.0234
+UST000000009,LAST_YIELD,0.0247
+UST000000010,LAST_YIELD,0.0263
+UST000000011,LAST_YIELD,0.0267
+UST000000012,LAST_YIELD,0.0271
+UST000000013,LAST_YIELD,0.0275
+UST000000014,LAST_YIELD,0.0279
+UST000000015,LAST_YIELD,0.0281
+UST000000016,LAST_YIELD,0.0284
+UST000000017,LAST_YIELD,0.0294
+UST000000018,LAST_YIELD,0.0299
+UST000000019,LAST_YIELD,0.0306
+UST000000020,LAST_YIELD,0.0316
+UST000000021,LAST_YIELD,0.0317
+UST000000022,LAST_YIELD,0.0319
+UST000000023,LAST_YIELD,0.0321
+UST000000024,LAST_YIELD,0.0323
+UST000000025,LAST_YIELD,0.0326
+UST000000026,LAST_YIELD,0.0328
+UST000000027,LAST_YIELD,0.0331
+UST000000028,LAST_YIELD,0.0334
+UST000000029,LAST_YIELD,0.0337
+UST000000030,LAST_YIELD,0.0341
+UST000000031,LAST_YIELD,0.0342
diff --git a/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/CollectionSecurityGeneratorTest.java b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/CollectionSecurityGeneratorTest.java
new file mode 100644
index 0000000..44ae0f9
--- /dev/null
+++ b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/CollectionSecurityGeneratorTest.java
@@ -0,0 +1,86 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import org.testng.annotations.Test;
+
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.master.security.RawSecurity;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * @author emcleod
+ * 
+ * Tests the {@link CollectionSecurityGenerator}.
+ */
+@Test(groups = TestGroup.UNIT)
+public class CollectionSecurityGeneratorTest {
+  /** An array of securities */
+  private static final ManageableSecurity[] SECURITIES;
+
+  static {
+    final int n = 10;
+    SECURITIES = new ManageableSecurity[n];
+    for (int i = 0; i < n; i++) {
+      final RawSecurity security = new RawSecurity();
+      security.setName(Integer.toString(i));
+      SECURITIES[i] = security;
+    }
+  }
+
+  /**
+   * Tests correct failure behaviour when the collection is null.
+   */
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void testNullCollection() {
+    new CollectionSecurityGenerator((List<ManageableSecurity>) null);
+  }
+
+  /**
+   * Tests correct failure behaviour when the array is null.
+   */
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void testNullArray() {
+    new CollectionSecurityGenerator<>((ManageableSecurity[]) null);
+  }
+
+  /**
+   * Tests correct failure behaviour when too many securities are requested.
+   */
+  @Test(expectedExceptions = IllegalStateException.class)
+  public void testTooManyRequested() {
+    final CollectionSecurityGenerator<ManageableSecurity> generator = new CollectionSecurityGenerator<>(SECURITIES);
+    for (int i = 0; i < SECURITIES.length + 1; i++) {
+      generator.createSecurity();
+    }
+  }
+
+  /**
+   * Tests the generated securities.
+   */
+  @Test
+  public void test() {
+    CollectionSecurityGenerator<ManageableSecurity> generator = new CollectionSecurityGenerator<>(SECURITIES);
+    for (final ManageableSecurity element : SECURITIES) {
+      assertEquals(element, generator.createSecurity());
+    }
+    generator = new CollectionSecurityGenerator<>(Arrays.asList(SECURITIES));
+    for (final ManageableSecurity element : SECURITIES) {
+      assertEquals(element, generator.createSecurity());
+    }
+    final Collection<ManageableSecurity> collection = new HashSet<>();
+    collection.addAll(Arrays.asList(SECURITIES));
+    generator = new CollectionSecurityGenerator<>(collection);
+    for (final ManageableSecurity security : collection) {
+      assertEquals(security, generator.createSecurity());
+    }
+  }
+}
diff --git a/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/SecuritiesGeneratorTest.java b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/SecuritiesGeneratorTest.java
new file mode 100644
index 0000000..f9829cd
--- /dev/null
+++ b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/generator/SecuritiesGeneratorTest.java
@@ -0,0 +1,96 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.generator;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertNull;
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.util.List;
+
+import org.testng.annotations.Test;
+
+import com.opengamma.financial.generator.SecurityGenerator;
+import com.opengamma.master.security.ManageableSecurity;
+import com.opengamma.master.security.RawSecurity;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * @author emcleod
+ *
+ * Tests {@link SecuritiesGenerator}.
+ */
+@Test(groups = TestGroup.UNIT)
+public class SecuritiesGeneratorTest {
+
+  /**
+   * Tests for failure in the case that the security generator is null.
+   */
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void testNullGenerator() {
+    new SecuritiesGenerator(null, 10);
+  }
+
+  /**
+   * Tests failure when too many securities are requested.
+   */
+  @Test(expectedExceptions = IllegalStateException.class)
+  public void testTooManySecurities() {
+    final int maxSecurities = 10;
+    final SecuritiesGenerator generator = new SecuritiesGenerator(new MySecurityGenerator(maxSecurities), maxSecurities + 10);
+    generator.createManageableSecurities();
+  }
+
+  /**
+   * Tests the list of generated securities.
+   */
+  @Test
+  public void testGeneratedSecuritiesList() {
+    final int maxSecurities = 10;
+    SecuritiesGenerator generator = new SecuritiesGenerator(new MySecurityGenerator(maxSecurities), 0);
+    List<ManageableSecurity> securities = generator.createManageableSecurities();
+    assertTrue(securities.isEmpty());
+    generator = new SecuritiesGenerator(new MySecurityGenerator(maxSecurities), maxSecurities);
+    securities = generator.createManageableSecurities();
+    assertEquals(10, securities.size());
+    int i = 0;
+    for (final ManageableSecurity security : securities) {
+      assertTrue(security instanceof RawSecurity);
+      final RawSecurity rawSecurity = (RawSecurity) security;
+      assertTrue(rawSecurity.getAttributes().isEmpty());
+      assertTrue(rawSecurity.getExternalIdBundle().isEmpty());
+      assertEquals(0, rawSecurity.getRawData().length);
+      assertNull(rawSecurity.getUniqueId());
+      assertEquals("SECURITY" + i++, rawSecurity.getName());
+    }
+  }
+
+  /**
+   * Testing class that creates a list of {@link RawSecurity} that only hold a name.
+   */
+  private static class MySecurityGenerator extends SecurityGenerator<RawSecurity> {
+    /** The maximum number of securities that can be created */
+    private final int _maxSecurities;
+    /** The count of securities that have been created */
+    private int _count;
+
+    /**
+     * @param maxSecurities The maximum number of securities
+     */
+    public MySecurityGenerator(final int maxSecurities) {
+      _maxSecurities = maxSecurities;
+    }
+
+    @Override
+    public RawSecurity createSecurity() {
+      if (_count > _maxSecurities) {
+        throw new IllegalStateException("Trying to create too many securities");
+      }
+      final RawSecurity security = new RawSecurity();
+      security.setName("SECURITY" + _count++);
+      return security;
+    }
+
+  }
+}
diff --git a/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverterTest.java b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverterTest.java
new file mode 100644
index 0000000..9696d60
--- /dev/null
+++ b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/CurveSpecificationBuilderConfigurationConverterTest.java
@@ -0,0 +1,590 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.Period;
+
+import com.google.common.collect.Iterables;
+import com.opengamma.examples.simulated.tool.converter.CurveSpecificationBuilderConfigurationConverter.ReflectionStripConverter;
+import com.opengamma.examples.simulated.tool.converter.csbc.BasisSwapInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.CashInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.DefaultCsbcRenamingFunction;
+import com.opengamma.examples.simulated.tool.converter.csbc.FraInstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.InstrumentProviderPopulator;
+import com.opengamma.examples.simulated.tool.converter.csbc.SwapInstrumentProviderPopulator;
+import com.opengamma.financial.analytics.curve.CurveNodeIdMapper;
+import com.opengamma.financial.analytics.ircurve.CurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.financial.analytics.ircurve.StripInstrumentType;
+import com.opengamma.financial.analytics.ircurve.SyntheticFutureCurveInstrumentProvider;
+import com.opengamma.financial.analytics.ircurve.SyntheticIdentifierCurveInstrumentProvider;
+import com.opengamma.id.ExternalScheme;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.Tenor;
+
+public class CurveSpecificationBuilderConfigurationConverterTest {
+  /** The scheme for the identifiers */
+  private static final String SCHEME = "Test";
+  /** Basis swaps instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> BASIS_SWAPS = new HashMap<>();
+  /** CDOR instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> CDORS = new HashMap<>();
+  /** CIBOR instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> CIBORS = new HashMap<>();
+  /** Continuous zero deposit instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> CONTINUOUS_ZERO_DEPOSITS = new HashMap<>();
+  /** Deposit instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> DEPOSITS = new HashMap<>();
+  /** Euribor instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> EURIBORS = new HashMap<>();
+  /** 3m FRA instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> FRA_3MS = new HashMap<>();
+  /** 6m FRA instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> FRA_6MS = new HashMap<>();
+  /** IR future instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> FUTURES = new HashMap<>();
+  /** LIBOR instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> LIBORS = new HashMap<>();
+  /** OIS swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> OIS_SWAPS = new HashMap<>();
+  /** Periodic zero deposit instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> PERIODIC_ZERO_DEPOSITS = new HashMap<>();
+  /** Simple zero deposit instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> SIMPLE_ZERO_DEPOSITS = new HashMap<>();
+  /** STIBOR instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> STIBORS = new HashMap<>();
+  /** 28d reset swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> SWAP_28DS = new HashMap<>();
+  /** 3m reset swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> SWAP_3MS = new HashMap<>();
+  /** 6m reset swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> SWAP_6MS = new HashMap<>();
+  /** 12m reset swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> SWAP_12MS = new HashMap<>();
+  /** Tenor swap instrument providers */
+  private static final Map<Tenor, CurveInstrumentProvider> TENOR_SWAPS = new HashMap<>();
+
+  static {
+    FUTURES.put(Tenor.of(Period.ZERO), new SyntheticFutureCurveInstrumentProvider("US"));
+    for (int i = 1; i < 31; i++) {
+      BASIS_SWAPS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.BASIS_SWAP, ExternalScheme.of(SCHEME)));
+      FRA_3MS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.FRA_3M, ExternalScheme.of(SCHEME)));
+      FRA_6MS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.FRA_6M, ExternalScheme.of(SCHEME)));
+      OIS_SWAPS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.OIS_SWAP, ExternalScheme.of(SCHEME)));
+      SWAP_28DS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.SWAP_28D, ExternalScheme.of(SCHEME)));
+      SWAP_3MS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.SWAP_3M, ExternalScheme.of(SCHEME)));
+      SWAP_6MS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.SWAP_6M, ExternalScheme.of(SCHEME)));
+      SWAP_12MS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.SWAP_12M, ExternalScheme.of(SCHEME)));
+      TENOR_SWAPS.put(Tenor.ofYears(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.TENOR_SWAP, ExternalScheme.of(SCHEME)));
+    }
+    for (int i = 1; i < 12; i++) {
+      CDORS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.CAD, StripInstrumentType.CDOR, ExternalScheme.of(SCHEME)));
+      CIBORS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.DKK, StripInstrumentType.CIBOR, ExternalScheme.of(SCHEME)));
+      CONTINUOUS_ZERO_DEPOSITS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.CONTINUOUS_ZERO_DEPOSIT, ExternalScheme.of(SCHEME)));
+      DEPOSITS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.CASH, ExternalScheme.of(SCHEME)));
+      EURIBORS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.EUR, StripInstrumentType.EURIBOR, ExternalScheme.of(SCHEME)));
+      LIBORS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.LIBOR, ExternalScheme.of(SCHEME)));
+      PERIODIC_ZERO_DEPOSITS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.PERIODIC_ZERO_DEPOSIT, ExternalScheme.of(SCHEME)));
+      SIMPLE_ZERO_DEPOSITS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.USD, StripInstrumentType.SIMPLE_ZERO_DEPOSIT, ExternalScheme.of(SCHEME)));
+      STIBORS.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.SEK, StripInstrumentType.STIBOR, ExternalScheme.of(SCHEME)));
+    }
+  }
+
+  @Test(expectedExceptions = RuntimeException.class)
+  public void testWrongSourceMethodNameForConverter() {
+    final Map<StripInstrumentType, InstrumentProviderPopulator> converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.CASH, new ReflectionStripConverter(StripInstrumentType.CASH, "getDepositInstrumentProviders", "cashNodeIds", new DefaultCsbcRenamingFunction()));
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+  }
+
+  @Test(expectedExceptions = RuntimeException.class)
+  public void testWrongDestinationMethodNameForConverter() {
+    final Map<StripInstrumentType, InstrumentProviderPopulator> converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.CASH, new ReflectionStripConverter(StripInstrumentType.CASH, "getCashInstrumentProviders", "depositNodeIds", new DefaultCsbcRenamingFunction()));
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+  }
+
+  @Test
+  public void testOverwritingCashNodes() {
+    final Map<StripInstrumentType, InstrumentProviderPopulator> converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.CASH, new CashInstrumentProviderPopulator(StripInstrumentType.CASH, "getCashInstrumentProviders"));
+    converters.put(StripInstrumentType.CASH, new CashInstrumentProviderPopulator(StripInstrumentType.CASH, "getLiborInstrumentProviders"));
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, null, null, LIBORS, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(LIBORS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testOverwritingFraNodes() {
+    final Map<StripInstrumentType, InstrumentProviderPopulator> converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.FRA_3M, new FraInstrumentProviderPopulator(StripInstrumentType.FRA_3M, "getFra3MInstrumentProviders"));
+    converters.put(StripInstrumentType.FRA_6M, new FraInstrumentProviderPopulator(StripInstrumentType.FRA_6M, "getFra6MInstrumentProviders"));
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, FRA_3MS, FRA_6MS, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .fraNodeIds(FRA_6MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testOverwritingSwapNodes() {
+    final String name = "DEFAULT";
+    final String expectedName = "DEFAULT USD";
+    Map<StripInstrumentType, InstrumentProviderPopulator> converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.SWAP_28D, new SwapInstrumentProviderPopulator(StripInstrumentType.SWAP_28D, "getSwap28DInstrumentProviders"));
+    converters.put(StripInstrumentType.SWAP_12M, new SwapInstrumentProviderPopulator(StripInstrumentType.SWAP_12M, "getSwap12MInstrumentProviders"));
+    CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, SWAP_12MS, SWAP_28DS);
+    Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+    CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(SWAP_28DS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+    converters = new EnumMap<>(StripInstrumentType.class);
+    converters.put(StripInstrumentType.BASIS_SWAP, new BasisSwapInstrumentProviderPopulator(StripInstrumentType.BASIS_SWAP));
+    converters.put(StripInstrumentType.TENOR_SWAP, new BasisSwapInstrumentProviderPopulator(StripInstrumentType.TENOR_SWAP));
+    originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, BASIS_SWAPS, TENOR_SWAPS, null, null, null, null, null, null);
+    newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig), converters);
+    expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(BASIS_SWAPS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testEmpty() {
+    final String name = "EMPTY";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertTrue(newConfigs.isEmpty());
+  }
+
+  @Test
+  public void testBasisSwaps() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, BASIS_SWAPS, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(BASIS_SWAPS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testCdor() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, CDORS, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("CAD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT CDOR CAD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(CDORS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+    newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testCibor() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, CIBORS, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("DKK", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT Cibor DKK";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(CIBORS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+    newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testContinuousZeroDeposits() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, CONTINUOUS_ZERO_DEPOSITS, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .continuouslyCompoundedRateNodeIds(CONTINUOUS_ZERO_DEPOSITS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testDeposits() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(DEPOSITS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testEuribor() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, EURIBORS, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("EUR", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT Euribor EUR";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(EURIBORS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+    newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testFra3m() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, FRA_3MS, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 3m USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .fraNodeIds(FRA_3MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testFuture() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        FUTURES, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .rateFutureNodeIds(FUTURES)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testFra6m() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, FRA_6MS, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 6m USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .fraNodeIds(FRA_6MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testLibor() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, EURIBORS, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, null);
+    Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("EUR", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT Euribor EUR";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .cashNodeIds(EURIBORS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+    newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testOIS() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, null, OIS_SWAPS, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(OIS_SWAPS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testPeriodicZeroDeposits() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, PERIODIC_ZERO_DEPOSITS, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .periodicallyCompoundedRateNodeIds(PERIODIC_ZERO_DEPOSITS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testSimpleZeroDeposits() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, SIMPLE_ZERO_DEPOSITS, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    assertTrue(newConfigs.isEmpty());
+  }
+
+  @Test
+  public void testSwap28d() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, null, SWAP_28DS);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 28d USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(SWAP_28DS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testSwap3m() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, SWAP_3MS, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 3m USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(SWAP_3MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testSwap6m() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, SWAP_6MS, null, null, null, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 6m USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(SWAP_6MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testSwap12m() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, null, null, null, null, null, SWAP_12MS, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT 12m USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(SWAP_12MS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  @Test
+  public void testTenorSwaps() {
+    final String name = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null, null, null,
+        null, null, null, null, TENOR_SWAPS, null, null, null, null, null, null);
+    final Collection<CurveNodeIdMapper> newConfigs = CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(name, originalConfig));
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder()
+        .name(expectedName)
+        .swapNodeIds(TENOR_SWAPS)
+        .build();
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  /**
+   * Tests conversion of a simple curve specification builder configuration containing only
+   * cash and OIS swap rates. In this case, the name should be appended with the currency
+   * and the id mapper should contain entries for cash and OIS.
+   */
+  @Test
+  public void testCashOISConfig() {
+    final String originalName = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, null, null, null, null,
+        null, null, null, null, null, null, null, null, OIS_SWAPS, null, null, null, null, null);
+    final String expectedName = "DEFAULT USD";
+    final CurveNodeIdMapper expectedConfig = CurveNodeIdMapper.builder().name(expectedName)
+        .cashNodeIds(DEPOSITS)
+        .swapNodeIds(OIS_SWAPS)
+        .build();
+    final Collection<CurveNodeIdMapper> newConfigs =
+        CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(originalName, originalConfig));
+    assertEquals(1, newConfigs.size());
+    assertEquals(expectedConfig, Iterables.getOnlyElement(newConfigs));
+  }
+
+  /**
+   * Tests conversion of a curve specification builder configuration with Euribor and
+   * EUR Libor rates. Two curve node id mappers, one with "Euribor" and the other with
+   * "Libor" appended to the name should be returned.
+   */
+  @Test
+  public void testEuriborLiborConfig() {
+    final String originalName = "DEFAULT";
+    final Map<Tenor, CurveInstrumentProvider> euribors = new HashMap<>();
+    final Map<Tenor, CurveInstrumentProvider> libors = new HashMap<>();
+    for (int i = 1; i < 12; i++) {
+      euribors.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.EUR, StripInstrumentType.EURIBOR, ExternalScheme.of(SCHEME)));
+      libors.put(Tenor.ofMonths(i), new SyntheticIdentifierCurveInstrumentProvider(Currency.EUR, StripInstrumentType.LIBOR, ExternalScheme.of(SCHEME)));
+    }
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, libors, euribors,
+        null, null, null, null, null, null, null, null, null, null, null, null, null, null);
+    final String expectedEuriborName = "DEFAULT Euribor EUR";
+    final String expectedLiborName = "DEFAULT Libor EUR";
+    final CurveNodeIdMapper expectedEuriborConfig = CurveNodeIdMapper.builder().name(expectedEuriborName)
+        .cashNodeIds(euribors)
+        .build();
+    final CurveNodeIdMapper expectedLiborConfig = CurveNodeIdMapper.builder().name(expectedLiborName)
+        .cashNodeIds(libors)
+        .build();
+    final Collection<CurveNodeIdMapper> newConfigs =
+        CurveSpecificationBuilderConfigurationConverter.convert("EUR", Collections.singletonMap(originalName, originalConfig));
+    assertEquals(2, newConfigs.size());
+    int count = 0;
+    for (final CurveNodeIdMapper config : newConfigs) {
+      if (config.getName().equals(expectedEuriborName)) {
+        assertEquals(expectedEuriborConfig, config);
+        count++;
+      } else if (config.getName().equals(expectedLiborName)) {
+        assertEquals(expectedLiborConfig, config);
+        count++;
+      }
+    }
+    assertEquals(2, count);
+  }
+
+  /**
+   * Tests conversion of a curve specification builder configuration with 28d, 3m, 6m and
+   * 12m strips. Four curve node id mappers of the form "{NAME} {PERIOD} {CURRENCY}" should
+   * be returned.
+   */
+  @Test
+  public void testSwapsConfig() {
+    final String originalName = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(null, null, null, null, null, null,
+        null, null, null, SWAP_6MS, SWAP_3MS, null, null, null, null, null, null, SWAP_12MS, SWAP_28DS);
+    final String expected28dName = "DEFAULT 28d USD";
+    final String expected3mName = "DEFAULT 3m USD";
+    final String expected6mName = "DEFAULT 6m USD";
+    final String expected12mName = "DEFAULT 12m USD";
+    final CurveNodeIdMapper expected28dConfig = CurveNodeIdMapper.builder().name(expected28dName)
+        .swapNodeIds(SWAP_28DS)
+        .build();
+    final CurveNodeIdMapper expected3mConfig = CurveNodeIdMapper.builder().name(expected3mName)
+        .swapNodeIds(SWAP_3MS)
+        .build();
+    final CurveNodeIdMapper expected6mConfig = CurveNodeIdMapper.builder().name(expected6mName)
+        .swapNodeIds(SWAP_6MS)
+        .build();
+    final CurveNodeIdMapper expected12mConfig = CurveNodeIdMapper.builder().name(expected12mName)
+        .swapNodeIds(SWAP_12MS)
+        .build();
+    final Collection<CurveNodeIdMapper> newConfigs =
+        CurveSpecificationBuilderConfigurationConverter.convert("USD", Collections.singletonMap(originalName, originalConfig));
+    assertEquals(4, newConfigs.size());
+    int count = 0;
+    for (final CurveNodeIdMapper config : newConfigs) {
+      if (config.getName().equals(expected28dName)) {
+        assertEquals(expected28dConfig, config);
+        count++;
+      } else if (config.getName().equals(expected3mName)) {
+        assertEquals(expected3mConfig, config);
+        count++;
+      } else if (config.getName().equals(expected6mName)) {
+        assertEquals(expected6mConfig, config);
+        count++;
+      } else if (config.getName().equals(expected12mName)) {
+        assertEquals(expected12mConfig, config);
+        count++;
+      }
+    }
+    assertEquals(4, count);
+  }
+
+  @Test
+  public void testTwoCurveSetup() {
+    final String originalName = "DEFAULT";
+    final CurveSpecificationBuilderConfiguration originalConfig = new CurveSpecificationBuilderConfiguration(DEPOSITS, FRA_3MS, null, LIBORS, null,
+        null, null, FUTURES, null, SWAP_6MS, null, null, OIS_SWAPS, null, null, null, null, null, null);
+  }
+}
diff --git a/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunctionTest.java b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunctionTest.java
new file mode 100644
index 0000000..b462506
--- /dev/null
+++ b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/DefaultCsbcRenamingFunctionTest.java
@@ -0,0 +1,57 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
+
+import org.testng.annotations.Test;
+
+import com.opengamma.examples.simulated.tool.converter.csbc.FixedCurrencyCsbcRenamingFunction;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.util.result.Function2;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * Tests a renaming function for {@link CurveSpecificationBuilderConfiguration} where
+ * the currency is fixed.
+ */
+@Test(groups = TestGroup.UNIT)
+public class DefaultCsbcRenamingFunctionTest {
+  /** The curve specification builder configuration name */
+  private static final String NAME = "DEFAULT";
+  /** The currency string */
+  private static final String CCY = "ABC";
+
+  /**
+   * Tests renaming without an intermediate string.
+   */
+  @Test
+  public static void testWithoutExtraInformation() {
+    final Function2<String, String, String> f = new FixedCurrencyCsbcRenamingFunction(CCY);
+    assertEquals(NAME + " " + CCY, f.apply(NAME, CCY));
+    Function2<String, String, String> other = new FixedCurrencyCsbcRenamingFunction(CCY);
+    assertEquals(f, other);
+    assertEquals(f.hashCode(), other.hashCode());
+    other = new FixedCurrencyCsbcRenamingFunction(CCY + "1");
+    assertFalse(f.equals(other));
+  }
+
+  /**
+   * Tests renaming with an intermediate string.
+   */
+  @Test
+  public static void testWithExtraInformation() {
+    final String s = "DEF";
+    final Function2<String, String, String> f = new FixedCurrencyCsbcRenamingFunction(CCY, s);
+    assertEquals(NAME + " " + s + " " + CCY, f.apply(NAME, CCY));
+    Function2<String, String, String> other = new FixedCurrencyCsbcRenamingFunction(CCY, s);
+    assertEquals(f, other);
+    assertEquals(f.hashCode(), other.hashCode());
+    other = new FixedCurrencyCsbcRenamingFunction(CCY, s + "1");
+    assertFalse(f.equals(other));
+    other = new FixedCurrencyCsbcRenamingFunction(CCY + "1", s);
+    assertFalse(f.equals(other));
+  }
+}
diff --git a/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunctionTest.java b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunctionTest.java
new file mode 100644
index 0000000..4a1ecea
--- /dev/null
+++ b/examples/examples-simulated/src/test/java/com/opengamma/examples/simulated/tool/converter/csbc/FixedCurrencyCsbcRenamingFunctionTest.java
@@ -0,0 +1,61 @@
+/**
+ * 
+ */
+package com.opengamma.examples.simulated.tool.converter.csbc;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
+
+import org.testng.annotations.Test;
+
+import com.opengamma.examples.simulated.tool.converter.csbc.DefaultCsbcRenamingFunction;
+import com.opengamma.examples.simulated.tool.converter.csbc.FixedCurrencyCsbcRenamingFunction;
+import com.opengamma.financial.analytics.ircurve.CurveSpecificationBuilderConfiguration;
+import com.opengamma.util.result.Function2;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * Tests the default renaming function for {@link CurveSpecificationBuilderConfiguration}.
+ */
+@Test(groups = TestGroup.UNIT)
+public class FixedCurrencyCsbcRenamingFunctionTest {
+  /** The curve specification builder configuration name */
+  private static final String NAME = "DEFAULT";
+  /** The currency string */
+  private static final String CCY = "ABC";
+
+  /**
+   * Tests that an {@link IllegalArgumentException} is thrown if the currency is null.
+   */
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void testNullCurrency() {
+    new FixedCurrencyCsbcRenamingFunction(null);
+  }
+
+  /**
+   * Tests renaming without an intermediate string.
+   */
+  @Test
+  public static void testWithoutExtraInformation() {
+    final Function2<String, String, String> f = new DefaultCsbcRenamingFunction();
+    assertEquals(NAME + " " + CCY, f.apply(NAME, CCY));
+    final Function2<String, String, String> other = new DefaultCsbcRenamingFunction();
+    assertEquals(f, other);
+    assertEquals(f.hashCode(), other.hashCode());
+  }
+
+  /**
+   * Tests renaming with an intermediate string.
+   */
+  @Test
+  public static void testWithExtraInformation() {
+    final String s = "DEF";
+    final Function2<String, String, String> f = new DefaultCsbcRenamingFunction(s);
+    assertEquals(NAME + " " + s + " " + CCY, f.apply(NAME, CCY));
+    Function2<String, String, String> other = new DefaultCsbcRenamingFunction(s);
+    assertEquals(f, other);
+    assertEquals(f.hashCode(), other.hashCode());
+    other = new DefaultCsbcRenamingFunction(s + "1");
+    assertFalse(f.equals(other));
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwap.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwap.java
deleted file mode 100644
index 0acd0db..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwap.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import org.apache.commons.lang.ObjectUtils;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
-import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
-import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
-import com.opengamma.analytics.financial.interestrate.swap.derivative.TotalReturnSwap;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.Currency;
-
-/**
- *
- */
-public class EquityTotalReturnSwap extends TotalReturnSwap {
-  /** The asset */
-  private final Equity _equity;
-  /** The notional amount */
-  private final double _notionalAmount;
-  /** The notional currency */
-  private final Currency _notionalCurrency;
-  /** The dividend percentage */
-  private final double _dividendPercentage;
-
-  /**
-   * @param fundingLeg The funding leg, not null
-   * @param equity The equity, not null
-   * @param notionalAmount The notional amount
-   * @param notionalCurrency The notional currency, not null
-   * @param dividendPercentage The dividend percentage received, >= 0 and <= 1
-   */
-  public EquityTotalReturnSwap(final Annuity<? extends Payment> fundingLeg, final Equity equity,
-      final double notionalAmount, final Currency notionalCurrency, final double dividendPercentage) {
-    super(fundingLeg);
-    ArgumentChecker.notNull(equity, "equity");
-    ArgumentChecker.notNull(notionalCurrency, "notionalCurrency");
-    ArgumentChecker.isTrue(ArgumentChecker.isInRangeInclusive(0, 1, dividendPercentage), "Dividend percentage must be >= 0 and <= 1 "
-        + "have {}", dividendPercentage);
-    _equity = equity;
-    _dividendPercentage = dividendPercentage;
-    _notionalAmount = notionalAmount;
-    _notionalCurrency = notionalCurrency;
-  }
-
-  /**
-   * Gets the equity.
-   * @return The equity
-   */
-
-  public Equity getEquity() {
-    return _equity;
-  }
-  /**
-   * Gets the dividend percentage.
-   * @return The dividend percentage
-   */
-  public double getDividendPercentage() {
-    return _dividendPercentage;
-  }
-
-  /**
-   * Gets the notional amount.
-   * @return The notional amount
-   */
-  public double getNotionalAmount() {
-    return _notionalAmount;
-  }
-
-  /**
-   * Gets the notional currency.
-   * @return The notional currency
-   */
-  public Currency getNotionalCurrency() {
-    return _notionalCurrency;
-  }
-
-  @Override
-  public <U, V> V accept(final InstrumentDerivativeVisitor<U, V> visitor, final U data) {
-    ArgumentChecker.notNull(visitor, "visitor");
-    return visitor.visitEquityTotalReturnSwap(this, data);
-  }
-
-  @Override
-  public <V> V accept(final InstrumentDerivativeVisitor<?, V> visitor) {
-    ArgumentChecker.notNull(visitor, "visitor");
-    return visitor.visitEquityTotalReturnSwap(this);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    long temp;
-    temp = Double.doubleToLongBits(_dividendPercentage);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(_notionalAmount);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    result = prime * result + _notionalCurrency.hashCode();
-    result = prime * result + _equity.hashCode();
-    return result;
-  }
-
-  @Override
-  public boolean equals(final Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (!super.equals(obj)) {
-      return false;
-    }
-    if (!(obj instanceof EquityTotalReturnSwap)) {
-      return false;
-    }
-    final EquityTotalReturnSwap other = (EquityTotalReturnSwap) obj;
-    if (!ObjectUtils.equals(_equity, other._equity)) {
-      return false;
-    }
-    if (Double.compare(_notionalAmount, other._notionalAmount) != 0) {
-      return false;
-    }
-    if (!ObjectUtils.equals(_notionalCurrency, other._notionalCurrency)) {
-      return false;
-    }
-    if (Double.compare(_dividendPercentage, other._dividendPercentage) != 0) {
-      return false;
-    }
-    return true;
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwapDefinition.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwapDefinition.java
deleted file mode 100644
index 0e7f65d..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EquityTotalReturnSwapDefinition.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import org.apache.commons.lang.ObjectUtils;
-import org.threeten.bp.ZonedDateTime;
-
-import com.opengamma.analytics.financial.instrument.InstrumentDefinitionVisitor;
-import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
-import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
-import com.opengamma.analytics.financial.instrument.swap.TotalReturnSwapDefinition;
-import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
-import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
-import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.Currency;
-
-/**
- *
- */
-public class EquityTotalReturnSwapDefinition extends TotalReturnSwapDefinition {
-  /** The notional amount */
-  private final double _notionalAmount;
-  /** The notional currency */
-  private final Currency _notionalCurrency;
-  /** The dividend percentage */
-  private final double _dividendPercentage;
-
-  /**
-   * @param fundingLeg The funding leg, not null
-   * @param equity The equity, not null
-   * @param notionalAmount The notional amount
-   * @param notionalCurrency The notional currency, not null
-   * @param dividendPercentage The dividend percentage received, >= 0 and <= 1
-   */
-  public EquityTotalReturnSwapDefinition(final AnnuityDefinition<? extends PaymentDefinition> fundingLeg, final EquityDefinition equity,
-      final double notionalAmount, final Currency notionalCurrency, final double dividendPercentage) {
-    super(fundingLeg, equity);
-    ArgumentChecker.notNull(notionalCurrency, "notionalCurrency");
-    ArgumentChecker.isTrue(ArgumentChecker.isInRangeInclusive(0, 1, dividendPercentage), "Dividend percentage must be >= 0 and <= 1 "
-        + "have {}", dividendPercentage);
-    _dividendPercentage = dividendPercentage;
-    _notionalAmount = notionalAmount;
-    _notionalCurrency = notionalCurrency;
-  }
-
-  /**
-   * Gets the dividend percentage.
-   * @return The dividend percentage
-   */
-  public double getDividendPercentage() {
-    return _dividendPercentage;
-  }
-
-  /**
-   * Gets the notional amount.
-   * @return The notional amount
-   */
-  public double getNotionalAmount() {
-    return _notionalAmount;
-  }
-
-  /**
-   * Gets the notional currency.
-   * @return The notional currency
-   */
-  public Currency getNotionalCurrency() {
-    return _notionalCurrency;
-  }
-
-  @Override
-  public <U, V> V accept(final InstrumentDefinitionVisitor<U, V> visitor, final U data) {
-    ArgumentChecker.notNull(visitor, "visitor");
-    return visitor.visitEquityTotalReturnSwapDefinition(this, data);
-  }
-
-  @Override
-  public <V> V accept(final InstrumentDefinitionVisitor<?, V> visitor) {
-    ArgumentChecker.notNull(visitor, "visitor");
-    return visitor.visitEquityTotalReturnSwapDefinition(this);
-  }
-
-  @Override
-  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final ZonedDateTimeDoubleTimeSeries data, final String... yieldCurveNames) {
-    return toDerivative(date, data);
-  }
-
-  @Override
-  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final ZonedDateTimeDoubleTimeSeries data) {
-    final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date, data);
-    final Equity equity = (Equity) getAsset().toDerivative(date);
-    return new EquityTotalReturnSwap(fundingLeg, equity, _notionalAmount, _notionalCurrency, _dividendPercentage);
-  }
-
-  @Override
-  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final String... yieldCurveNames) {
-    return toDerivative(date);
-  }
-
-  @Override
-  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date) {
-    final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date);
-    final Equity equity = (Equity) getAsset().toDerivative(date);
-    return new EquityTotalReturnSwap(fundingLeg, equity, _notionalAmount, _notionalCurrency, _dividendPercentage);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    long temp;
-    temp = Double.doubleToLongBits(_dividendPercentage);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(_notionalAmount);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    result = prime * result + _notionalCurrency.hashCode();
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public boolean equals(final Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (!super.equals(obj)) {
-      return false;
-    }
-    if (!(obj instanceof EquityTotalReturnSwapDefinition)) {
-      return false;
-    }
-    final EquityTotalReturnSwapDefinition other = (EquityTotalReturnSwapDefinition) obj;
-    if (Double.compare(_notionalAmount, other._notionalAmount) != 0) {
-      return false;
-    }
-    if (!ObjectUtils.equals(_notionalCurrency, other._notionalCurrency)) {
-      return false;
-    }
-    if (Double.compare(_dividendPercentage, other._dividendPercentage) != 0) {
-      return false;
-    }
-    return true;
-  }
-
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsAssetLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsAssetLegPresentValueCalculator.java
deleted file mode 100644
index 57f1d64..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsAssetLegPresentValueCalculator.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.CurrencyAmount;
-import com.opengamma.util.money.MultipleCurrencyAmount;
-
-/**
- * Calculates the present value of the asset leg of an equity total return swap.
- */
-public final class EqyTrsAssetLegPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
-  /** The singleton instance */
-  private static final EqyTrsAssetLegPresentValueCalculator INSTANCE = new EqyTrsAssetLegPresentValueCalculator();
-
-  /**
-   * Gets the instance.
-   * @return The instance
-   */
-  public static EqyTrsAssetLegPresentValueCalculator getInstance() {
-    return INSTANCE;
-  }
-
-  /**
-   * Private constructor.
-   */
-  private EqyTrsAssetLegPresentValueCalculator() {
-  }
-
-  @Override
-  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
-    ArgumentChecker.notNull(equityTrs, "equityTrs");
-    ArgumentChecker.notNull(data, "data");
-    return MultipleCurrencyAmount.of(CurrencyAmount.of(equityTrs.getNotionalCurrency(), data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares()));
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsFundingLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsFundingLegPresentValueCalculator.java
deleted file mode 100644
index 2fe56f9..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsFundingLegPresentValueCalculator.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
-import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.MultipleCurrencyAmount;
-
-/**
- * Calculates the present value of the funding leg of an equity total return swap.
- */
-public final class EqyTrsFundingLegPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
-  /** The singleton instance */
-  private static final EqyTrsFundingLegPresentValueCalculator INSTANCE = new EqyTrsFundingLegPresentValueCalculator();
-
-  /**
-   * Gets the instance.
-   * @return The instance
-   */
-  public static EqyTrsFundingLegPresentValueCalculator getInstance() {
-    return INSTANCE;
-  }
-
-  /**
-   * Private constructor.
-   */
-  private EqyTrsFundingLegPresentValueCalculator() {
-  }
-
-  @Override
-  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
-    ArgumentChecker.notNull(equityTrs, "equityTrs");
-    ArgumentChecker.notNull(data, "data");
-    return equityTrs.getFundingLeg().accept(PresentValueDiscountingCalculator.getInstance(), data.getCurves());
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsGammaPV01Calculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsGammaPV01Calculator.java
deleted file mode 100644
index 840f82e..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsGammaPV01Calculator.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
-import com.opengamma.analytics.financial.provider.calculator.discounting.GammaPV01CurveParametersCalculator;
-import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueCurveSensitivityDiscountingCalculator;
-import com.opengamma.analytics.financial.provider.description.interestrate.MulticurveProviderInterface;
-import com.opengamma.util.ArgumentChecker;
-
-/**
- * Calculates the gamma PV01 of an equity total return swap.
- */
-public final class EqyTrsGammaPV01Calculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, Double> {
-  /** The singleton instance */
-  private static final EqyTrsGammaPV01Calculator INSTANCE = new EqyTrsGammaPV01Calculator();
-  /** The gamma PV01 calculator */
-  private static final GammaPV01CurveParametersCalculator<MulticurveProviderInterface> CALCULATOR =
-      new GammaPV01CurveParametersCalculator<>(PresentValueCurveSensitivityDiscountingCalculator.getInstance());
-
-  /**
-   * Gets the instance.
-   * @return The instance
-   */
-  public static EqyTrsGammaPV01Calculator getInstance() {
-    return INSTANCE;
-  }
-
-  /**
-   * Private constructor.
-   */
-  private EqyTrsGammaPV01Calculator() {
-  }
-
-  @Override
-  public Double visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
-    ArgumentChecker.notNull(equityTrs, "equityTrs");
-    ArgumentChecker.notNull(data, "data");
-    return equityTrs.getFundingLeg().accept(CALCULATOR, data.getCurves());
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsPresentValueCalculator.java
deleted file mode 100644
index efee10c..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsPresentValueCalculator.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
-import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.Currency;
-import com.opengamma.util.money.CurrencyAmount;
-import com.opengamma.util.money.MultipleCurrencyAmount;
-
-/**
- * Calculates the present value of an equity total return swap.
- */
-public final class EqyTrsPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
-  /** The singleton instance */
-  private static final EqyTrsPresentValueCalculator INSTANCE = new EqyTrsPresentValueCalculator();
-
-  /**
-   * Gets the instance.
-   * @return The instance
-   */
-  public static EqyTrsPresentValueCalculator getInstance() {
-    return INSTANCE;
-  }
-
-  /**
-   * Private constructor.
-   */
-  private EqyTrsPresentValueCalculator() {
-  }
-
-  @Override
-  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
-    ArgumentChecker.notNull(equityTrs, "equityTrs");
-    ArgumentChecker.notNull(data, "data");
-    final MultipleCurrencyAmount fundingLegPV = equityTrs.getFundingLeg().accept(PresentValueDiscountingCalculator.getInstance(), data.getCurves());
-    final Currency fundingCurrency = equityTrs.getFundingLeg().getCurrency();
-    final CurrencyAmount equityPV = CurrencyAmount.of(equityTrs.getNotionalCurrency(), data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares());
-    final Currency equityCurrency = equityTrs.getEquity().getCurrency();
-    final double fxRate = data.getCurves().getFxRate(equityCurrency, fundingCurrency);
-    return MultipleCurrencyAmount.of(equityPV.plus(CurrencyAmount.of(equityCurrency, -fundingLegPV.getAmount(fundingCurrency) * fxRate)));
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsValueDeltaCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsValueDeltaCalculator.java
deleted file mode 100644
index d16e4b6..0000000
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/EqyTrsValueDeltaCalculator.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.analytics.financial.equity;
-
-import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
-import com.opengamma.util.ArgumentChecker;
-import com.opengamma.util.money.CurrencyAmount;
-import com.opengamma.util.money.MultipleCurrencyAmount;
-
-/**
- * Calculates the value delta (i.e. delta w.r.t the equity) of an equity total return swap.
- */
-public final class EqyTrsValueDeltaCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
-  /** The singleton instance */
-  private static final EqyTrsValueDeltaCalculator INSTANCE = new EqyTrsValueDeltaCalculator();
-
-  /**
-   * Gets the instance.
-   * @return The instance
-   */
-  public static EqyTrsValueDeltaCalculator getInstance() {
-    return INSTANCE;
-  }
-
-  /**
-   * Private constructor.
-   */
-  private EqyTrsValueDeltaCalculator() {
-  }
-
-  @Override
-  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
-    ArgumentChecker.notNull(equityTrs, "equityTrs");
-    ArgumentChecker.notNull(data, "data");
-    final CurrencyAmount equityValueDelta = CurrencyAmount.of(equityTrs.getNotionalCurrency(), -(data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares()));
-    return MultipleCurrencyAmount.of(equityValueDelta);
-  }
-}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwap.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwap.java
new file mode 100644
index 0000000..ebded7c
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwap.java
@@ -0,0 +1,139 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import org.apache.commons.lang.ObjectUtils;
+
+import com.opengamma.analytics.financial.equity.Equity;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.financial.interestrate.swap.derivative.TotalReturnSwap;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.Currency;
+
+/**
+ * Description of an equity total return swap.
+ */
+public class EquityTotalReturnSwap extends TotalReturnSwap {
+  /** The asset */
+  private final Equity _equity;
+  /** The notional amount */
+  private final double _notionalAmount;
+  /** The notional currency */
+  private final Currency _notionalCurrency;
+  /** The dividend paid by the asset leg payer as a ratio of the original dividend. ratio >= 0 and <= 1. */
+  private final double _dividendRatio;
+
+  /**
+   * @param effectiveTime The time to the effective date.
+   * @param terminatioTime The time to the termination date.
+   * @param fundingLeg The funding leg, not null
+   * @param equity The equity, not null
+   * @param notionalAmount The notional amount
+   * @param notionalCurrency The notional currency, not null
+   * @param dividendRatio The dividend paid by the asset leg payer as a ratio of the original dividend. ratio >= 0 and <= 1.
+   */
+  public EquityTotalReturnSwap(final double effectiveTime, final double terminatioTime,
+      final Annuity<? extends Payment> fundingLeg, final Equity equity,
+      final double notionalAmount, final Currency notionalCurrency, final double dividendRatio) {
+    super(effectiveTime, terminatioTime, fundingLeg);
+    ArgumentChecker.notNull(equity, "equity");
+    ArgumentChecker.notNull(notionalCurrency, "notionalCurrency");
+    ArgumentChecker.isTrue(ArgumentChecker.isInRangeInclusive(0, 1, dividendRatio), "Dividend ratio must be >= 0 and <= 1 "
+        + "have {}", dividendRatio);
+    _equity = equity;
+    _dividendRatio = dividendRatio;
+    _notionalAmount = notionalAmount;
+    _notionalCurrency = notionalCurrency;
+  }
+
+  /**
+   * Gets the equity.
+   * @return The equity
+   */
+
+  public Equity getEquity() {
+    return _equity;
+  }
+
+  /**
+   * Gets the dividend percentage.
+   * @return The dividend percentage
+   */
+  public double getDividendPercentage() {
+    return _dividendRatio;
+  }
+
+  /**
+   * Gets the notional amount.
+   * @return The notional amount
+   */
+  public double getNotionalAmount() {
+    return _notionalAmount;
+  }
+
+  /**
+   * Gets the notional currency.
+   * @return The notional currency
+   */
+  public Currency getNotionalCurrency() {
+    return _notionalCurrency;
+  }
+
+  @Override
+  public <U, V> V accept(final InstrumentDerivativeVisitor<U, V> visitor, final U data) {
+    ArgumentChecker.notNull(visitor, "visitor");
+    return visitor.visitEquityTotalReturnSwap(this, data);
+  }
+
+  @Override
+  public <V> V accept(final InstrumentDerivativeVisitor<?, V> visitor) {
+    ArgumentChecker.notNull(visitor, "visitor");
+    return visitor.visitEquityTotalReturnSwap(this);
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(_dividendRatio);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(_notionalAmount);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + _notionalCurrency.hashCode();
+    result = prime * result + _equity.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!super.equals(obj)) {
+      return false;
+    }
+    if (!(obj instanceof EquityTotalReturnSwap)) {
+      return false;
+    }
+    final EquityTotalReturnSwap other = (EquityTotalReturnSwap) obj;
+    if (!ObjectUtils.equals(_equity, other._equity)) {
+      return false;
+    }
+    if (Double.compare(_notionalAmount, other._notionalAmount) != 0) {
+      return false;
+    }
+    if (!ObjectUtils.equals(_notionalCurrency, other._notionalCurrency)) {
+      return false;
+    }
+    if (Double.compare(_dividendRatio, other._dividendRatio) != 0) {
+      return false;
+    }
+    return true;
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinition.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinition.java
new file mode 100644
index 0000000..4cbb535
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinition.java
@@ -0,0 +1,159 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import org.apache.commons.lang.ObjectUtils;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.analytics.financial.equity.Equity;
+import com.opengamma.analytics.financial.equity.EquityDefinition;
+import com.opengamma.analytics.financial.instrument.InstrumentDefinitionVisitor;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.instrument.swap.TotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.Currency;
+
+/**
+ * Description of an equity total return swap.
+ */
+public class EquityTotalReturnSwapDefinition extends TotalReturnSwapDefinition {
+
+  /** The notional amount */
+  private final double _notionalAmount;
+  /** The notional currency */
+  private final Currency _notionalCurrency;
+  /** The dividend percentage */
+  private final double _dividendPercentage;
+
+  /**
+   * @param effectiveDate The effective date.
+   * @param terminationDate The termination date.
+   * @param fundingLeg The funding leg, not null
+   * @param equity The equity, not null
+   * @param notionalAmount The notional amount
+   * @param notionalCurrency The notional currency, not null
+   * @param dividendPercentage The dividend percentage received, >= 0 and <= 1
+   */
+  public EquityTotalReturnSwapDefinition(final ZonedDateTime effectiveDate, final ZonedDateTime terminationDate,
+      final AnnuityDefinition<? extends PaymentDefinition> fundingLeg, final EquityDefinition equity,
+      final double notionalAmount, final Currency notionalCurrency, final double dividendPercentage) {
+    super(effectiveDate, terminationDate, fundingLeg, equity);
+    ArgumentChecker.notNull(notionalCurrency, "notionalCurrency");
+    ArgumentChecker.isTrue(ArgumentChecker.isInRangeInclusive(0, 1, dividendPercentage), "Dividend percentage must be >= 0 and <= 1 "
+        + "have {}", dividendPercentage);
+    _dividendPercentage = dividendPercentage;
+    _notionalAmount = notionalAmount;
+    _notionalCurrency = notionalCurrency;
+  }
+
+  /**
+   * Gets the dividend percentage.
+   * @return The dividend percentage
+   */
+  public double getDividendPercentage() {
+    return _dividendPercentage;
+  }
+
+  /**
+   * Gets the notional amount.
+   * @return The notional amount
+   */
+  public double getNotionalAmount() {
+    return _notionalAmount;
+  }
+
+  /**
+   * Gets the notional currency.
+   * @return The notional currency
+   */
+  public Currency getNotionalCurrency() {
+    return _notionalCurrency;
+  }
+
+  @Override
+  public <U, V> V accept(final InstrumentDefinitionVisitor<U, V> visitor, final U data) {
+    ArgumentChecker.notNull(visitor, "visitor");
+    return visitor.visitEquityTotalReturnSwapDefinition(this, data);
+  }
+
+  @Override
+  public <V> V accept(final InstrumentDefinitionVisitor<?, V> visitor) {
+    ArgumentChecker.notNull(visitor, "visitor");
+    return visitor.visitEquityTotalReturnSwapDefinition(this);
+  }
+
+  @Override
+  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final ZonedDateTimeDoubleTimeSeries data, final String... yieldCurveNames) {
+    return toDerivative(date, data);
+  }
+
+  @Override
+  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final ZonedDateTimeDoubleTimeSeries data) {
+    final double effectiveTime = TimeCalculator.getTimeBetween(date, getEffectiveDate());
+    final double terminationTime = TimeCalculator.getTimeBetween(date, getTerminationDate());
+    final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date, data);
+    final Equity equity = (Equity) getAsset().toDerivative(date);
+    return new EquityTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, equity, _notionalAmount, _notionalCurrency, _dividendPercentage);
+  }
+
+  @Override
+  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date, final String... yieldCurveNames) {
+    return toDerivative(date);
+  }
+
+  @Override
+  public EquityTotalReturnSwap toDerivative(final ZonedDateTime date) {
+    final double effectiveTime = TimeCalculator.getTimeBetween(date, getEffectiveDate());
+    final double terminationTime = TimeCalculator.getTimeBetween(date, getTerminationDate());
+    final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date);
+    final Equity equity = (Equity) getAsset().toDerivative(date);
+    return new EquityTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, equity, _notionalAmount, _notionalCurrency, _dividendPercentage);
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(_dividendPercentage);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(_notionalAmount);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + _notionalCurrency.hashCode();
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public boolean equals(final Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (!super.equals(obj)) {
+      return false;
+    }
+    if (!(obj instanceof EquityTotalReturnSwapDefinition)) {
+      return false;
+    }
+    final EquityTotalReturnSwapDefinition other = (EquityTotalReturnSwapDefinition) obj;
+    if (Double.compare(_notionalAmount, other._notionalAmount) != 0) {
+      return false;
+    }
+    if (!ObjectUtils.equals(_notionalCurrency, other._notionalCurrency)) {
+      return false;
+    }
+    if (Double.compare(_dividendPercentage, other._dividendPercentage) != 0) {
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethod.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethod.java
new file mode 100644
index 0000000..d90943c
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethod.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueCurveSensitivityDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyMulticurveSensitivity;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Class with pricing methods related to equity TRS valued by discounting.
+ */
+public final class EquityTotalReturnSwapDiscountingMethod {
+
+  /**
+   * The unique instance of the class.
+   */
+  private static final EquityTotalReturnSwapDiscountingMethod INSTANCE = new EquityTotalReturnSwapDiscountingMethod();
+
+  /**
+   * Return the class instance.
+   * @return The instance.
+   */
+  public static EquityTotalReturnSwapDiscountingMethod getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Constructor
+   */
+  private EquityTotalReturnSwapDiscountingMethod() {
+  }
+
+  /** The present value and present value curve sensitivity calculators used for bonds calculation */
+  private static final PresentValueDiscountingCalculator PVDC = PresentValueDiscountingCalculator.getInstance();
+  private static final PresentValueCurveSensitivityDiscountingCalculator PVCSDC = PresentValueCurveSensitivityDiscountingCalculator.getInstance();
+
+  /**
+   * Computes the present value of a equity TRS.
+   * The present value of the equity leg is equal to the equity price multiply the the number of shares in the currency of the shares.
+   * @param trs The equity total return swap.
+   * @param equityMulticurves The multi-curves provider with equity price.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValue(final EquityTotalReturnSwap trs, final EquityTrsDataBundle equityMulticurves) {
+    ArgumentChecker.notNull(trs, "equity TRS");
+    ArgumentChecker.notNull(equityMulticurves, "multi-curve provider with equity price");
+    final MultipleCurrencyAmount fundingLegPV = trs.getFundingLeg().accept(PVDC, equityMulticurves.getCurves());
+    final MultipleCurrencyAmount equityPV = MultipleCurrencyAmount.of(trs.getEquity().getCurrency(),
+        equityMulticurves.getSpotEquity() * trs.getEquity().getNumberOfShares());
+    return equityPV.plus(fundingLegPV);
+  }
+
+  /**
+   * Computes the present value of the asset leg of a equity TRS. 
+   * The present value is equal to the equity price multiply the the number of shares in the currency of the shares.
+   * @param trs The equity total return swap.
+   * @param equityMulticurves The multi-curves provider with equity price.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValueAssetLeg(final EquityTotalReturnSwap trs, final EquityTrsDataBundle equityMulticurves) {
+    ArgumentChecker.notNull(trs, "equity TRS");
+    ArgumentChecker.notNull(equityMulticurves, "multi-curve provider with equity price");
+    final MultipleCurrencyAmount equityPV = MultipleCurrencyAmount.of(trs.getEquity().getCurrency(),
+        equityMulticurves.getSpotEquity() * trs.getEquity().getNumberOfShares());
+    return equityPV;
+  }
+
+  /**
+   * Computes the present value of the funding leg of a equity TRS.
+   * @param trs The equity total return swap.
+   * @param equityMulticurves The multi-curves provider with equity price.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValueFundingLeg(final EquityTotalReturnSwap trs, final EquityTrsDataBundle equityMulticurves) {
+    ArgumentChecker.notNull(trs, "equity TRS");
+    ArgumentChecker.notNull(equityMulticurves, "multi-curve provider with equity price");
+    final MultipleCurrencyAmount fundingLegPV = trs.getFundingLeg().accept(PVDC, equityMulticurves.getCurves());
+    return fundingLegPV;
+  }
+
+  /**
+   * Computes the present value curve sensitivity of a equity TRS. 
+   * The sensitivity to the (issuer) curves used in the bond valuation and the sensitivity to the curves used in the funding leg valuation are computed.
+   * @param trs The equity total return swap.
+   * @param equityMulticurves The multi-curves provider with equity price.
+   * @return The present value.
+   */
+  public MultipleCurrencyMulticurveSensitivity presentValueCurveSensitivity(final EquityTotalReturnSwap trs, final EquityTrsDataBundle equityMulticurves) {
+    ArgumentChecker.notNull(trs, "equity TRS");
+    ArgumentChecker.notNull(equityMulticurves, "multi-curve provider with equity price");
+    MultipleCurrencyMulticurveSensitivity fundingLegCS = trs.getFundingLeg().accept(PVCSDC, equityMulticurves.getCurves());
+    return fundingLegCS;
+  }
+
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsAssetLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsAssetLegPresentValueCalculator.java
new file mode 100644
index 0000000..0c777cb
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsAssetLegPresentValueCalculator.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.CurrencyAmount;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Calculates the present value of the asset leg of an equity total return swap.
+ */
+public final class EqyTrsAssetLegPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
+  /** The singleton instance */
+  private static final EqyTrsAssetLegPresentValueCalculator INSTANCE = new EqyTrsAssetLegPresentValueCalculator();
+
+  /**
+   * Gets the instance.
+   * @return The instance
+   */
+  public static EqyTrsAssetLegPresentValueCalculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Private constructor.
+   */
+  private EqyTrsAssetLegPresentValueCalculator() {
+  }
+
+  @Override
+  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
+    ArgumentChecker.notNull(equityTrs, "equityTrs");
+    ArgumentChecker.notNull(data, "data");
+    return MultipleCurrencyAmount.of(CurrencyAmount.of(equityTrs.getNotionalCurrency(), data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares()));
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsFundingLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsFundingLegPresentValueCalculator.java
new file mode 100644
index 0000000..1a6e751
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsFundingLegPresentValueCalculator.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Calculates the present value of the funding leg of an equity total return swap.
+ */
+public final class EqyTrsFundingLegPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
+  /** The singleton instance */
+  private static final EqyTrsFundingLegPresentValueCalculator INSTANCE = new EqyTrsFundingLegPresentValueCalculator();
+
+  /**
+   * Gets the instance.
+   * @return The instance
+   */
+  public static EqyTrsFundingLegPresentValueCalculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Private constructor.
+   */
+  private EqyTrsFundingLegPresentValueCalculator() {
+  }
+
+  @Override
+  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
+    ArgumentChecker.notNull(equityTrs, "equityTrs");
+    ArgumentChecker.notNull(data, "data");
+    return equityTrs.getFundingLeg().accept(PresentValueDiscountingCalculator.getInstance(), data.getCurves());
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsGammaPV01Calculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsGammaPV01Calculator.java
new file mode 100644
index 0000000..8b010cb
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsGammaPV01Calculator.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
+import com.opengamma.analytics.financial.provider.calculator.discounting.GammaPV01CurveParametersCalculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueCurveSensitivityDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.description.interestrate.MulticurveProviderInterface;
+import com.opengamma.util.ArgumentChecker;
+
+/**
+ * Calculates the gamma PV01 of an equity total return swap.
+ */
+public final class EqyTrsGammaPV01Calculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, Double> {
+  /** The singleton instance */
+  private static final EqyTrsGammaPV01Calculator INSTANCE = new EqyTrsGammaPV01Calculator();
+  /** The gamma PV01 calculator */
+  private static final GammaPV01CurveParametersCalculator<MulticurveProviderInterface> CALCULATOR =
+      new GammaPV01CurveParametersCalculator<>(PresentValueCurveSensitivityDiscountingCalculator.getInstance());
+
+  /**
+   * Gets the instance.
+   * @return The instance
+   */
+  public static EqyTrsGammaPV01Calculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Private constructor.
+   */
+  private EqyTrsGammaPV01Calculator() {
+  }
+
+  @Override
+  public Double visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
+    ArgumentChecker.notNull(equityTrs, "equityTrs");
+    ArgumentChecker.notNull(data, "data");
+    return equityTrs.getFundingLeg().accept(CALCULATOR, data.getCurves());
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsPresentValueCalculator.java
new file mode 100644
index 0000000..9d05149
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsPresentValueCalculator.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.money.CurrencyAmount;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Calculates the present value of an equity total return swap.
+ */
+public final class EqyTrsPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
+  /** The singleton instance */
+  private static final EqyTrsPresentValueCalculator INSTANCE = new EqyTrsPresentValueCalculator();
+
+  /**
+   * Gets the instance.
+   * @return The instance
+   */
+  public static EqyTrsPresentValueCalculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Private constructor.
+   */
+  private EqyTrsPresentValueCalculator() {
+  }
+
+  @Override
+  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
+    ArgumentChecker.notNull(equityTrs, "equityTrs");
+    ArgumentChecker.notNull(data, "data");
+    final MultipleCurrencyAmount fundingLegPV = equityTrs.getFundingLeg().accept(PresentValueDiscountingCalculator.getInstance(), data.getCurves());
+    final Currency fundingCurrency = equityTrs.getFundingLeg().getCurrency();
+    final CurrencyAmount equityPV = CurrencyAmount.of(equityTrs.getNotionalCurrency(), data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares());
+    final Currency equityCurrency = equityTrs.getEquity().getCurrency();
+    final double fxRate = data.getCurves().getFxRate(equityCurrency, fundingCurrency);
+    return MultipleCurrencyAmount.of(equityPV.plus(CurrencyAmount.of(equityCurrency, -fundingLegPV.getAmount(fundingCurrency) * fxRate)));
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsValueDeltaCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsValueDeltaCalculator.java
new file mode 100644
index 0000000..c7f9112
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/trs/EqyTrsValueDeltaCalculator.java
@@ -0,0 +1,42 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.CurrencyAmount;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Calculates the value delta (i.e. delta w.r.t the equity) of an equity total return swap.
+ */
+public final class EqyTrsValueDeltaCalculator extends InstrumentDerivativeVisitorAdapter<EquityTrsDataBundle, MultipleCurrencyAmount> {
+  /** The singleton instance */
+  private static final EqyTrsValueDeltaCalculator INSTANCE = new EqyTrsValueDeltaCalculator();
+
+  /**
+   * Gets the instance.
+   * @return The instance
+   */
+  public static EqyTrsValueDeltaCalculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Private constructor.
+   */
+  private EqyTrsValueDeltaCalculator() {
+  }
+
+  @Override
+  public MultipleCurrencyAmount visitEquityTotalReturnSwap(final EquityTotalReturnSwap equityTrs, final EquityTrsDataBundle data) {
+    ArgumentChecker.notNull(equityTrs, "equityTrs");
+    ArgumentChecker.notNull(data, "data");
+    final CurrencyAmount equityValueDelta = CurrencyAmount.of(equityTrs.getNotionalCurrency(), -(data.getSpotEquity() * equityTrs.getEquity().getNumberOfShares()));
+    return MultipleCurrencyAmount.of(equityValueDelta);
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/horizon/EqyTrsConstantSpreadHorizonCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/horizon/EqyTrsConstantSpreadHorizonCalculator.java
index cd47036..e882a55 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/horizon/EqyTrsConstantSpreadHorizonCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/horizon/EqyTrsConstantSpreadHorizonCalculator.java
@@ -7,8 +7,8 @@ package com.opengamma.analytics.financial.horizon;
 
 import org.threeten.bp.ZonedDateTime;
 
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
 import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
 import com.opengamma.analytics.financial.provider.description.interestrate.MulticurveProviderInterface;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitor.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitor.java
index 3ea291d..4c83bcc 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitor.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitor.java
@@ -25,7 +25,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -34,6 +33,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorAdapter.java
index 0a1b63b..d8a6415 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorAdapter.java
@@ -25,7 +25,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -34,6 +33,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorDelegate.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorDelegate.java
index 288816d..450370b 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorDelegate.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorDelegate.java
@@ -25,7 +25,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -34,6 +33,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameMethodAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameMethodAdapter.java
index b0aa521..b6a7f4b 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameMethodAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameMethodAdapter.java
@@ -25,7 +25,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -34,6 +33,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameValueAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameValueAdapter.java
index 697b581..a76f7a3 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameValueAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorSameValueAdapter.java
@@ -25,7 +25,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -34,6 +33,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/annuity/FloatingAnnuityDefinitionBuilder.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/annuity/FloatingAnnuityDefinitionBuilder.java
index dfa5ceb..a1b3891 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/annuity/FloatingAnnuityDefinitionBuilder.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/annuity/FloatingAnnuityDefinitionBuilder.java
@@ -18,6 +18,7 @@ import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponIborCompoundingDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponIborCompoundingFlatSpreadDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponIborCompoundingSimpleSpreadDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponIborCompoundingSpreadDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponIborDefinition;
 import com.opengamma.analytics.financial.instrument.payment.CouponIborGearingDefinition;
@@ -933,6 +934,24 @@ public class FloatingAnnuityDefinitionBuilder extends AbstractAnnuityDefinitionB
             compoundFixingYearFractions,
             _spread,
             initialCompoundRate);
+      } else if (CompoundingMethod.SPREAD_EXCLUSIVE == _compoundingMethod) {
+        coupon = CouponIborCompoundingSimpleSpreadDefinition.from(
+            getCurrency(), 
+            paymentDate, 
+            accrualStartDate, 
+            accrualEndDate, 
+            accrualYearFraction, 
+            notional, 
+            ((IborIndex) _index),
+            compoundAccrualStartDates, 
+            compoundAccrualEndDates, 
+            compoundAccrualYearFractions, 
+            compoundFixingDates, 
+            compoundFixingStartDates, 
+            compoundFixingEndDates, 
+            compoundFixingYearFractions, 
+            _spread, 
+            initialCompoundRate);
       } else {
         coupon = CouponIborCompoundingSpreadDefinition.from(
             getCurrency(),
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinition.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinition.java
index 5ce27b9..d1b482c 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinition.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinition.java
@@ -9,29 +9,54 @@ import org.threeten.bp.ZonedDateTime;
 
 import com.opengamma.analytics.financial.instrument.InstrumentDefinitionVisitor;
 import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
-import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
 import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
 import com.opengamma.analytics.financial.instrument.swap.TotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
-import com.opengamma.analytics.financial.interestrate.bond.definition.BondSecurity;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedSecurity;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
-import com.opengamma.analytics.financial.interestrate.payments.derivative.Coupon;
 import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.util.time.TimeCalculator;
 import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
 import com.opengamma.util.ArgumentChecker;
 
 /**
- *
+ * Description of a total return swap with an underlying fixed coupon bond and a funding leg.
  */
 public class BondTotalReturnSwapDefinition extends TotalReturnSwapDefinition {
 
+  /** The quantity of the bond reference in the TRS. Can be negative or positive. */
+  private final double _quantity;
+
   /**
+   * Constructor of the bond total return swap.
+   * @param effectiveDate The effective date.
+   * @param terminationDate The termination date.
    * @param annuity The funding leg, not null
-   * @param bond The bond, not null
+   * @param bond The fixed coupon bond. Not null.
+   * @param quantity The quantity of the bond reference in the TRS. Can be negative or positive.
+   */
+  public BondTotalReturnSwapDefinition(final ZonedDateTime effectiveDate, final ZonedDateTime terminationDate,
+      final AnnuityDefinition<? extends PaymentDefinition> annuity,
+      final BondFixedSecurityDefinition bond, final double quantity) {
+    super(effectiveDate, terminationDate, annuity, bond);
+    _quantity = quantity;
+  }
+
+  /**
+   * Gets the fixed bond underlying the TRS.
+   * @return The bond.
+   */
+  @Override
+  public BondFixedSecurityDefinition getAsset() {
+    return (BondFixedSecurityDefinition) super.getAsset();
+  }
+
+  /**
+   * Returns the bond quantity.
+   * @return The quantity.
    */
-  public BondTotalReturnSwapDefinition(final AnnuityDefinition<? extends PaymentDefinition> annuity,
-      final BondSecurityDefinition<? extends PaymentDefinition, ? extends CouponDefinition> bond) {
-    super(annuity, bond);
+  public double getQuantity() {
+    return _quantity;
   }
 
   @Override
@@ -53,9 +78,11 @@ public class BondTotalReturnSwapDefinition extends TotalReturnSwapDefinition {
 
   @Override
   public BondTotalReturnSwap toDerivative(final ZonedDateTime date, final ZonedDateTimeDoubleTimeSeries data) {
+    final double effectiveTime = TimeCalculator.getTimeBetween(date, getEffectiveDate());
+    final double terminationTime = TimeCalculator.getTimeBetween(date, getTerminationDate());
     final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date, data);
-    final BondSecurity<? extends Payment, ? extends Coupon> bond = (BondSecurity<? extends Payment, ? extends Coupon>) getAsset().toDerivative(date);
-    return new BondTotalReturnSwap(fundingLeg, bond);
+    BondFixedSecurity bond = getAsset().toDerivative(date, getEffectiveDate());
+    return new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, _quantity);
   }
 
   @Override
@@ -65,9 +92,11 @@ public class BondTotalReturnSwapDefinition extends TotalReturnSwapDefinition {
 
   @Override
   public BondTotalReturnSwap toDerivative(final ZonedDateTime date) {
+    final double effectiveTime = TimeCalculator.getTimeBetween(date, getEffectiveDate());
+    final double terminationTime = TimeCalculator.getTimeBetween(date, getTerminationDate());
     final Annuity<? extends Payment> fundingLeg = getFundingLeg().toDerivative(date);
-    final BondSecurity<? extends Payment, ? extends Coupon> bond = (BondSecurity<? extends Payment, ? extends Coupon>) getAsset().toDerivative(date);
-    return new BondTotalReturnSwap(fundingLeg, bond);
+    BondFixedSecurity bond = getAsset().toDerivative(date, getEffectiveDate());
+    return new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, _quantity);
   }
 
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/swap/TotalReturnSwapDefinition.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/swap/TotalReturnSwapDefinition.java
index aac06f3..4bc10b7 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/swap/TotalReturnSwapDefinition.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/swap/TotalReturnSwapDefinition.java
@@ -6,34 +6,69 @@
 package com.opengamma.analytics.financial.instrument.swap;
 
 import org.apache.commons.lang.ObjectUtils;
+import org.threeten.bp.ZonedDateTime;
 
 import com.opengamma.analytics.financial.instrument.InstrumentDefinition;
 import com.opengamma.analytics.financial.instrument.InstrumentDefinitionVisitor;
 import com.opengamma.analytics.financial.instrument.InstrumentDefinitionWithData;
 import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
 import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
 import com.opengamma.analytics.financial.interestrate.swap.derivative.TotalReturnSwap;
 import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
 import com.opengamma.util.ArgumentChecker;
 
 /**
- *
+ * Description of a total return swap with an underlying asset and a funding leg.
  */
 public abstract class TotalReturnSwapDefinition implements InstrumentDefinitionWithData<TotalReturnSwap, ZonedDateTimeDoubleTimeSeries> {
+
   /** The funding leg */
   private final AnnuityDefinition<? extends PaymentDefinition> _fundingLeg;
   /** The asset */
   private final InstrumentDefinition<?> _asset;
+  /** The effective date; the date at which the TRS becomes effective and the cash flows of the asset are paid. */
+  private final ZonedDateTime _effectiveDate;
+  /** The termination date; the date at which the TRS terminates. */
+  private final ZonedDateTime _terminationDate;
+
+  /**
+   * Default constructor.
+   * @param effectiveDate The effective date.
+   * @param terminationDate The termination date.
+   * @param fundingLeg The funding leg, not null
+   * @param asset The asset, not null
+   */
+  public TotalReturnSwapDefinition(final ZonedDateTime effectiveDate, final ZonedDateTime terminationDate,
+      final AnnuityDefinition<? extends PaymentDefinition> fundingLeg, final InstrumentDefinition<?> asset) {
+    ArgumentChecker.notNull(fundingLeg, "fundingLeg");
+    ArgumentChecker.notNull(asset, "asset");
+    ArgumentChecker.notNull(effectiveDate, "effective date");
+    ArgumentChecker.notNull(terminationDate, "termination date");
+    _fundingLeg = fundingLeg;
+    _asset = asset;
+    _effectiveDate = effectiveDate;
+    _terminationDate = terminationDate;
+  }
 
   /**
+   * Default constructor. 
+   * The effective date is the start accrual date of the first annuity payment; the first annuity payment must be a CouponDefinition.
+   * The termination date is the date of the last annuity payment.
    * @param fundingLeg The funding leg, not null
    * @param asset The asset, not null
+   * @deprecated Use the constructor with explicit effective date and termnation date.
    */
+  @Deprecated
   public TotalReturnSwapDefinition(final AnnuityDefinition<? extends PaymentDefinition> fundingLeg, final InstrumentDefinition<?> asset) {
     ArgumentChecker.notNull(fundingLeg, "fundingLeg");
     ArgumentChecker.notNull(asset, "asset");
     _fundingLeg = fundingLeg;
     _asset = asset;
+    PaymentDefinition payment0 = fundingLeg.getNthPayment(0);
+    ArgumentChecker.isTrue(payment0 instanceof CouponDefinition, "first payment must be of type CouponDefinition");
+    _effectiveDate = ((CouponDefinition) payment0).getAccrualStartDate();
+    _terminationDate = fundingLeg.getNthPayment(fundingLeg.getNumberOfPayments() - 1).getPaymentDate();
   }
 
   /**
@@ -52,6 +87,22 @@ public abstract class TotalReturnSwapDefinition implements InstrumentDefinitionW
     return _asset;
   }
 
+  /**
+   * Returns the TRS effective date.
+   * @return The date.
+   */
+  public ZonedDateTime getEffectiveDate() {
+    return _effectiveDate;
+  }
+
+  /**
+   * Returns the TRS termination date.
+   * @return The date.
+   */
+  public ZonedDateTime getTerminationDate() {
+    return _terminationDate;
+  }
+
   @Override
   public <U, V> V accept(final InstrumentDefinitionVisitor<U, V> visitor, final U data) {
     ArgumentChecker.notNull(visitor, "visitor");
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinition.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinition.java
index 8b71d48..cea0b63 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinition.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinition.java
@@ -13,6 +13,7 @@ import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.volatilityswap.FXVolatilitySwap;
 import com.opengamma.analytics.util.time.TimeCalculator;
 import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.financial.convention.daycount.DayCountFactory;
 import com.opengamma.financial.convention.frequency.PeriodFrequency;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.money.Currency;
@@ -64,6 +65,7 @@ public class FXVolatilitySwapDefinition extends VolatilitySwapDefinition {
   public Currency getBaseCurrency() {
     return _baseCurrency;
   }
+
   /**
    * Gets the counter currency.
    * @return the counter currency
@@ -91,9 +93,9 @@ public class FXVolatilitySwapDefinition extends VolatilitySwapDefinition {
   @Override
   public FXVolatilitySwap toDerivative(final ZonedDateTime date) {
     ArgumentChecker.notNull(date, "date");
-    final double timeToObservationStart = TimeCalculator.getTimeBetween(date, getObservationStartDate());
-    final double timeToObservationEnd = TimeCalculator.getTimeBetween(date, getObservationEndDate());
-    final double timeToMaturity = TimeCalculator.getTimeBetween(date, getMaturityDate());
+    final double timeToObservationStart = TimeCalculator.getTimeBetween(date, getObservationStartDate(), DayCountFactory.of("Business/252"), getCalendar());
+    final double timeToObservationEnd = TimeCalculator.getTimeBetween(date, getObservationEndDate(), DayCountFactory.of("Business/252"), getCalendar());
+    final double timeToMaturity = TimeCalculator.getTimeBetween(date, getMaturityDate(), DayCountFactory.of("Business/252"), getCalendar());
     return new FXVolatilitySwap(timeToObservationStart, timeToObservationEnd, getObservationFrequency(), timeToMaturity,
         getVolatilityStrike(), getVolatilityNotional(), getCurrency(), _baseCurrency, _counterCurrency, getAnnualizationFactor());
   }
@@ -106,6 +108,7 @@ public class FXVolatilitySwapDefinition extends VolatilitySwapDefinition {
     result = prime * result + _counterCurrency.hashCode();
     return result;
   }
+
   @Override
   public boolean equals(final Object obj) {
     if (this == obj) {
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitor.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitor.java
index 8facd08..0ee2b7f 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitor.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitor.java
@@ -26,7 +26,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -36,6 +35,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorAdapter.java
index a29fa90..22148ba 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorAdapter.java
@@ -26,7 +26,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -36,6 +35,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorDelegate.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorDelegate.java
index f0f5477..796d18b 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorDelegate.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorDelegate.java
@@ -26,7 +26,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -36,6 +35,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameMethodAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameMethodAdapter.java
index 0ae7874..e507858 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameMethodAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameMethodAdapter.java
@@ -26,7 +26,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -36,6 +35,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameValueAdapter.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameValueAdapter.java
index 2d38611..6223d59 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameValueAdapter.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorSameValueAdapter.java
@@ -26,7 +26,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -36,6 +35,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsAssetLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsAssetLegPresentValueCalculator.java
index 69f63cd..e43dcc1 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsAssetLegPresentValueCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsAssetLegPresentValueCalculator.java
@@ -7,7 +7,7 @@ package com.opengamma.analytics.financial.interestrate.bond.calculator;
 
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
-import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueIssuerCalculator;
+import com.opengamma.analytics.financial.interestrate.bond.provider.BondTotalReturnSwapDiscountingMethod;
 import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderInterface;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.money.MultipleCurrencyAmount;
@@ -37,6 +37,7 @@ public final class BondTrsAssetLegPresentValueCalculator extends InstrumentDeriv
   public MultipleCurrencyAmount visitBondTotalReturnSwap(final BondTotalReturnSwap bondTrs, final IssuerProviderInterface data) {
     ArgumentChecker.notNull(bondTrs, "bondTrs");
     ArgumentChecker.notNull(data, "data");
-    return bondTrs.getAsset().accept(PresentValueIssuerCalculator.getInstance(), data);
+    return BondTotalReturnSwapDiscountingMethod.getInstance().presentValueAssetLeg(bondTrs, data);
   }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsFundingLegPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsFundingLegPresentValueCalculator.java
index 29d9728..1584a0a 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsFundingLegPresentValueCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsFundingLegPresentValueCalculator.java
@@ -7,7 +7,7 @@ package com.opengamma.analytics.financial.interestrate.bond.calculator;
 
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
-import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueIssuerCalculator;
+import com.opengamma.analytics.financial.interestrate.bond.provider.BondTotalReturnSwapDiscountingMethod;
 import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderInterface;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.money.MultipleCurrencyAmount;
@@ -37,6 +37,7 @@ public final class BondTrsFundingLegPresentValueCalculator extends InstrumentDer
   public MultipleCurrencyAmount visitBondTotalReturnSwap(final BondTotalReturnSwap bondTrs, final IssuerProviderInterface data) {
     ArgumentChecker.notNull(bondTrs, "bondTrs");
     ArgumentChecker.notNull(data, "data");
-    return bondTrs.getFundingLeg().accept(PresentValueIssuerCalculator.getInstance(), data);
+    return BondTotalReturnSwapDiscountingMethod.getInstance().presentValueFundingLeg(bondTrs, data);
   }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPV01Calculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPV01Calculator.java
index 2ba3aa8..d63a318 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPV01Calculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPV01Calculator.java
@@ -18,7 +18,9 @@ import com.opengamma.util.tuple.Pair;
 
 /**
  * Calculates the PV01s for a bond total return swap. 
+ * @deprecated Use the standard PV01CurveParametersCalculator.
  */
+@Deprecated
 public final class BondTrsPV01Calculator extends InstrumentDerivativeVisitorAdapter<ParameterIssuerProviderInterface, ReferenceAmount<Pair<String, Currency>>> {
   /** A singleton instance */
   private static final BondTrsPV01Calculator INSTANCE = new BondTrsPV01Calculator();
@@ -44,8 +46,10 @@ public final class BondTrsPV01Calculator extends InstrumentDerivativeVisitorAdap
   public ReferenceAmount<Pair<String, Currency>> visitBondTotalReturnSwap(final BondTotalReturnSwap bondTrs, final ParameterIssuerProviderInterface data) {
     ArgumentChecker.notNull(bondTrs, "bondTrs");
     ArgumentChecker.notNull(data, "data");
-    final ReferenceAmount<Pair<String, Currency>> fundingLegPV01 = bondTrs.getFundingLeg().accept(CALCULATOR, data);
-    final ReferenceAmount<Pair<String, Currency>> bondPV01 = bondTrs.getAsset().accept(CALCULATOR, data);
-    return fundingLegPV01.plus(bondPV01);
+    //    final ReferenceAmount<Pair<String, Currency>> fundingLegPV01 = bondTrs.getFundingLeg().accept(CALCULATOR, data);
+    //    final ReferenceAmount<Pair<String, Currency>> bondPV01 = bondTrs.getAsset().accept(CALCULATOR, data);
+    //    return fundingLegPV01.plus(bondPV01);
+    return bondTrs.accept(CALCULATOR, data);
   }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPresentValueCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPresentValueCalculator.java
index fec92ca..769c8d1 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPresentValueCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/calculator/BondTrsPresentValueCalculator.java
@@ -17,7 +17,9 @@ import com.opengamma.util.money.MultipleCurrencyAmount;
 /**
  * Calculates the present value of a bond total return swap. The value is returned in the currency 
  * of the asset.
+ * @deprecated Use the standard issuer calculator {@link PresentValueIssuerCalculator}.
  */
+@Deprecated
 public final class BondTrsPresentValueCalculator extends InstrumentDerivativeVisitorAdapter<IssuerProviderInterface, MultipleCurrencyAmount> {
   /** A singleton instance */
   private static final BondTrsPresentValueCalculator INSTANCE = new BondTrsPresentValueCalculator();
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwap.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwap.java
index 675ef72..f11e76d 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwap.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwap.java
@@ -9,36 +9,52 @@ import org.apache.commons.lang.ObjectUtils;
 
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
 import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
-import com.opengamma.analytics.financial.interestrate.payments.derivative.Coupon;
 import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
 import com.opengamma.analytics.financial.interestrate.swap.derivative.TotalReturnSwap;
 import com.opengamma.util.ArgumentChecker;
 
 /**
- *
+ * Description of a bond total return swap.
  */
 public class BondTotalReturnSwap extends TotalReturnSwap {
-  /** The bond */
-  private final BondSecurity<? extends Payment, ? extends Coupon> _bond;
+
+  /** The underlying bond */
+  private final BondFixedSecurity _bond;
+  /** The quantity of the bond reference in the TRS. Can be negative or positive. */
+  private final double _quantity;
 
   /**
+   * Constructor of the total return swap.
+   * @param effectiveTime The time to the effective date.
+   * @param terminatioTime The time to the termination date.
    * @param fundingLeg The funding leg, not null
-   * @param bond The bond, not null
+   * @param bond The fixed coupon bond. Not null.
+   * @param bondQuantity The quantity of the bond reference in the TRS. Can be negative or positive.
    */
-  public BondTotalReturnSwap(final Annuity<? extends Payment> fundingLeg, final BondSecurity<? extends Payment, ? extends Coupon> bond) {
-    super(fundingLeg);
+  public BondTotalReturnSwap(final double effectiveTime, final double terminatioTime,
+      final Annuity<? extends Payment> fundingLeg, final BondFixedSecurity bond, final double bondQuantity) {
+    super(effectiveTime, terminatioTime, fundingLeg);
     ArgumentChecker.notNull(bond, "bond");
     _bond = bond;
+    _quantity = bondQuantity;
   }
 
   /**
    * Gets the bond bond.
    * @return The bond
    */
-  public BondSecurity<? extends Payment, ? extends Coupon> getAsset() {
+  public BondFixedSecurity getAsset() {
     return _bond;
   }
 
+  /**
+   * Returns the bond quantity.
+   * @return The quantity.
+   */
+  public double getQuantity() {
+    return _quantity;
+  }
+
   @Override
   public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {
     return visitor.visitBondTotalReturnSwap(this, data);
@@ -54,26 +70,31 @@ public class BondTotalReturnSwap extends TotalReturnSwap {
     final int prime = 31;
     int result = super.hashCode();
     result = prime * result + _bond.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(_quantity);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
     return result;
   }
 
   @Override
-  public boolean equals(final Object obj) {
+  public boolean equals(Object obj) {
     if (this == obj) {
       return true;
     }
     if (!super.equals(obj)) {
       return false;
     }
-    if (!(obj instanceof BondTotalReturnSwap)) {
+    if (getClass() != obj.getClass()) {
       return false;
     }
-    final BondTotalReturnSwap other = (BondTotalReturnSwap) obj;
+    BondTotalReturnSwap other = (BondTotalReturnSwap) obj;
     if (!ObjectUtils.equals(_bond, other._bond)) {
       return false;
     }
+    if (Double.doubleToLongBits(_quantity) != Double.doubleToLongBits(other._quantity)) {
+      return false;
+    }
     return true;
   }
 
-
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethod.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethod.java
new file mode 100644
index 0000000..d4896da
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethod.java
@@ -0,0 +1,99 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.interestrate.bond.provider;
+
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueCurveSensitivityIssuerCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueIssuerCalculator;
+import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderInterface;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyMulticurveSensitivity;
+import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Class with methods related to bond TRS valued by discounting.
+ */
+public final class BondTotalReturnSwapDiscountingMethod {
+
+  /**
+   * The unique instance of the class.
+   */
+  private static final BondTotalReturnSwapDiscountingMethod INSTANCE = new BondTotalReturnSwapDiscountingMethod();
+
+  /**
+   * Return the class instance.
+   * @return The instance.
+   */
+  public static BondTotalReturnSwapDiscountingMethod getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Constructor
+   */
+  private BondTotalReturnSwapDiscountingMethod() {
+  }
+
+  /** The present value and present value curve sensitivity calculators used for bonds calculation */
+  private static final PresentValueIssuerCalculator PVIC = PresentValueIssuerCalculator.getInstance();
+  private static final PresentValueCurveSensitivityIssuerCalculator PVCSIC = PresentValueCurveSensitivityIssuerCalculator.getInstance();
+
+  /**
+   * Computes the present value of a bond TRS.
+   * @param trs The bond total return swap.
+   * @param issuerMulticurves The issuer and multi-curves provider.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValue(final BondTotalReturnSwap trs, final IssuerProviderInterface issuerMulticurves) {
+    ArgumentChecker.notNull(trs, "bond TRS");
+    ArgumentChecker.notNull(issuerMulticurves, "issuer and multi-curve provider");
+    final MultipleCurrencyAmount fundingLegPV = trs.getFundingLeg().accept(PVIC, issuerMulticurves);
+    final MultipleCurrencyAmount bondPV = trs.getAsset().accept(PVIC, issuerMulticurves).multipliedBy(trs.getQuantity());
+    return bondPV.plus(fundingLegPV);
+  }
+
+  /**
+   * Computes the present value of the asset leg of a bond TRS. The present value is equal to the bond present value.
+   * @param trs The bond total return swap.
+   * @param issuerMulticurves The issuer and multi-curves provider.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValueAssetLeg(final BondTotalReturnSwap trs, final IssuerProviderInterface issuerMulticurves) {
+    ArgumentChecker.notNull(trs, "bond TRS");
+    ArgumentChecker.notNull(issuerMulticurves, "issuer and multi-curve provider");
+    final MultipleCurrencyAmount bondPV = trs.getAsset().accept(PVIC, issuerMulticurves).multipliedBy(trs.getQuantity());
+    return bondPV;
+  }
+
+  /**
+   * Computes the present value of the funding leg of a bond TRS.
+   * @param trs The bond total return swap.
+   * @param issuerMulticurves The issuer and multi-curves provider.
+   * @return The present value.
+   */
+  public MultipleCurrencyAmount presentValueFundingLeg(final BondTotalReturnSwap trs, final IssuerProviderInterface issuerMulticurves) {
+    ArgumentChecker.notNull(trs, "bond TRS");
+    ArgumentChecker.notNull(issuerMulticurves, "issuer and multi-curve provider");
+    final MultipleCurrencyAmount fundingLegPV = trs.getFundingLeg().accept(PresentValueIssuerCalculator.getInstance(), issuerMulticurves);
+    return fundingLegPV;
+  }
+
+  /**
+   * Computes the present value curve sensitivity of a bond TRS. 
+   * The sensitivity to the (issuer) curves used in the bond valuation and the sensitivity to the curves used in the funding leg valuation are computed.
+   * @param trs The bond total return swap.
+   * @param issuerMulticurves The issuer and multi-curves provider.
+   * @return The present value.
+   */
+  public MultipleCurrencyMulticurveSensitivity presentValueCurveSensitivity(final BondTotalReturnSwap trs, final IssuerProviderInterface issuerMulticurves) {
+    ArgumentChecker.notNull(trs, "bond TRS");
+    ArgumentChecker.notNull(issuerMulticurves, "issuer and multi-curve provider");
+    MultipleCurrencyMulticurveSensitivity fundingLegCS = trs.getFundingLeg().accept(PVCSIC, issuerMulticurves);
+    MultipleCurrencyMulticurveSensitivity bondCS = trs.getAsset().accept(PVCSIC, issuerMulticurves).multipliedBy(trs.getQuantity());
+    return bondCS.plus(fundingLegCS);
+  }
+
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/swap/derivative/TotalReturnSwap.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/swap/derivative/TotalReturnSwap.java
index 8a94e0a..e59475c 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/swap/derivative/TotalReturnSwap.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/swap/derivative/TotalReturnSwap.java
@@ -13,18 +13,28 @@ import com.opengamma.analytics.financial.interestrate.payments.derivative.Paymen
 import com.opengamma.util.ArgumentChecker;
 
 /**
- *
+ * Description of a total return swap: funding leg. The asset is described in the child classes.
  */
 public abstract class TotalReturnSwap implements InstrumentDerivative {
+
   /** The funding leg */
   private final Annuity<? extends Payment> _fundingLeg;
+  /** The time to effective date */
+  private final double _effectiveTime;
+  /** The time to termination date */
+  private final double _terminationTime;
 
   /**
+   * Constructor of the bond TRS.
+   * @param effectiveTime The time to the effective date.
+   * @param terminatioTime The time to the termination date.
    * @param fundingLeg The funding leg, not null
    */
-  public TotalReturnSwap(final Annuity<? extends Payment> fundingLeg) {
+  public TotalReturnSwap(final double effectiveTime, final double terminatioTime, final Annuity<? extends Payment> fundingLeg) {
     ArgumentChecker.notNull(fundingLeg, "fundingLeg");
     _fundingLeg = fundingLeg;
+    _effectiveTime = effectiveTime;
+    _terminationTime = terminatioTime;
   }
 
   /**
@@ -35,6 +45,22 @@ public abstract class TotalReturnSwap implements InstrumentDerivative {
     return _fundingLeg;
   }
 
+  /**
+   * Returns the time to the effective date.
+   * @return The time.
+   */
+  public double getEffectiveTime() {
+    return _effectiveTime;
+  }
+
+  /**
+   * Returns the time to the termination date.
+   * @return The time.
+   */
+  public double getTerminationTime() {
+    return _terminationTime;
+  }
+
   @Override
   public int hashCode() {
     final int prime = 31;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/CurrencyExposureIssuerCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/CurrencyExposureIssuerCalculator.java
new file mode 100644
index 0000000..6b0addb
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/CurrencyExposureIssuerCalculator.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.provider.calculator.issuer;
+
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorDelegate;
+import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * Calculates the currency exposure by discounting with issuer specific curves.
+ */
+public final class CurrencyExposureIssuerCalculator extends InstrumentDerivativeVisitorDelegate<ParameterIssuerProviderInterface, MultipleCurrencyAmount> {
+
+  /**
+   * The unique instance of the calculator.
+   */
+  private static final CurrencyExposureIssuerCalculator INSTANCE = new CurrencyExposureIssuerCalculator();
+
+  /**
+   * Gets the calculator instance.
+   * @return The calculator.
+   */
+  public static CurrencyExposureIssuerCalculator getInstance() {
+    return INSTANCE;
+  }
+
+  /**
+   * Constructor.
+   */
+  private CurrencyExposureIssuerCalculator() {
+    super(PresentValueIssuerCalculator.getInstance());
+  }
+
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueCurveSensitivityIssuerCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueCurveSensitivityIssuerCalculator.java
index c7145cb..16f0874 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueCurveSensitivityIssuerCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueCurveSensitivityIssuerCalculator.java
@@ -10,9 +10,11 @@ import com.opengamma.analytics.financial.interestrate.bond.definition.BillSecuri
 import com.opengamma.analytics.financial.interestrate.bond.definition.BillTransaction;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedSecurity;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedTransaction;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BillSecurityDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BillTransactionDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BondSecurityDiscountingMethod;
+import com.opengamma.analytics.financial.interestrate.bond.provider.BondTotalReturnSwapDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BondTransactionDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.cash.derivative.DepositCounterpart;
 import com.opengamma.analytics.financial.interestrate.cash.provider.DepositCounterpartDiscountingMethod;
@@ -60,6 +62,8 @@ public final class PresentValueCurveSensitivityIssuerCalculator extends Instrume
   private static final BondTransactionDiscountingMethod METHOD_BOND_TR = BondTransactionDiscountingMethod.getInstance();
   /** Method for bond future transactions */
   private static final BondFuturesTransactionDiscountingMethod METHOD_BNDFUT_TRA = BondFuturesTransactionDiscountingMethod.getInstance();
+  /** Method for bond Total Return Swap */
+  private static final BondTotalReturnSwapDiscountingMethod METHOD_TRS = BondTotalReturnSwapDiscountingMethod.getInstance();
 
   //     -----     Deposit     -----
 
@@ -97,4 +101,11 @@ public final class PresentValueCurveSensitivityIssuerCalculator extends Instrume
     return METHOD_BNDFUT_TRA.presentValueCurveSensitivity(futures, issuercurves.getIssuerProvider());
   }
 
+  //     -----     Other     -----
+
+  @Override
+  public MultipleCurrencyMulticurveSensitivity visitBondTotalReturnSwap(final BondTotalReturnSwap trs, final ParameterIssuerProviderInterface issuercurves) {
+    return METHOD_TRS.presentValueCurveSensitivity(trs, issuercurves.getIssuerProvider());
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueIssuerCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueIssuerCalculator.java
index db3a58f..52fd2ea 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueIssuerCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/calculator/issuer/PresentValueIssuerCalculator.java
@@ -12,9 +12,11 @@ import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedS
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedTransaction;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondIborSecurity;
 import com.opengamma.analytics.financial.interestrate.bond.definition.BondIborTransaction;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BillSecurityDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BillTransactionDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BondSecurityDiscountingMethod;
+import com.opengamma.analytics.financial.interestrate.bond.provider.BondTotalReturnSwapDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.bond.provider.BondTransactionDiscountingMethod;
 import com.opengamma.analytics.financial.interestrate.cash.derivative.DepositCounterpart;
 import com.opengamma.analytics.financial.interestrate.cash.provider.DepositCounterpartDiscountingMethod;
@@ -61,6 +63,8 @@ public final class PresentValueIssuerCalculator extends InstrumentDerivativeVisi
   private static final BondTransactionDiscountingMethod METHOD_BOND_TR = BondTransactionDiscountingMethod.getInstance();
   /** Method for bond future transactions */
   private static final BondFuturesTransactionDiscountingMethod METHOD_BNDFUT_TRA = BondFuturesTransactionDiscountingMethod.getInstance();
+  /** Method for bond Total Return Swap */
+  private static final BondTotalReturnSwapDiscountingMethod METHOD_TRS = BondTotalReturnSwapDiscountingMethod.getInstance();
 
   //     -----     Deposit     -----
 
@@ -107,4 +111,12 @@ public final class PresentValueIssuerCalculator extends InstrumentDerivativeVisi
   public MultipleCurrencyAmount visitBondFuturesTransaction(final BondFuturesTransaction futures, final ParameterIssuerProviderInterface issuercurves) {
     return METHOD_BNDFUT_TRA.presentValue(futures, issuercurves.getIssuerProvider());
   }
+
+  //     -----     Other     -----
+
+  @Override
+  public MultipleCurrencyAmount visitBondTotalReturnSwap(final BondTotalReturnSwap trs, final ParameterIssuerProviderInterface issuercurves) {
+    return METHOD_TRS.presentValue(trs, issuercurves.getIssuerProvider());
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/curve/issuer/IssuerDiscountBuildingRepository.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/curve/issuer/IssuerDiscountBuildingRepository.java
index 3dd5ee8..71de5b8 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/curve/issuer/IssuerDiscountBuildingRepository.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/provider/curve/issuer/IssuerDiscountBuildingRepository.java
@@ -145,7 +145,7 @@ public class IssuerDiscountBuildingRepository {
     allCurveName.addAll(currentCurves); // Manipulation to ensure that the new curves are at the end.
     //Implementation note : if blockBundle don't contain a block for a specific curve then we remove this curve from  beforeCurveName. 
     //Because we can't compute the total bundle without the block for each curve. So we are computing a total bundle without this curve.
-    for (final String name : beforeCurveName) {
+    for (final String name : new LinkedHashSet<>(beforeCurveName)) {
       if (!(blockBundle.getData().containsKey(name))) {
         beforeCurveName.remove(name);
       }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculator.java
index 279dddd..b5ee723 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculator.java
@@ -5,6 +5,8 @@
  */
 package com.opengamma.analytics.financial.volatilityswap;
 
+import java.util.Arrays;
+
 import com.google.common.primitives.Doubles;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitorAdapter;
 import com.opengamma.analytics.financial.model.volatility.surface.SmileDeltaTermStructureParameters;
@@ -31,6 +33,8 @@ public class CarrLeeFXVolatilitySwapCalculator extends InstrumentDerivativeVisit
   private final double _highestCallDelta;
   private final int _numPoints;
 
+  private final double[] _strikeRange;
+
   /**
    * Default constructor
    */
@@ -51,6 +55,24 @@ public class CarrLeeFXVolatilitySwapCalculator extends InstrumentDerivativeVisit
     _lowestPutDelta = lowestPutDelta;
     _highestCallDelta = highestCallDelta;
     _numPoints = numPoints;
+    _strikeRange = null;
+  }
+
+  /**
+   * Constructor specifying number of strikes and strike range by strike values
+   * @param numPoints The number of strikes between the lowest strike and the highest strike is (numPoints + 1)
+   * @param strikeRange {minimum strike, maximum strike}
+   */
+  public CarrLeeFXVolatilitySwapCalculator(final int numPoints, final double[] strikeRange) {
+    ArgumentChecker.isTrue(numPoints > 2, "numPoints should be greater than 2");
+    ArgumentChecker.notNull(strikeRange, "strikeRange");
+    ArgumentChecker.isTrue(strikeRange.length == 2, "length of strikeRange should be 2");
+    ArgumentChecker.isTrue(strikeRange[0] < strikeRange[1], "upper bound should be greater than lower bound");
+
+    _lowestPutDelta = 0.0;
+    _highestCallDelta = 0.0;
+    _numPoints = numPoints;
+    _strikeRange = Arrays.copyOf(strikeRange, 2);
   }
 
   @Override
@@ -72,15 +94,22 @@ public class CarrLeeFXVolatilitySwapCalculator extends InstrumentDerivativeVisit
     final double forward = spot * foreignDF / domesticDF;
     final double timeFromInception = swap.getTimeToObservationStart() < 0 ? Math.abs(swap.getTimeToObservationStart()) : 0;
     final double[] strikeRange;
-    if (swap.getTimeToObservationStart() < 0) {
-      if (data.getRealizedVariance() == null) {
-        throw new IllegalStateException("Trying to price a seasoned swap but have null realized variance in the market data object");
+
+    if (_strikeRange == null) {
+      if (swap.getTimeToObservationStart() < 0) {
+        if (data.getRealizedVariance() == null) {
+          throw new IllegalStateException("Trying to price a seasoned swap but have null realized variance in the market data object");
+        }
+        final double reference = 3.0 * Math.sqrt(data.getRealizedVariance() * timeFromInception) / 100.;
+        strikeRange = getStrikeRange(timeToExpiry, data.getVolatilityData(), forward, reference);
+      } else {
+        strikeRange = getStrikeRange(timeToExpiry, data.getVolatilityData(), forward, 0.);
       }
-      final double reference = 3.0 * Math.sqrt(data.getRealizedVariance() * timeFromInception) / 100.;
-      strikeRange = getStrikeRange(timeToExpiry, data.getVolatilityData(), forward, reference);
     } else {
-      strikeRange = getStrikeRange(timeToExpiry, data.getVolatilityData(), forward, 0.);
+      strikeRange = Arrays.copyOf(_strikeRange, 2);
+      ArgumentChecker.isTrue((forward > strikeRange[0] && forward < strikeRange[1]), "forward is outside of strike range");
     }
+
     final double deltaK = (strikeRange[1] - strikeRange[0]) / _numPoints;
     final double[] strikes = new double[_numPoints + 1];
     for (int i = 0; i < _numPoints; ++i) {
@@ -159,4 +188,45 @@ public class CarrLeeFXVolatilitySwapCalculator extends InstrumentDerivativeVisit
     };
   }
 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    long temp;
+    temp = Double.doubleToLongBits(_highestCallDelta);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(_lowestPutDelta);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + _numPoints;
+    result = prime * result + Arrays.hashCode(_strikeRange);
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof CarrLeeFXVolatilitySwapCalculator)) {
+      return false;
+    }
+    CarrLeeFXVolatilitySwapCalculator other = (CarrLeeFXVolatilitySwapCalculator) obj;
+    if (Double.doubleToLongBits(_highestCallDelta) != Double.doubleToLongBits(other._highestCallDelta)) {
+      return false;
+    }
+    if (Double.doubleToLongBits(_lowestPutDelta) != Double.doubleToLongBits(other._lowestPutDelta)) {
+      return false;
+    }
+    if (_numPoints != other._numPoints) {
+      return false;
+    }
+    if (!Arrays.equals(_strikeRange, other._strikeRange)) {
+      return false;
+    }
+    return true;
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapDeltaCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapDeltaCalculator.java
index 727e18a..2102847 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapDeltaCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapDeltaCalculator.java
@@ -23,15 +23,15 @@ import com.opengamma.util.ArgumentChecker;
 public class CarrLeeFXVolatilitySwapDeltaCalculator extends InstrumentDerivativeVisitorAdapter<CarrLeeFXData, Double> {
 
   private static final double DEFAULT_BUMP = 1.0e-5;
-  private static final CarrLeeFXVolatilitySwapCalculator CALCULATOR = new CarrLeeFXVolatilitySwapCalculator();
 
+  private final CarrLeeFXVolatilitySwapCalculator _cal;
   private final double _bumpSpot;
 
   /**
    * Constructor using default bump amount
    */
   public CarrLeeFXVolatilitySwapDeltaCalculator() {
-    _bumpSpot = DEFAULT_BUMP;
+    this(DEFAULT_BUMP);
   }
 
   /**
@@ -40,6 +40,18 @@ public class CarrLeeFXVolatilitySwapDeltaCalculator extends InstrumentDerivative
    */
   public CarrLeeFXVolatilitySwapDeltaCalculator(final double bump) {
     _bumpSpot = bump;
+    _cal = new CarrLeeFXVolatilitySwapCalculator();
+  }
+
+  /**
+   * Constructor specifying bump amount and base calculator
+   * @param bump The bump amount
+   * @param cal Base calculator
+   */
+  public CarrLeeFXVolatilitySwapDeltaCalculator(final double bump, final CarrLeeFXVolatilitySwapCalculator cal) {
+    ArgumentChecker.notNull(cal, "cal");
+    _bumpSpot = bump;
+    _cal = cal;
   }
 
   /**
@@ -58,7 +70,7 @@ public class CarrLeeFXVolatilitySwapDeltaCalculator extends InstrumentDerivative
     final double baseFV = result.getFairValue();
 
     final CarrLeeFXData spotBumpedData = getSpotBumpedData(data);
-    final VolatilitySwapCalculatorResult spotBumpedRes = CALCULATOR.visitFXVolatilitySwap(swap, spotBumpedData);
+    final VolatilitySwapCalculatorResult spotBumpedRes = _cal.visitFXVolatilitySwap(swap, spotBumpedData);
     final double spotBumpedFV = spotBumpedRes.getFairValue();
 
     return (spotBumpedFV - baseFV) / _bumpSpot;
@@ -69,8 +81,7 @@ public class CarrLeeFXVolatilitySwapDeltaCalculator extends InstrumentDerivative
     ArgumentChecker.notNull(swap, "swap");
     ArgumentChecker.notNull(data, "data");
 
-    final CarrLeeFXVolatilitySwapCalculator calculator = new CarrLeeFXVolatilitySwapCalculator();
-    final VolatilitySwapCalculatorResultWithStrikes result = calculator.visitFXVolatilitySwap(swap, data);
+    final VolatilitySwapCalculatorResultWithStrikes result = _cal.visitFXVolatilitySwap(swap, data);
     return getFXVolatilitySwapDelta(result, swap, data);
   }
 
@@ -94,4 +105,40 @@ public class CarrLeeFXVolatilitySwapDeltaCalculator extends InstrumentDerivative
     return new CarrLeeFXData(data.getCurrencyPair(), data.getVolatilityData(), spotBumpedCurves, data.getRealizedVariance());
   }
 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    long temp;
+    temp = Double.doubleToLongBits(_bumpSpot);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + ((_cal == null) ? 0 : _cal.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof CarrLeeFXVolatilitySwapDeltaCalculator)) {
+      return false;
+    }
+    CarrLeeFXVolatilitySwapDeltaCalculator other = (CarrLeeFXVolatilitySwapDeltaCalculator) obj;
+    if (Double.doubleToLongBits(_bumpSpot) != Double.doubleToLongBits(other._bumpSpot)) {
+      return false;
+    }
+    if (_cal == null) {
+      if (other._cal != null) {
+        return false;
+      }
+    } else if (!_cal.equals(other._cal)) {
+      return false;
+    }
+    return true;
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapThetaCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapThetaCalculator.java
index ecf6ec0..376c67a 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapThetaCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapThetaCalculator.java
@@ -14,7 +14,23 @@ import com.opengamma.util.ArgumentChecker;
  * Compute theta of forward volatility based on finite difference method
  */
 public class CarrLeeFXVolatilitySwapThetaCalculator extends InstrumentDerivativeVisitorAdapter<CarrLeeFXData, Double> {
-  private static final CarrLeeFXVolatilitySwapCalculator CALCULATOR = new CarrLeeFXVolatilitySwapCalculator();
+  private final CarrLeeFXVolatilitySwapCalculator _cal;
+
+  /**
+   * Constructor using default calculator
+   */
+  public CarrLeeFXVolatilitySwapThetaCalculator() {
+    _cal = new CarrLeeFXVolatilitySwapCalculator();
+  }
+
+  /**
+   * Constructor specifying base calculator
+   * @param cal Base calculator
+   */
+  public CarrLeeFXVolatilitySwapThetaCalculator(final CarrLeeFXVolatilitySwapCalculator cal) {
+    ArgumentChecker.notNull(cal, "cal");
+    _cal = cal;
+  }
 
   /**
    * Theta calculator for FX volatility swap based on "bump and reprice" using {@link VolatilitySwapCalculatorResultWithStrikes}, 
@@ -49,7 +65,7 @@ public class CarrLeeFXVolatilitySwapThetaCalculator extends InstrumentDerivative
 
     final FXVolatilitySwap timeBumpedSwap = new FXVolatilitySwap(bumpedTimeToObservationStart, swap.getTimeToObservationEnd() - timeBumpAmount, swap.getObservationFrequency(),
         swap.getTimeToMaturity() - timeBumpAmount, swap.getVolatilityStrike(), swap.getVolatilityNotional(), swap.getCurrency(), swap.getBaseCurrency(), swap.getCounterCurrency(), aFac);
-    final VolatilitySwapCalculatorResult timeBumpedRes = CALCULATOR.visitFXVolatilitySwap(timeBumpedSwap, data);
+    final VolatilitySwapCalculatorResult timeBumpedRes = _cal.visitFXVolatilitySwap(timeBumpedSwap, data);
     final double timeBumpedFV = timeBumpedRes.getFairValue();
 
     return timeBumpedFV - baseFV;
@@ -60,9 +76,38 @@ public class CarrLeeFXVolatilitySwapThetaCalculator extends InstrumentDerivative
     ArgumentChecker.notNull(swap, "swap");
     ArgumentChecker.notNull(data, "data");
 
-    final CarrLeeFXVolatilitySwapCalculator calculator = new CarrLeeFXVolatilitySwapCalculator();
-    final VolatilitySwapCalculatorResultWithStrikes result = calculator.visitFXVolatilitySwap(swap, data);
+    final VolatilitySwapCalculatorResultWithStrikes result = _cal.visitFXVolatilitySwap(swap, data);
     return getFXVolatilitySwapTheta(result, swap, data);
   }
 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((_cal == null) ? 0 : _cal.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof CarrLeeFXVolatilitySwapThetaCalculator)) {
+      return false;
+    }
+    CarrLeeFXVolatilitySwapThetaCalculator other = (CarrLeeFXVolatilitySwapThetaCalculator) obj;
+    if (_cal == null) {
+      if (other._cal != null) {
+        return false;
+      }
+    } else if (!_cal.equals(other._cal)) {
+      return false;
+    }
+    return true;
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapVegaCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapVegaCalculator.java
index 0994ae8..5c84e22 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapVegaCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapVegaCalculator.java
@@ -21,6 +21,7 @@ public class CarrLeeFXVolatilitySwapVegaCalculator extends InstrumentDerivativeV
   private static final CarrLeeNewlyIssuedSyntheticVolatilitySwapCalculator NEW_CALCULATOR = new CarrLeeNewlyIssuedSyntheticVolatilitySwapCalculator();
   private static final CarrLeeSeasonedSyntheticVolatilitySwapCalculator SEASONED_CALCULATOR = new CarrLeeSeasonedSyntheticVolatilitySwapCalculator();
 
+  private final CarrLeeFXVolatilitySwapCalculator _cal;
   private final double _bumpVol;
 
   /**
@@ -28,7 +29,7 @@ public class CarrLeeFXVolatilitySwapVegaCalculator extends InstrumentDerivativeV
    * Note that fractional volatility is bumped
    */
   public CarrLeeFXVolatilitySwapVegaCalculator() {
-    _bumpVol = DEFAULT_BUMP;
+    this(DEFAULT_BUMP);
   }
 
   /**
@@ -37,6 +38,18 @@ public class CarrLeeFXVolatilitySwapVegaCalculator extends InstrumentDerivativeV
    */
   public CarrLeeFXVolatilitySwapVegaCalculator(final double bump) {
     _bumpVol = bump;
+    _cal = new CarrLeeFXVolatilitySwapCalculator();
+  }
+
+  /**
+   * Constructor specifying bump amount
+   * @param bump The bump amount
+   * @param cal Base calculator
+   */
+  public CarrLeeFXVolatilitySwapVegaCalculator(final double bump, final CarrLeeFXVolatilitySwapCalculator cal) {
+    ArgumentChecker.notNull(cal, "cal");
+    _bumpVol = bump;
+    _cal = cal;
   }
 
   /**
@@ -109,9 +122,44 @@ public class CarrLeeFXVolatilitySwapVegaCalculator extends InstrumentDerivativeV
     ArgumentChecker.notNull(swap, "swap");
     ArgumentChecker.notNull(data, "data");
 
-    final CarrLeeFXVolatilitySwapCalculator calculator = new CarrLeeFXVolatilitySwapCalculator();
-    final VolatilitySwapCalculatorResultWithStrikes result = calculator.visitFXVolatilitySwap(swap, data);
+    final VolatilitySwapCalculatorResultWithStrikes result = _cal.visitFXVolatilitySwap(swap, data);
     return getFXVolatilitySwapVega(result, swap, data);
   }
 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    long temp;
+    temp = Double.doubleToLongBits(_bumpVol);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + ((_cal == null) ? 0 : _cal.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof CarrLeeFXVolatilitySwapVegaCalculator)) {
+      return false;
+    }
+    CarrLeeFXVolatilitySwapVegaCalculator other = (CarrLeeFXVolatilitySwapVegaCalculator) obj;
+    if (Double.doubleToLongBits(_bumpVol) != Double.doubleToLongBits(other._bumpVol)) {
+      return false;
+    }
+    if (_cal == null) {
+      if (other._cal != null) {
+        return false;
+      }
+    } else if (!_cal.equals(other._cal)) {
+      return false;
+    }
+    return true;
+  }
+
 }
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeSeasonedSyntheticVolatilitySwapCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeSeasonedSyntheticVolatilitySwapCalculator.java
index 5e26acf..df5cfca 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeSeasonedSyntheticVolatilitySwapCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeSeasonedSyntheticVolatilitySwapCalculator.java
@@ -80,7 +80,7 @@ public class CarrLeeSeasonedSyntheticVolatilitySwapCalculator {
 
     final double rate = interestRate - dividend;
     final double forward = spot * Math.exp(rate * timeToExpiry);
-    ArgumentChecker.isTrue((callStrikes[0] > forward && putStrikes[nPuts - 1] < forward), "Max(putStrikes) < forward < Min(callStrikes) should hold");
+    ArgumentChecker.isTrue((callStrikes[0] >= forward && putStrikes[nPuts - 1] <= forward), "Max(putStrikes) <= forward <= Min(callStrikes) should hold");
 
     final double u = 100. / Math.sqrt(timeToExpiry + timeFromInception);
     final double us = 100. / Math.sqrt(timeFromInception);
@@ -117,10 +117,14 @@ public class CarrLeeSeasonedSyntheticVolatilitySwapCalculator {
 
     for (int i = 0; i < nOptions; ++i) {
       final double logKF = Math.log(strikes[i] / forward);
-      final double bound = 50. / Math.sqrt(resRV);
-      final Function1D<Double, Double> funcFin = integrandFin(logKF, resRV);
-      final Function1D<Double, Double> funcInf = integrandInf(logKF, resRV);
-      res[i] = reFac * Math.exp(0.5 * logKF) * (INTEGRATOR.integrate(funcFin, 0., 0.5 * Math.PI) + INTEGRATOR.integrate(funcInf, 0., bound)) / strikes[i] / strikes[i];
+      if (Math.abs(logKF) < EPS) {
+        res[i] = reFac * Math.sqrt(2. * Math.PI / resRV) / strikes[i] / strikes[i];
+      } else {
+        final double bound = 50. / Math.sqrt(resRV);
+        final Function1D<Double, Double> funcFin = integrandFin(logKF, resRV);
+        final Function1D<Double, Double> funcInf = integrandInf(logKF, resRV);
+        res[i] = reFac * Math.exp(0.5 * logKF) * (INTEGRATOR.integrate(funcFin, 0., 0.5 * Math.PI) + INTEGRATOR.integrate(funcInf, 0., bound)) / strikes[i] / strikes[i];
+      }
     }
 
     return res;
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/RealizedVolatilityCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/RealizedVolatilityCalculator.java
new file mode 100644
index 0000000..70d0900
--- /dev/null
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/RealizedVolatilityCalculator.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.volatilityswap;
+
+import com.opengamma.util.ArgumentChecker;
+
+/**
+ * 
+ */
+public class RealizedVolatilityCalculator {
+
+  /**
+   * @param spotValues Spot values
+   * @return realized variance
+   */
+  public double getRealizedVariance(final double[] spotValues) {
+    ArgumentChecker.notNull(spotValues, "spotValues");
+    final int nSpots = spotValues.length;
+    ArgumentChecker.isTrue(nSpots > 1, "Number of spot values should be greater than 1");
+
+    double res = 0.0;
+    for (int i = 1; i < nSpots; ++i) {
+      res += Math.pow(Math.log(spotValues[i] / spotValues[i - 1]), 2.0);
+    }
+    final double factor = 252.0 * 1.e4 / (nSpots - 1.0);
+    res *= factor;
+    return res;
+  }
+
+  /**
+   * @param spotValues Spot Values
+   * @return realized volatility
+   */
+  public double getRealizedVolatility(final double[] spotValues) {
+    final double var = getRealizedVariance(spotValues);
+    return Math.sqrt(var);
+  }
+}
diff --git a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksCalculator.java b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksCalculator.java
index d437c79..174e0fd 100644
--- a/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksCalculator.java
+++ b/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksCalculator.java
@@ -27,7 +27,7 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
   private static final double DEFAULT_BUMP = 1.0e-5;
   private static final CarrLeeNewlyIssuedSyntheticVolatilitySwapCalculator NEW_CALCULATOR = new CarrLeeNewlyIssuedSyntheticVolatilitySwapCalculator();
   private static final CarrLeeSeasonedSyntheticVolatilitySwapCalculator SEASONED_CALCULATOR = new CarrLeeSeasonedSyntheticVolatilitySwapCalculator();
-  private static final CarrLeeFXVolatilitySwapCalculator COMBINED_CALCULATOR = new CarrLeeFXVolatilitySwapCalculator();
+  private final CarrLeeFXVolatilitySwapCalculator _combinedCal;
 
   private final double _bumpSpot;
   private final double _bumpVol;
@@ -36,8 +36,7 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
    * Constructor using default bump amount
    */
   public VolatilitySwapFiniteDifferenceGreeksCalculator() {
-    _bumpSpot = DEFAULT_BUMP;
-    _bumpVol = _bumpSpot * 1.0e-2;
+    this(DEFAULT_BUMP);
   }
 
   /**
@@ -47,6 +46,18 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
   public VolatilitySwapFiniteDifferenceGreeksCalculator(final double bump) {
     _bumpSpot = bump;
     _bumpVol = _bumpSpot * 1.0e-2;
+    _combinedCal = new CarrLeeFXVolatilitySwapCalculator();
+  }
+
+  /**
+   * Constructor specifying bump amount and base calculator
+   * @param bump The bump amount
+   * @param baseCal Base calculator
+   */
+  public VolatilitySwapFiniteDifferenceGreeksCalculator(final double bump, final CarrLeeFXVolatilitySwapCalculator baseCal) {
+    _bumpSpot = bump;
+    _bumpVol = _bumpSpot * 1.0e-2;
+    _combinedCal = baseCal;
   }
 
   /**
@@ -106,11 +117,11 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
 
     final FXVolatilitySwap timeBumpedSwap = new FXVolatilitySwap(bumpedTimeToObservationStart, swap.getTimeToObservationEnd() - timeBumpAmount, swap.getObservationFrequency(),
         swap.getTimeToMaturity() - timeBumpAmount, swap.getVolatilityStrike(), swap.getVolatilityNotional(), swap.getCurrency(), swap.getBaseCurrency(), swap.getCounterCurrency(), aFac);
-    final VolatilitySwapCalculatorResult timeBumpedRes = COMBINED_CALCULATOR.visitFXVolatilitySwap(timeBumpedSwap, data);
+    final VolatilitySwapCalculatorResult timeBumpedRes = _combinedCal.visitFXVolatilitySwap(timeBumpedSwap, data);
     final double timeBumpedFV = timeBumpedRes.getFairValue();
 
     final CarrLeeFXData spotBumpedData = getSpotBumpedData(data);
-    final VolatilitySwapCalculatorResult spotBumpedRes = COMBINED_CALCULATOR.visitFXVolatilitySwap(swap, spotBumpedData);
+    final VolatilitySwapCalculatorResult spotBumpedRes = _combinedCal.visitFXVolatilitySwap(swap, spotBumpedData);
     final double spotBumpedFV = spotBumpedRes.getFairValue();
 
     if (rv == null) {
@@ -142,8 +153,7 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
     ArgumentChecker.notNull(swap, "swap");
     ArgumentChecker.notNull(data, "data");
 
-    final CarrLeeFXVolatilitySwapCalculator calculator = new CarrLeeFXVolatilitySwapCalculator();
-    final VolatilitySwapCalculatorResultWithStrikes result = calculator.visitFXVolatilitySwap(swap, data);
+    final VolatilitySwapCalculatorResultWithStrikes result = _combinedCal.visitFXVolatilitySwap(swap, data);
     return getFXVolatilitySwapGreeks(result, swap, data);
   }
 
@@ -167,4 +177,45 @@ public class VolatilitySwapFiniteDifferenceGreeksCalculator {
     return new CarrLeeFXData(data.getCurrencyPair(), data.getVolatilityData(), spotBumpedCurves, data.getRealizedVariance());
   }
 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    long temp;
+    temp = Double.doubleToLongBits(_bumpSpot);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(_bumpVol);
+    result = prime * result + (int) (temp ^ (temp >>> 32));
+    result = prime * result + ((_combinedCal == null) ? 0 : _combinedCal.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof VolatilitySwapFiniteDifferenceGreeksCalculator)) {
+      return false;
+    }
+    VolatilitySwapFiniteDifferenceGreeksCalculator other = (VolatilitySwapFiniteDifferenceGreeksCalculator) obj;
+    if (Double.doubleToLongBits(_bumpSpot) != Double.doubleToLongBits(other._bumpSpot)) {
+      return false;
+    }
+    if (Double.doubleToLongBits(_bumpVol) != Double.doubleToLongBits(other._bumpVol)) {
+      return false;
+    }
+    if (_combinedCal == null) {
+      if (other._combinedCal != null) {
+        return false;
+      }
+    } else if (!_combinedCal.equals(other._combinedCal)) {
+      return false;
+    }
+    return true;
+  }
+
 }
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinitionTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinitionTest.java
new file mode 100644
index 0000000..f962cc2
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDefinitionTest.java
@@ -0,0 +1,102 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.datasets.CalendarGBP;
+import com.opengamma.analytics.financial.equity.Equity;
+import com.opengamma.analytics.financial.equity.EquityDefinition;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.financial.legalentity.CreditRating;
+import com.opengamma.analytics.financial.legalentity.LegalEntity;
+import com.opengamma.analytics.financial.legalentity.Region;
+import com.opengamma.analytics.financial.legalentity.Sector;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.util.i18n.Country;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Tests related to the description of an equity total return swap.
+ */
+public class EquityTotalReturnSwapDefinitionTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+
+  private static final Currency GBP = Currency.GBP;
+  private static final Calendar LON = new CalendarGBP("LON");
+  private static final double NOTIONAL_TRS = 123456000;
+  // Equity
+  private static final double NB_SHARES = 1000000;
+  // Funding: unique fixed coupon in GBP: pay TRS equity, receive funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(GBP,
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new CouponFixedDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION }, LON);
+  private static final String OG_NAME = "OpenGamma Ltd";
+  private static final String OG_TICKER = "OG";
+  private static final LegalEntity OG_LEGAL_ENTITY = new LegalEntity(OG_TICKER, OG_NAME, Sets.newHashSet(CreditRating.of("AAA", "ABC", true)), Sector.of("Technology"),
+      Region.of("UK", Country.GB, Currency.GBP));
+  private static final EquityDefinition EQUITY_DEFINITION = new EquityDefinition(OG_LEGAL_ENTITY, GBP, NB_SHARES);
+  private static final double DIVIDEND_RATIO = 1.0;
+  private static final EquityTotalReturnSwapDefinition TRS_PAY_FIXED_REC_DEFINITION = new EquityTotalReturnSwapDefinition(EFFECTIVE_DATE_1,
+      TERMINATION_DATE_1, FUNDING_LEG_FIXED_REC_DEFINITION, EQUITY_DEFINITION, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullEffectiveDate() {
+    new EquityTotalReturnSwapDefinition(null, TERMINATION_DATE_1, FUNDING_LEG_FIXED_REC_DEFINITION, EQUITY_DEFINITION, NOTIONAL_TRS, GBP, 1.0);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullTerminationDate() {
+    new EquityTotalReturnSwapDefinition(EFFECTIVE_DATE_1, null, FUNDING_LEG_FIXED_REC_DEFINITION, EQUITY_DEFINITION, NOTIONAL_TRS, GBP, 1.0);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullFundingLeg() {
+    new EquityTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, null, EQUITY_DEFINITION, NOTIONAL_TRS, GBP, 1.0);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullUnderlyingEquity() {
+    new EquityTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, FUNDING_LEG_FIXED_REC_DEFINITION, null, NOTIONAL_TRS, GBP, 1.0);
+  }
+
+  @Test
+  public void getter() {
+    assertEquals("EquityTotalReturnSwapDefinition: getter", EFFECTIVE_DATE_1, TRS_PAY_FIXED_REC_DEFINITION.getEffectiveDate());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", TERMINATION_DATE_1, TRS_PAY_FIXED_REC_DEFINITION.getTerminationDate());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", FUNDING_LEG_FIXED_REC_DEFINITION, TRS_PAY_FIXED_REC_DEFINITION.getFundingLeg());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", EQUITY_DEFINITION, TRS_PAY_FIXED_REC_DEFINITION.getAsset());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", DIVIDEND_RATIO, TRS_PAY_FIXED_REC_DEFINITION.getDividendPercentage());
+  }
+
+  @Test
+  public void toDerivative() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    Equity equity = new Equity(OG_LEGAL_ENTITY, GBP, NB_SHARES);
+    EquityTotalReturnSwap trsExpected = new EquityTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, equity, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+    EquityTotalReturnSwap trsConverted = TRS_PAY_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethodTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethodTest.java
new file mode 100644
index 0000000..cd76868
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapDiscountingMethodTest.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertTrue;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.datasets.CalendarGBP;
+import com.opengamma.analytics.financial.datasets.CalendarUSD;
+import com.opengamma.analytics.financial.equity.Equity;
+import com.opengamma.analytics.financial.equity.EquityDefinition;
+import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinitionBuilder;
+import com.opengamma.analytics.financial.instrument.index.IborIndex;
+import com.opengamma.analytics.financial.instrument.index.IndexIborMaster;
+import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentFixedDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.financial.legalentity.CreditRating;
+import com.opengamma.analytics.financial.legalentity.LegalEntity;
+import com.opengamma.analytics.financial.legalentity.Region;
+import com.opengamma.analytics.financial.legalentity.Sector;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueCurveSensitivityDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.description.MulticurveProviderDiscountDataSets;
+import com.opengamma.analytics.financial.provider.description.interestrate.MulticurveProviderDiscount;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyMulticurveSensitivity;
+import com.opengamma.analytics.financial.util.AssertSensitivityObjects;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.financial.convention.StubType;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.timeseries.precise.zdt.ImmutableZonedDateTimeDoubleTimeSeries;
+import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
+import com.opengamma.util.i18n.Country;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Test related to the equity total return swap pricing methodology by discounting of funding leg the cash-flows.
+ */
+public class EquityTotalReturnSwapDiscountingMethodTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime EFFECTIVE_DATE_2 = DateUtils.getUTCDate(2012, 3, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+  private static final ZonedDateTime TERMINATION_DATE_2 = DateUtils.getUTCDate(2012, 9, 9);
+
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+  private static final ZonedDateTime REFERENCE_DATE_2 = DateUtils.getUTCDate(2012, 2, 16); // After effective date 1.
+
+  private static final double EFFECTIVE_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  private static final double EFFECTIVE_TIME_2_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+  private static final double TERMINATION_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+  private static final double TERMINATION_TIME_2_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, TERMINATION_DATE_1);
+
+  private static final ZonedDateTime[] FIXING_DATES = new ZonedDateTime[] {DateUtils.getUTCDate(2012, 2, 7), DateUtils.getUTCDate(2012, 2, 8),
+    DateUtils.getUTCDate(2012, 2, 9), DateUtils.getUTCDate(2012, 3, 7) };
+  private static final double[] FIXING_RATES = new double[] {0.0040, 0.0041, 0.0042, 0.0043 };
+  private static final ZonedDateTimeDoubleTimeSeries FIXING_TS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(FIXING_DATES, FIXING_RATES);
+
+  private static final Currency GBP = Currency.GBP;
+  private static final Calendar LON = new CalendarGBP("LON");
+
+  // Equity
+  private static final double NB_SHARES = 1000000;
+  private static final String OG_NAME = "OpenGamma Ltd";
+  private static final String OG_TICKER = "OG";
+  private static final LegalEntity OG_LEGAL_ENTITY = new LegalEntity(OG_TICKER, OG_NAME, Sets.newHashSet(CreditRating.of("AAA", "ABC", true)), Sector.of("Technology"),
+      Region.of("UK", Country.GB, Currency.GBP));
+  private static final EquityDefinition EQUITY_DEFINITION_REC = new EquityDefinition(OG_LEGAL_ENTITY, GBP, NB_SHARES);
+  private static final Equity EQUITY_REC = new Equity(OG_LEGAL_ENTITY, GBP, NB_SHARES);
+  private static final Equity EQUITY_PAY = new Equity(OG_LEGAL_ENTITY, GBP, -NB_SHARES);
+  private static final double DIVIDEND_RATIO = 1.0;
+
+  private static final double NOTIONAL_TRS = 123456000;
+  // Funding: unique fixed coupon in GBP: receive TRS equity, pay funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(GBP,
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final PaymentFixedDefinition FUNDING_FIXED_NTL_REC_DEFINITION = new PaymentFixedDefinition(GBP, TERMINATION_DATE_1, NOTIONAL_TRS);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new PaymentDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION, FUNDING_FIXED_NTL_REC_DEFINITION }, LON);
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC_1 = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC_2 = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_2);
+  private static final EquityTotalReturnSwap TRS_PAY_FIXED_REC_1 = new EquityTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC_1, EQUITY_PAY,
+      NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  private static final EquityTotalReturnSwap TRS_PAY_FIXED_REC_2 = new EquityTotalReturnSwap(EFFECTIVE_TIME_2_1, TERMINATION_TIME_2_1, FUNDING_LEG_FIXED_REC_2, EQUITY_PAY,
+      NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  // Funding: unique fixed coupon in GBP: pay TRS bond, receive funding
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_PAY_DEFINITION = new CouponFixedDefinition(GBP,
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, -NOTIONAL_TRS, RATE);
+  private static final PaymentFixedDefinition FUNDING_FIXED_NTL_PAY_DEFINITION = new PaymentFixedDefinition(GBP, TERMINATION_DATE_1, -NOTIONAL_TRS);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_PAY_DEFINITION =
+      new AnnuityDefinition<>(new PaymentDefinition[] {FUNDING_FIXED_CPN_PAY_DEFINITION, FUNDING_FIXED_NTL_PAY_DEFINITION }, LON);
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_PAY_1 = FUNDING_LEG_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1);
+  private static final EquityTotalReturnSwap TRS_REC_FIXED_PAY_1 = new EquityTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_PAY_1, EQUITY_REC,
+      NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  // Funding: multiple USD Libor coupons
+  private static final Calendar NYC = new CalendarUSD("NYC");
+  private static final double SPREAD = 0.0010;
+  private static final IborIndex USDLIBOR3M = IndexIborMaster.getInstance().getIndex("USDLIBOR3M");
+  private static final Currency USD = USDLIBOR3M.getCurrency();
+  private static final AnnuityDefinition<CouponDefinition> FUNDING_LEG_IBOR_PAY_DEFINITION = AnnuityDefinitionBuilder.couponIborSpreadWithNotional(EFFECTIVE_DATE_2,
+      TERMINATION_DATE_2, NOTIONAL_TRS, SPREAD, USDLIBOR3M, USDLIBOR3M.getDayCount(), USDLIBOR3M.getBusinessDayConvention(), true, USDLIBOR3M.getTenor(),
+      USDLIBOR3M.isEndOfMonth(), NYC, StubType.SHORT_START, 0, false, true);
+  private static final Annuity<? extends Payment> FUNDING_LEG_IBOR_PAY_1 = FUNDING_LEG_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+  private static final EquityTotalReturnSwapDefinition TRS_REC_IBOR_PAY_DEFINITION = new EquityTotalReturnSwapDefinition(EFFECTIVE_DATE_2, TERMINATION_DATE_2,
+      FUNDING_LEG_IBOR_PAY_DEFINITION, EQUITY_DEFINITION_REC, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  private static final EquityTotalReturnSwap TRS_REC_IBOR_PAY_1_EFF = TRS_REC_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+
+  private static final EquityTotalReturnSwapDiscountingMethod METHOD_TRS_EQT = EquityTotalReturnSwapDiscountingMethod.getInstance();
+  private static final PresentValueDiscountingCalculator PVDC = PresentValueDiscountingCalculator.getInstance();
+  private static final PresentValueCurveSensitivityDiscountingCalculator PVCSDC = PresentValueCurveSensitivityDiscountingCalculator.getInstance();
+
+  private static final MulticurveProviderDiscount MULTICURVE = MulticurveProviderDiscountDataSets.createMulticurveGbpUsd();
+  private static final double EQUITY_PRICE = 1.234;
+  private static final EquityTrsDataBundle EQUITY_MULTICURVE = new EquityTrsDataBundle(EQUITY_PRICE, MULTICURVE);
+
+  private static final double TOLERANCE_PV = 1.0E-2;
+  private static final double TOLERANCE_PV_DELTA = 1.0E+2;
+
+  @Test
+  public void presentValueFixedSameCurrencyBeforeEffective() {
+    MultipleCurrencyAmount pvComputedPay = METHOD_TRS_EQT.presentValue(TRS_PAY_FIXED_REC_1, EQUITY_MULTICURVE);
+    assertEquals("EquityTotalReturnSwapDiscountingMethod: present value", 1, pvComputedPay.size()); // Bond and funding in same currency
+    assertTrue("EquityTotalReturnSwapDiscountingMethod: present value", pvComputedPay.getAmount(GBP) != 0.0);
+    MultipleCurrencyAmount pvEquity = MultipleCurrencyAmount.of(GBP, -NB_SHARES * EQUITY_PRICE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_FIXED_REC_1.accept(PVDC, MULTICURVE);
+    MultipleCurrencyAmount pvExpected = pvEquity.plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputedPay.getAmount(GBP), TOLERANCE_PV);
+    MultipleCurrencyAmount pvComputedRec = METHOD_TRS_EQT.presentValue(TRS_REC_FIXED_PAY_1, EQUITY_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", -pvComputedPay.getAmount(GBP), pvComputedRec.getAmount(GBP), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueFixedSameCurrencyAfterEffective() {
+    MultipleCurrencyAmount pvComputed = METHOD_TRS_EQT.presentValue(TRS_PAY_FIXED_REC_2, EQUITY_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", 1, pvComputed.size()); // Bond and funding in same currency
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputed.getAmount(GBP) != 0.0);
+    MultipleCurrencyAmount pvEquity = MultipleCurrencyAmount.of(GBP, -NB_SHARES * EQUITY_PRICE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_FIXED_REC_2.accept(PVDC, MULTICURVE);
+    MultipleCurrencyAmount pvExpected = pvEquity.plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputed.getAmount(GBP), TOLERANCE_PV); // Bond and funding in same currency
+  }
+
+  @Test
+  public void presentValueIborDiffCurrencyBeforeEffective() {
+    MultipleCurrencyAmount pvComputedRec = METHOD_TRS_EQT.presentValue(TRS_REC_IBOR_PAY_1_EFF, EQUITY_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", 2, pvComputedRec.size()); // Bond and funding in different currency
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputedRec.getAmount(GBP) != 0.0);
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputedRec.getAmount(USD) != 0.0);
+    MultipleCurrencyAmount pvEquity = MultipleCurrencyAmount.of(GBP, NB_SHARES * EQUITY_PRICE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_IBOR_PAY_1.accept(PVDC, MULTICURVE);
+    MultipleCurrencyAmount pvExpected = pvEquity.plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputedRec.getAmount(GBP), TOLERANCE_PV);
+    assertEquals("BondTRSDiscountingMethod: present value", pvFunding.getAmount(USD), pvComputedRec.getAmount(USD), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueLegs() {
+    MultipleCurrencyAmount pvEquityLegExpected = MultipleCurrencyAmount.of(GBP, NB_SHARES * EQUITY_PRICE);
+    MultipleCurrencyAmount pvEquityLegComputed = METHOD_TRS_EQT.presentValueAssetLeg(TRS_REC_IBOR_PAY_1_EFF, EQUITY_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", pvEquityLegExpected.getAmount(GBP), pvEquityLegComputed.getAmount(GBP), TOLERANCE_PV);
+    MultipleCurrencyAmount pvFundingLegExpected = TRS_REC_IBOR_PAY_1_EFF.getFundingLeg().accept(PVDC, MULTICURVE);
+    MultipleCurrencyAmount pvFundingLegComputed = METHOD_TRS_EQT.presentValueFundingLeg(TRS_REC_IBOR_PAY_1_EFF, EQUITY_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", pvFundingLegExpected.getAmount(USD), pvFundingLegComputed.getAmount(USD), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueCurveSensitivty() {
+    MultipleCurrencyMulticurveSensitivity pvcsComputed = METHOD_TRS_EQT.presentValueCurveSensitivity(TRS_REC_IBOR_PAY_1_EFF, EQUITY_MULTICURVE).cleaned();
+    MultipleCurrencyMulticurveSensitivity pvcsFundingLeg = TRS_REC_IBOR_PAY_1_EFF.getFundingLeg().accept(PVCSDC, MULTICURVE).cleaned();
+    AssertSensitivityObjects.assertEquals("BondTRSDiscountingMethod: present value curve senstivity",
+        pvcsFundingLeg.getSensitivity(USD), pvcsComputed.getSensitivity(USD), TOLERANCE_PV_DELTA);
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapTest.java
new file mode 100644
index 0000000..046267a
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/equity/trs/EquityTotalReturnSwapTest.java
@@ -0,0 +1,82 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.equity.trs;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.datasets.CalendarGBP;
+import com.opengamma.analytics.financial.equity.Equity;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.financial.legalentity.CreditRating;
+import com.opengamma.analytics.financial.legalentity.LegalEntity;
+import com.opengamma.analytics.financial.legalentity.Region;
+import com.opengamma.analytics.financial.legalentity.Sector;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.util.i18n.Country;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Tests related to the description of an equity total return swap.
+ */
+public class EquityTotalReturnSwapTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+  private static final double EFFECTIVE_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  private static final double TERMINATION_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+
+  private static final Currency GBP = Currency.GBP;
+  private static final Calendar LON = new CalendarGBP("LON");
+  private static final double NOTIONAL_TRS = 123456000;
+  // Equity
+  private static final double NB_SHARES = 1000000;
+  // Funding: unique fixed coupon in GBP: pay TRS equity, receive funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(GBP,
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new CouponFixedDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION }, LON);
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(EFFECTIVE_DATE_1);
+  private static final String OG_NAME = "OpenGamma Ltd";
+  private static final String OG_TICKER = "OG";
+  private static final LegalEntity OG_LEGAL_ENTITY = new LegalEntity(OG_TICKER, OG_NAME, Sets.newHashSet(CreditRating.of("AAA", "ABC", true)),
+      Sector.of("Technology"), Region.of("UK", Country.GB, Currency.GBP));
+  private static final Equity EQUITY = new Equity(OG_LEGAL_ENTITY, GBP, NB_SHARES);
+  private static final double DIVIDEND_RATIO = 1.0;
+  private static final EquityTotalReturnSwap TRS_PAY_FIXED_REC = new EquityTotalReturnSwap(EFFECTIVE_TIME_1_1,
+      TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC, EQUITY, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullFundingLeg() {
+    new EquityTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, null, EQUITY, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullUnderlyingEquity() {
+    new EquityTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC, null, NOTIONAL_TRS, GBP, DIVIDEND_RATIO);
+  }
+
+  @Test
+  public void getter() {
+    assertEquals("EquityTotalReturnSwapDefinition: getter", EFFECTIVE_TIME_1_1, TRS_PAY_FIXED_REC.getEffectiveTime());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", TERMINATION_TIME_1_1, TRS_PAY_FIXED_REC.getTerminationTime());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", FUNDING_LEG_FIXED_REC, TRS_PAY_FIXED_REC.getFundingLeg());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", EQUITY, TRS_PAY_FIXED_REC.getEquity());
+    assertEquals("EquityTotalReturnSwapDefinition: getter", DIVIDEND_RATIO, TRS_PAY_FIXED_REC.getDividendPercentage());
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/forex/calculator/ForexDerivativeVisitorTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/forex/calculator/ForexDerivativeVisitorTest.java
index a5395cb..3826a77 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/forex/calculator/ForexDerivativeVisitorTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/forex/calculator/ForexDerivativeVisitorTest.java
@@ -31,7 +31,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -41,6 +40,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorTest.java
index 599ebaf..6768373 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/InstrumentDefinitionVisitorTest.java
@@ -37,7 +37,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.definitio
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureSecurityDefinition;
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.definition.MetalFutureTransactionDefinition;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexDividendFutureDefinition;
 import com.opengamma.analytics.financial.equity.future.definition.EquityIndexFutureDefinition;
@@ -46,6 +45,7 @@ import com.opengamma.analytics.financial.equity.future.definition.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOptionDefinition;
 import com.opengamma.analytics.financial.equity.option.EquityOptionDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwapDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexDefinition;
 import com.opengamma.analytics.financial.forex.definition.ForexNonDeliverableForwardDefinition;
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondDataSets.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondDataSets.java
new file mode 100644
index 0000000..5869b37
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondDataSets.java
@@ -0,0 +1,68 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.instrument.bond;
+
+import org.threeten.bp.Period;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.analytics.financial.datasets.CalendarGBP;
+import com.opengamma.analytics.financial.provider.description.IssuerProviderDiscountDataSets;
+import com.opengamma.financial.convention.businessday.BusinessDayConvention;
+import com.opengamma.financial.convention.businessday.BusinessDayConventions;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.financial.convention.daycount.DayCount;
+import com.opengamma.financial.convention.daycount.DayCounts;
+import com.opengamma.financial.convention.yield.YieldConvention;
+import com.opengamma.financial.convention.yield.YieldConventionFactory;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Examples of bond futures to be used in tests.
+ */
+public class BondDataSets {
+
+  //UKT 5 09/07/14 - ISIN-GB0031829509
+  private static final String UK_GOVT_NAME = IssuerProviderDiscountDataSets.getIssuerNames()[3];
+  private static final String REPO_TYPE = "General collateral";
+  private static final Currency GBP = Currency.GBP;
+  private static final Period PAYMENT_TENOR_GILT = Period.ofMonths(6);
+  private static final Calendar CALENDAR_GILT = new CalendarGBP("LON");
+  private static final DayCount DAY_COUNT_GILT = DayCounts.ACT_ACT_ICMA;
+  private static final BusinessDayConvention BUSINESS_DAY_GILT = BusinessDayConventions.FOLLOWING;
+  private static final boolean IS_EOM_GILT = false;
+  private static final int SETTLEMENT_DAYS_GILT = 2;
+  private static final int EX_DIVIDEND_DAYS_GILT = 7;
+  private static final YieldConvention YIELD_CONVENTION_GILT = YieldConventionFactory.INSTANCE.getYieldConvention("UK:BUMP/DMO METHOD");
+  private static final Period BOND_TENOR_UK14 = Period.ofYears(12);
+  private static final ZonedDateTime START_ACCRUAL_DATE_UK14 = DateUtils.getUTCDate(2002, 9, 7);
+  private static final ZonedDateTime MATURITY_DATE_UK14 = START_ACCRUAL_DATE_UK14.plus(BOND_TENOR_UK14);
+  private static final double RATE_UK14 = 0.0500;
+  private static final double DEFAULT_NOTIONAL_UK14 = 1.0d;
+  private static final BondFixedSecurityDefinition BOND_SECURITY_DEFINITION_UK14 = BondFixedSecurityDefinition.from(GBP, MATURITY_DATE_UK14, START_ACCRUAL_DATE_UK14,
+      PAYMENT_TENOR_GILT, RATE_UK14, SETTLEMENT_DAYS_GILT, DEFAULT_NOTIONAL_UK14, EX_DIVIDEND_DAYS_GILT, CALENDAR_GILT, DAY_COUNT_GILT, BUSINESS_DAY_GILT, YIELD_CONVENTION_GILT, IS_EOM_GILT,
+      UK_GOVT_NAME, REPO_TYPE);
+
+  /**
+   * Returns the definition of the UKT 5 09/07/14 - ISIN-GB0031829509 bond security.
+   * Default notional of 1.
+   * @return The bond.
+   */
+  public static BondFixedSecurityDefinition bondUKT5_20140907() {
+    return BOND_SECURITY_DEFINITION_UK14;
+  }
+
+  /**
+   * Returns the definition of the UKT 5 09/07/14 - ISIN-GB0031829509 bond security.
+   * @param notional The bond notional.
+   * @return The bond.
+   */
+  public static BondFixedSecurityDefinition bondUKT5_20140907(double notional) {
+    return BondFixedSecurityDefinition.from(GBP, MATURITY_DATE_UK14, START_ACCRUAL_DATE_UK14, PAYMENT_TENOR_GILT, RATE_UK14, SETTLEMENT_DAYS_GILT,
+        notional, EX_DIVIDEND_DAYS_GILT, CALENDAR_GILT, DAY_COUNT_GILT, BUSINESS_DAY_GILT, YIELD_CONVENTION_GILT, IS_EOM_GILT, UK_GOVT_NAME, REPO_TYPE);
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinitionTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinitionTest.java
new file mode 100644
index 0000000..65ce3e2
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/bond/BondTotalReturnSwapDefinitionTest.java
@@ -0,0 +1,161 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.instrument.bond;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.analytics.financial.datasets.CalendarUSD;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinitionBuilder;
+import com.opengamma.analytics.financial.instrument.index.IborIndex;
+import com.opengamma.analytics.financial.instrument.index.IndexIborMaster;
+import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedSecurity;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.financial.convention.StubType;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.timeseries.precise.zdt.ImmutableZonedDateTimeDoubleTimeSeries;
+import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Test related to the description of a bond total return swap with an underlying bond and a funding leg.
+ */
+public class BondTotalReturnSwapDefinitionTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+
+  private static final double NOTIONAL_TRS = 123456000;
+  // Bond (UKT)
+  private static final double NOTIONAL_BND = 100000000;
+  private static final BondFixedSecurityDefinition UKT14_DEFINITION = BondDataSets.bondUKT5_20140907();
+  // Funding: unique fixed coupon in GBP: pay TRS bond, receive funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(UKT14_DEFINITION.getCurrency(),
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new CouponFixedDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION }, UKT14_DEFINITION.getCalendar());
+  private static final BondTotalReturnSwapDefinition TRS_PAY_FIXED_REC_DEFINITION =
+      new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, FUNDING_LEG_FIXED_REC_DEFINITION, UKT14_DEFINITION, -NOTIONAL_BND);
+  // Funding: unique fixed coupon in GBP: receive TRS bond, pay funding
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_PAY_DEFINITION = new CouponFixedDefinition(UKT14_DEFINITION.getCurrency(),
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, -NOTIONAL_TRS, RATE);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_PAY_DEFINITION =
+      new AnnuityDefinition<>(new CouponFixedDefinition[] {FUNDING_FIXED_CPN_PAY_DEFINITION }, UKT14_DEFINITION.getCalendar());
+  private static final BondTotalReturnSwapDefinition TRS_REC_FIXED_PAY_DEFINITION =
+      new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, FUNDING_LEG_FIXED_PAY_DEFINITION, UKT14_DEFINITION, NOTIONAL_BND);
+  // Funding: multiple USD Libor coupons
+  private static final Calendar NYC = new CalendarUSD("NYC");
+  private static final double SPREAD = 0.0010;
+  private static final ZonedDateTime TERMINATION_DATE_2 = DateUtils.getUTCDate(2012, 8, 9);
+  private static final IborIndex USDLIBOR1M = IndexIborMaster.getInstance().getIndex("USDLIBOR1M");
+  private static final AnnuityDefinition<CouponDefinition> FUNDING_LEG_IBOR_PAY_DEFINITION = AnnuityDefinitionBuilder.couponIborSpreadWithNotional(EFFECTIVE_DATE_1,
+      TERMINATION_DATE_2, NOTIONAL_TRS, SPREAD, USDLIBOR1M, USDLIBOR1M.getDayCount(), USDLIBOR1M.getBusinessDayConvention(), true, USDLIBOR1M.getTenor(),
+      USDLIBOR1M.isEndOfMonth(), NYC, StubType.SHORT_START, 0, false, true);
+  private static final BondTotalReturnSwapDefinition TRS_REC_IBOR_PAY_DEFINITION =
+      new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_2, FUNDING_LEG_IBOR_PAY_DEFINITION, UKT14_DEFINITION, NOTIONAL_BND);
+
+  private static final ZonedDateTime[] FIXING_DATES = new ZonedDateTime[] {DateUtils.getUTCDate(2012, 2, 7), DateUtils.getUTCDate(2012, 2, 8), DateUtils.getUTCDate(2012, 2, 9) };
+  private static final double[] FIXING_RATES = new double[] {0.0040, 0.0041, 0.0042 };
+  private static final ZonedDateTimeDoubleTimeSeries FIXING_TS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(FIXING_DATES, FIXING_RATES);
+
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+  private static final ZonedDateTime REFERENCE_DATE_2 = DateUtils.getUTCDate(2012, 2, 16); // After effective date.
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullEffectiveDate() {
+    new BondTotalReturnSwapDefinition(null, TERMINATION_DATE_1, FUNDING_LEG_FIXED_PAY_DEFINITION, UKT14_DEFINITION, NOTIONAL_BND);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullTerminationDate() {
+    new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, null, FUNDING_LEG_FIXED_PAY_DEFINITION, UKT14_DEFINITION, NOTIONAL_BND);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullFundingLeg() {
+    new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, null, UKT14_DEFINITION, NOTIONAL_BND);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullUnderlyingBond() {
+    new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_1, TERMINATION_DATE_1, FUNDING_LEG_FIXED_PAY_DEFINITION, null, NOTIONAL_BND);
+  }
+
+  @Test
+  public void getter() {
+    assertEquals("BondTotalReturnSwapDefinition: getter", EFFECTIVE_DATE_1, TRS_REC_FIXED_PAY_DEFINITION.getEffectiveDate());
+    assertEquals("BondTotalReturnSwapDefinition: getter", TERMINATION_DATE_1, TRS_REC_FIXED_PAY_DEFINITION.getTerminationDate());
+    assertEquals("BondTotalReturnSwapDefinition: getter", FUNDING_LEG_FIXED_PAY_DEFINITION, TRS_REC_FIXED_PAY_DEFINITION.getFundingLeg());
+    assertEquals("BondTotalReturnSwapDefinition: getter", UKT14_DEFINITION, TRS_REC_FIXED_PAY_DEFINITION.getAsset());
+    assertEquals("BondTotalReturnSwapDefinition: getter", NOTIONAL_BND, TRS_REC_FIXED_PAY_DEFINITION.getQuantity());
+  }
+
+  @Test
+  public void toDerivativeFixedRecBeforeEffectiveDate() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    BondFixedSecurity bond = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    BondTotalReturnSwap trsExpected = new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, NOTIONAL_BND);
+    BondTotalReturnSwap trsConverted = TRS_REC_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+  @Test
+  public void toDerivativeFixedPayBeforeEffectiveDate() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    BondFixedSecurity bond = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    BondTotalReturnSwap trsExpected = new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, -NOTIONAL_BND);
+    BondTotalReturnSwap trsConverted = TRS_PAY_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+  @Test
+  public void toDerivativeFixedAfterEffectiveDate() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, TERMINATION_DATE_1);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_2);
+    BondFixedSecurity bond = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+    BondTotalReturnSwap trsExpected = new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, NOTIONAL_BND);
+    BondTotalReturnSwap trsConverted = TRS_REC_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_2);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+  @Test
+  public void toDerivativeIborBeforeEffectiveDate() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_2);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+    BondFixedSecurity bond = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+    BondTotalReturnSwap trsExpected = new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, NOTIONAL_BND);
+    BondTotalReturnSwap trsConverted = TRS_REC_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+  @Test
+  public void toDerivativeIborAfterEffectiveDate() {
+    double effectiveTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+    double terminationTime = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, TERMINATION_DATE_2);
+    Annuity<? extends Payment> fundingLeg = FUNDING_LEG_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_2, FIXING_TS);
+    BondFixedSecurity bond = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+    BondTotalReturnSwap trsExpected = new BondTotalReturnSwap(effectiveTime, terminationTime, fundingLeg, bond, NOTIONAL_BND);
+    BondTotalReturnSwap trsConverted = TRS_REC_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_2, FIXING_TS);
+    assertEquals("BondTotalReturnSwapDefinition: toDerivative", trsExpected, trsConverted);
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/future/BondFuturesDataSets.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/future/BondFuturesDataSets.java
index b7a5d97..3b00773 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/future/BondFuturesDataSets.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/future/BondFuturesDataSets.java
@@ -21,6 +21,9 @@ import com.opengamma.financial.convention.yield.YieldConventionFactory;
 import com.opengamma.util.money.Currency;
 import com.opengamma.util.time.DateUtils;
 
+/**
+ * Examples of bond futures to be used in tests.
+ */
 public class BondFuturesDataSets {
 
   // Bond futures: Bobl June 14
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinitionTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinitionTest.java
index dcfe975..60ba750 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinitionTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/volatilityswap/FXVolatilitySwapDefinitionTest.java
@@ -60,7 +60,7 @@ public class FXVolatilitySwapDefinitionTest extends AnalyticsTestBase {
     super(FXVolatilitySwapDefinition.class,
         new Object[] {CCY, BASE, COUNTER, VOL_STRIKE, VOL_NOTIONAL, T_PLUS_2D, T_PLUS_5Y, NOW, T_PLUS_5Y, OBSERVATION_FREQUENCY, OBS_PER_YEAR, WEEKENDS },
         new Class[] {Currency.class, Currency.class, Currency.class, double.class, double.class,
-          ZonedDateTime.class, ZonedDateTime.class, ZonedDateTime.class, ZonedDateTime.class, PeriodFrequency.class, double.class, Calendar.class },
+            ZonedDateTime.class, ZonedDateTime.class, ZonedDateTime.class, ZonedDateTime.class, PeriodFrequency.class, double.class, Calendar.class },
         new boolean[] {true, true, true, false, false, true, true, true, true, true, false, true });
   }
 
@@ -140,11 +140,11 @@ public class FXVolatilitySwapDefinitionTest extends AnalyticsTestBase {
     final FXVolatilitySwap volatilitySwap = DEFINITION.toDerivative(NOW);
     assertEquals(OBS_PER_YEAR, volatilitySwap.getAnnualizationFactor());
     assertEquals(CCY, volatilitySwap.getCurrency());
-    assertEquals(5, volatilitySwap.getTimeToObservationEnd(), 0);
-    assertEquals(2. / 365, volatilitySwap.getTimeToObservationStart(), 0);
+    assertEquals(5.174603174603175, volatilitySwap.getTimeToObservationEnd(), 1.e-12);
+    assertEquals(1. / 252, volatilitySwap.getTimeToObservationStart(), 0);
     assertEquals(OBSERVATION_FREQUENCY, volatilitySwap.getObservationFrequency());
-    assertEquals(5, volatilitySwap.getTimeToMaturity(), 0);
-    assertEquals(VOL_NOTIONAL, volatilitySwap.getVolatilityNotional(), 0);
+    assertEquals(5.174603174603175, volatilitySwap.getTimeToMaturity(), 1.e-12);
+    assertEquals(VOL_NOTIONAL, volatilitySwap.getVolatilityNotional(), 1.e-12);
     assertEquals(VOL_STRIKE, volatilitySwap.getVolatilityStrike());
     assertEquals(volatilitySwap, DEFINITION.toDerivative(NOW));
     assertEquals(volatilitySwap, DEFINITION.toDerivative(NOW, "A", "B"));
@@ -163,10 +163,10 @@ public class FXVolatilitySwapDefinitionTest extends AnalyticsTestBase {
     final FXVolatilitySwap volatilitySwap = definition.toDerivative(NOW.plusYears(1));
     assertEquals(OBS_PER_YEAR, volatilitySwap.getAnnualizationFactor());
     assertEquals(CCY, volatilitySwap.getCurrency());
-    assertEquals(4, volatilitySwap.getTimeToObservationEnd(), 0);
-    assertEquals(-1 + 2 / 365., volatilitySwap.getTimeToObservationStart(), 0);
+    assertEquals(5.7976190476190474, volatilitySwap.getTimeToObservationEnd(), 1.e-12);
+    assertEquals(-1.4404761904761905, volatilitySwap.getTimeToObservationStart(), 1.e-12);
     assertEquals(OBSERVATION_FREQUENCY, volatilitySwap.getObservationFrequency());
-    assertEquals(4, volatilitySwap.getTimeToMaturity(), 0);
+    assertEquals(5.7976190476190474, volatilitySwap.getTimeToMaturity(), 1.e-12);
     assertEquals(VOL_NOTIONAL, volatilitySwap.getVolatilityNotional());
     assertEquals(VOL_STRIKE, volatilitySwap.getVolatilityStrike(), 0);
     assertEquals(volatilitySwap, definition.toDerivative(NOW.plusYears(1), "A", "B"));
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorTest.java
index e035ef3..91f8b97 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentDerivativeVisitorTest.java
@@ -34,7 +34,6 @@ import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivativ
 import com.opengamma.analytics.financial.commodity.multicurvecommodity.derivative.MetalFutureTransaction;
 import com.opengamma.analytics.financial.credit.cds.ISDACDSDerivative;
 import com.opengamma.analytics.financial.equity.Equity;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.future.derivative.CashSettledFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityFuture;
 import com.opengamma.analytics.financial.equity.future.derivative.EquityIndexDividendFuture;
@@ -44,6 +43,7 @@ import com.opengamma.analytics.financial.equity.future.derivative.VolatilityInde
 import com.opengamma.analytics.financial.equity.option.EquityIndexFutureOption;
 import com.opengamma.analytics.financial.equity.option.EquityIndexOption;
 import com.opengamma.analytics.financial.equity.option.EquityOption;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.variance.EquityVarianceSwap;
 import com.opengamma.analytics.financial.forex.derivative.Forex;
 import com.opengamma.analytics.financial.forex.derivative.ForexNonDeliverableForward;
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwapTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwapTest.java
new file mode 100644
index 0000000..7b90793
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/definition/BondTotalReturnSwapTest.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.interestrate.bond.definition;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.bond.BondDataSets;
+import com.opengamma.analytics.financial.instrument.bond.BondFixedSecurityDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.util.time.DateUtils;
+
+/**
+ * Test related to the description of a bond total return swap with an underlying bond and a funding leg.
+ */
+public class BondTotalReturnSwapTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+
+  private static final double EFFECTIVE_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  private static final double TERMINATION_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+
+  private static final double NOTIONAL_TRS = 123456000;
+  // Bond (UKT)
+  private static final double NOTIONAL_BND = 100000000;
+  private static final BondFixedSecurityDefinition UKT14_DEFINITION = BondDataSets.bondUKT5_20140907();
+  private static final BondFixedSecurity UKT14_1_1 = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  // Funding: unique fixed coupon in GBP: receive TRS bond, pay funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(UKT14_DEFINITION.getCurrency(),
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new CouponFixedDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION }, UKT14_DEFINITION.getCalendar());
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC_1 = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+  private static final BondTotalReturnSwap TRS_PAY_FIXED_REC_1 = new BondTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC_1, UKT14_1_1, -NOTIONAL_BND);
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullFundingLeg() {
+    new BondTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, null, UKT14_1_1, -NOTIONAL_BND);
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullBond() {
+    new BondTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC_1, null, -NOTIONAL_BND);
+  }
+
+  @Test
+  public void getter() {
+    assertEquals("BondTotalReturnSwap: getter", EFFECTIVE_TIME_1_1, TRS_PAY_FIXED_REC_1.getEffectiveTime());
+    assertEquals("BondTotalReturnSwap: getter", TERMINATION_TIME_1_1, TRS_PAY_FIXED_REC_1.getTerminationTime());
+    assertEquals("BondTotalReturnSwap: getter", FUNDING_LEG_FIXED_REC_1, TRS_PAY_FIXED_REC_1.getFundingLeg());
+    assertEquals("BondTotalReturnSwap: getter", UKT14_1_1, TRS_PAY_FIXED_REC_1.getAsset());
+    assertEquals("BondTotalReturnSwap: getter", -NOTIONAL_BND, TRS_PAY_FIXED_REC_1.getQuantity());
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BillTransactionDiscountingMethodTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BillTransactionDiscountingMethodTest.java
index 7459f3e..ee851e9 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BillTransactionDiscountingMethodTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BillTransactionDiscountingMethodTest.java
@@ -77,7 +77,7 @@ public class BillTransactionDiscountingMethodTest {
 
   private final static PresentValueIssuerCalculator PVIC = PresentValueIssuerCalculator.getInstance();
   private final static PresentValueCurveSensitivityIssuerCalculator PVCSIC = PresentValueCurveSensitivityIssuerCalculator.getInstance();
-  private static final ParameterSensitivityIssuerCalculator<ParameterIssuerProviderInterface> PS_PVI_C = new ParameterSensitivityIssuerCalculator<ParameterIssuerProviderInterface>(PVCSIC);
+  private static final ParameterSensitivityIssuerCalculator<ParameterIssuerProviderInterface> PS_PVI_C = new ParameterSensitivityIssuerCalculator<>(PVCSIC);
   private static final ParameterSensitivityIssuerDiscountInterpolatedFDCalculator PS_PVI_FDC = new ParameterSensitivityIssuerDiscountInterpolatedFDCalculator(PVIC, SHIFT_FD);
 
   private final static ParSpreadMarketQuoteIssuerDiscountingCalculator PSMQIDC = ParSpreadMarketQuoteIssuerDiscountingCalculator.getInstance();
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethodTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethodTest.java
new file mode 100644
index 0000000..cc6efab
--- /dev/null
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTotalReturnSwapDiscountingMethodTest.java
@@ -0,0 +1,208 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.analytics.financial.interestrate.bond.provider;
+
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
+import static org.testng.AssertJUnit.assertTrue;
+
+import org.testng.annotations.Test;
+import org.threeten.bp.ZonedDateTime;
+
+import com.opengamma.analytics.financial.datasets.CalendarUSD;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
+import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinitionBuilder;
+import com.opengamma.analytics.financial.instrument.bond.BondDataSets;
+import com.opengamma.analytics.financial.instrument.bond.BondFixedSecurityDefinition;
+import com.opengamma.analytics.financial.instrument.bond.BondTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.instrument.index.IborIndex;
+import com.opengamma.analytics.financial.instrument.index.IndexIborMaster;
+import com.opengamma.analytics.financial.instrument.payment.CouponDefinition;
+import com.opengamma.analytics.financial.instrument.payment.CouponFixedDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
+import com.opengamma.analytics.financial.instrument.payment.PaymentFixedDefinition;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
+import com.opengamma.analytics.financial.interestrate.annuity.derivative.Annuity;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondFixedSecurity;
+import com.opengamma.analytics.financial.interestrate.bond.definition.BondTotalReturnSwap;
+import com.opengamma.analytics.financial.interestrate.payments.derivative.Payment;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PV01CurveParametersCalculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueCurveSensitivityIssuerCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueIssuerCalculator;
+import com.opengamma.analytics.financial.provider.description.IssuerProviderDiscountDataSets;
+import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderDiscount;
+import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyMulticurveSensitivity;
+import com.opengamma.analytics.financial.util.AssertSensitivityObjects;
+import com.opengamma.analytics.util.amount.ReferenceAmount;
+import com.opengamma.analytics.util.time.TimeCalculator;
+import com.opengamma.financial.convention.StubType;
+import com.opengamma.financial.convention.calendar.Calendar;
+import com.opengamma.timeseries.precise.zdt.ImmutableZonedDateTimeDoubleTimeSeries;
+import com.opengamma.timeseries.precise.zdt.ZonedDateTimeDoubleTimeSeries;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+import com.opengamma.util.time.DateUtils;
+import com.opengamma.util.tuple.Pair;
+
+/**
+ * Test related to the bond total return swap pricing methodology by discounting of the cash-flows.
+ */
+public class BondTotalReturnSwapDiscountingMethodTest {
+
+  private static final ZonedDateTime EFFECTIVE_DATE_1 = DateUtils.getUTCDate(2012, 2, 9);
+  private static final ZonedDateTime EFFECTIVE_DATE_2 = DateUtils.getUTCDate(2012, 3, 9);
+  private static final ZonedDateTime TERMINATION_DATE_1 = DateUtils.getUTCDate(2012, 5, 9);
+  private static final ZonedDateTime TERMINATION_DATE_2 = DateUtils.getUTCDate(2012, 9, 9);
+
+  private static final ZonedDateTime REFERENCE_DATE_1 = DateUtils.getUTCDate(2012, 2, 2); // Before effective date.
+  private static final ZonedDateTime REFERENCE_DATE_2 = DateUtils.getUTCDate(2012, 2, 16); // After effective date 1.
+
+  private static final double EFFECTIVE_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  private static final double EFFECTIVE_TIME_2_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+  private static final double EFFECTIVE_TIME_1_2 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, EFFECTIVE_DATE_2);
+  private static final double TERMINATION_TIME_1_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_1);
+  private static final double TERMINATION_TIME_1_2 = TimeCalculator.getTimeBetween(REFERENCE_DATE_1, TERMINATION_DATE_2);
+  private static final double TERMINATION_TIME_2_1 = TimeCalculator.getTimeBetween(REFERENCE_DATE_2, TERMINATION_DATE_1);
+
+  private static final ZonedDateTime[] FIXING_DATES = new ZonedDateTime[] {DateUtils.getUTCDate(2012, 2, 7), DateUtils.getUTCDate(2012, 2, 8),
+    DateUtils.getUTCDate(2012, 2, 9), DateUtils.getUTCDate(2012, 3, 7) };
+  private static final double[] FIXING_RATES = new double[] {0.0040, 0.0041, 0.0042, 0.0043 };
+  private static final ZonedDateTimeDoubleTimeSeries FIXING_TS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(FIXING_DATES, FIXING_RATES);
+
+  private static final double NOTIONAL_TRS = 123456000;
+  // Bond (UKT)
+  private static final double NOTIONAL_BND = 100000000;
+  private static final BondFixedSecurityDefinition UKT14_DEFINITION = BondDataSets.bondUKT5_20140907();
+  private static final BondFixedSecurity UKT14_1_1 = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_1);
+  private static final BondFixedSecurity UKT14_1_2 = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_1, EFFECTIVE_DATE_2);
+  private static final BondFixedSecurity UKT14_2_1 = UKT14_DEFINITION.toDerivative(REFERENCE_DATE_2, EFFECTIVE_DATE_1);
+  private static final Currency GBP = UKT14_DEFINITION.getCurrency();
+  // Funding: unique fixed coupon in GBP: receive TRS bond, pay funding
+  private static final double RATE = 0.0043;
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_REC_DEFINITION = new CouponFixedDefinition(UKT14_DEFINITION.getCurrency(),
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, NOTIONAL_TRS, RATE);
+  private static final PaymentFixedDefinition FUNDING_FIXED_NTL_REC_DEFINITION = new PaymentFixedDefinition(GBP, TERMINATION_DATE_1, NOTIONAL_TRS);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_REC_DEFINITION =
+      new AnnuityDefinition<>(new PaymentDefinition[] {FUNDING_FIXED_CPN_REC_DEFINITION, FUNDING_FIXED_NTL_REC_DEFINITION }, UKT14_DEFINITION.getCalendar());
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC_1 = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_1);
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_REC_2 = FUNDING_LEG_FIXED_REC_DEFINITION.toDerivative(REFERENCE_DATE_2);
+  private static final BondTotalReturnSwap TRS_PAY_FIXED_REC_1 = new BondTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_REC_1, UKT14_1_1, -NOTIONAL_BND);
+  private static final BondTotalReturnSwap TRS_PAY_FIXED_REC_2 = new BondTotalReturnSwap(EFFECTIVE_TIME_2_1, TERMINATION_TIME_2_1, FUNDING_LEG_FIXED_REC_2, UKT14_2_1, -NOTIONAL_BND);
+  // Funding: unique fixed coupon in GBP: pay TRS bond, receive funding
+  private static final CouponFixedDefinition FUNDING_FIXED_CPN_PAY_DEFINITION = new CouponFixedDefinition(UKT14_DEFINITION.getCurrency(),
+      TERMINATION_DATE_1, EFFECTIVE_DATE_1, TERMINATION_DATE_1, 0.25, -NOTIONAL_TRS, RATE);
+  private static final PaymentFixedDefinition FUNDING_FIXED_NTL_PAY_DEFINITION = new PaymentFixedDefinition(GBP, TERMINATION_DATE_1, -NOTIONAL_TRS);
+  private static final AnnuityDefinition<? extends PaymentDefinition> FUNDING_LEG_FIXED_PAY_DEFINITION =
+      new AnnuityDefinition<>(new PaymentDefinition[] {FUNDING_FIXED_CPN_PAY_DEFINITION, FUNDING_FIXED_NTL_PAY_DEFINITION }, UKT14_DEFINITION.getCalendar());
+  private static final Annuity<? extends Payment> FUNDING_LEG_FIXED_PAY_1 = FUNDING_LEG_FIXED_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1);
+  private static final BondTotalReturnSwap TRS_REC_FIXED_PAY_1 = new BondTotalReturnSwap(EFFECTIVE_TIME_1_1, TERMINATION_TIME_1_1, FUNDING_LEG_FIXED_PAY_1, UKT14_1_1, NOTIONAL_BND);
+  // Funding: multiple USD Libor coupons
+  private static final Calendar NYC = new CalendarUSD("NYC");
+  private static final double SPREAD = 0.0010;
+  private static final IborIndex USDLIBOR1M = IndexIborMaster.getInstance().getIndex("USDLIBOR1M");
+  private static final Currency USD = USDLIBOR1M.getCurrency();
+  private static final AnnuityDefinition<CouponDefinition> FUNDING_LEG_IBOR_PAY_DEFINITION = AnnuityDefinitionBuilder.couponIborSpreadWithNotional(EFFECTIVE_DATE_2,
+      TERMINATION_DATE_2, NOTIONAL_TRS, SPREAD, USDLIBOR1M, USDLIBOR1M.getDayCount(), USDLIBOR1M.getBusinessDayConvention(), true, USDLIBOR1M.getTenor(),
+      USDLIBOR1M.isEndOfMonth(), NYC, StubType.SHORT_START, 0, false, true);
+  private static final Annuity<? extends Payment> FUNDING_LEG_IBOR_PAY_1 = FUNDING_LEG_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+  private static final BondTotalReturnSwapDefinition TRS_REC_IBOR_PAY_DEFINITION = new BondTotalReturnSwapDefinition(EFFECTIVE_DATE_2, TERMINATION_DATE_2,
+      FUNDING_LEG_IBOR_PAY_DEFINITION, UKT14_DEFINITION, NOTIONAL_BND);
+  private static final BondTotalReturnSwap TRS_REC_IBOR_PAY_1_STD = new BondTotalReturnSwap(EFFECTIVE_TIME_1_2, TERMINATION_TIME_1_2, FUNDING_LEG_IBOR_PAY_1, UKT14_1_1, NOTIONAL_BND);
+  private static final BondTotalReturnSwap TRS_REC_IBOR_PAY_1_EFF = TRS_REC_IBOR_PAY_DEFINITION.toDerivative(REFERENCE_DATE_1, FIXING_TS);
+
+  private static final BondTotalReturnSwapDiscountingMethod METHOD_TRS_BND = BondTotalReturnSwapDiscountingMethod.getInstance();
+  private static final PresentValueIssuerCalculator PVIC = PresentValueIssuerCalculator.getInstance();
+  private static final PresentValueCurveSensitivityIssuerCalculator PVCSIC = PresentValueCurveSensitivityIssuerCalculator.getInstance();
+  private static final InstrumentDerivativeVisitor<ParameterIssuerProviderInterface, ReferenceAmount<Pair<String, Currency>>> PV01C =
+      new PV01CurveParametersCalculator<>(PVCSIC);
+  private static final PresentValueDiscountingCalculator PVDC = PresentValueDiscountingCalculator.getInstance();
+
+  private static final IssuerProviderDiscount ISSUER_MULTICURVE = IssuerProviderDiscountDataSets.getIssuerSpecificProvider();
+
+  private static final double TOLERANCE_PV = 1.0E-2;
+  private static final double TOLERANCE_PV_DELTA = 1.0E+2;
+
+  @Test
+  public void presentValueFixedSameCurrencyBeforeEffective() {
+    MultipleCurrencyAmount pvComputedPay = METHOD_TRS_BND.presentValue(TRS_PAY_FIXED_REC_1, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", 1, pvComputedPay.size()); // Bond and funding in same currency
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputedPay.getAmount(GBP) != 0.0);
+    MultipleCurrencyAmount pvBondUnit = UKT14_1_1.accept(PVIC, ISSUER_MULTICURVE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_FIXED_REC_1.accept(PVDC, ISSUER_MULTICURVE.getMulticurveProvider());
+    MultipleCurrencyAmount pvExpected = pvBondUnit.multipliedBy(-NOTIONAL_BND).plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputedPay.getAmount(GBP), TOLERANCE_PV);
+    MultipleCurrencyAmount pvComputedRec = METHOD_TRS_BND.presentValue(TRS_REC_FIXED_PAY_1, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", -pvComputedPay.getAmount(GBP), pvComputedRec.getAmount(GBP), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueFixedSameCurrencyAfterEffective() {
+    MultipleCurrencyAmount pvComputed = METHOD_TRS_BND.presentValue(TRS_PAY_FIXED_REC_2, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", 1, pvComputed.size()); // Bond and funding in same currency
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputed.getAmount(GBP) != 0.0);
+    MultipleCurrencyAmount pvBondUnit = UKT14_2_1.accept(PVIC, ISSUER_MULTICURVE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_FIXED_REC_2.accept(PVDC, ISSUER_MULTICURVE.getMulticurveProvider());
+    MultipleCurrencyAmount pvExpected = pvBondUnit.multipliedBy(-NOTIONAL_BND).plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputed.getAmount(GBP), TOLERANCE_PV); // Bond and funding in same currency
+  }
+
+  @Test
+  public void presentValueIborDiffCurrencyBeforeEffective() {
+    MultipleCurrencyAmount pvComputedRec = METHOD_TRS_BND.presentValue(TRS_REC_IBOR_PAY_1_EFF, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", 2, pvComputedRec.size()); // Bond and funding in different currency
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputedRec.getAmount(GBP) != 0.0);
+    assertTrue("BondTRSDiscountingMethod: present value", pvComputedRec.getAmount(USD) != 0.0);
+    MultipleCurrencyAmount pvBondUnit = UKT14_1_2.accept(PVIC, ISSUER_MULTICURVE);
+    MultipleCurrencyAmount pvFunding = FUNDING_LEG_IBOR_PAY_1.accept(PVDC, ISSUER_MULTICURVE.getMulticurveProvider());
+    MultipleCurrencyAmount pvExpected = pvBondUnit.multipliedBy(NOTIONAL_BND).plus(pvFunding);
+    assertEquals("BondTRSDiscountingMethod: present value", pvExpected.getAmount(GBP), pvComputedRec.getAmount(GBP), TOLERANCE_PV);
+    assertEquals("BondTRSDiscountingMethod: present value", pvFunding.getAmount(USD), pvComputedRec.getAmount(USD), TOLERANCE_PV);
+    // Check that the coupon not in the effective period is not taken into account
+    MultipleCurrencyAmount pvComputedRecStd = METHOD_TRS_BND.presentValue(TRS_REC_IBOR_PAY_1_STD, ISSUER_MULTICURVE);
+    assertFalse("", Math.abs(pvComputedRec.getAmount(GBP) - pvComputedRecStd.getAmount(GBP)) < TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueLegs() {
+    MultipleCurrencyAmount pvBondLegExpected = TRS_REC_IBOR_PAY_1_EFF.getAsset().accept(PVIC, ISSUER_MULTICURVE).multipliedBy(NOTIONAL_BND);
+    MultipleCurrencyAmount pvBondLegComputed = METHOD_TRS_BND.presentValueAssetLeg(TRS_REC_IBOR_PAY_1_EFF, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", pvBondLegExpected.getAmount(GBP), pvBondLegComputed.getAmount(GBP), TOLERANCE_PV);
+    MultipleCurrencyAmount pvFundingLegExpected = TRS_REC_IBOR_PAY_1_EFF.getFundingLeg().accept(PVDC, ISSUER_MULTICURVE.getMulticurveProvider());
+    MultipleCurrencyAmount pvFundingLegComputed = METHOD_TRS_BND.presentValueFundingLeg(TRS_REC_IBOR_PAY_1_EFF, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", pvFundingLegExpected.getAmount(USD), pvFundingLegComputed.getAmount(USD), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueMethodVsCalculator() {
+    MultipleCurrencyAmount pvMethod = METHOD_TRS_BND.presentValue(TRS_REC_IBOR_PAY_1_EFF, ISSUER_MULTICURVE);
+    MultipleCurrencyAmount pvCalculator = TRS_REC_IBOR_PAY_1_EFF.accept(PVIC, ISSUER_MULTICURVE);
+    assertEquals("BondTRSDiscountingMethod: present value", pvMethod.getAmount(GBP), pvCalculator.getAmount(GBP), TOLERANCE_PV);
+    assertEquals("BondTRSDiscountingMethod: present value", pvMethod.getAmount(USD), pvCalculator.getAmount(USD), TOLERANCE_PV);
+  }
+
+  @Test
+  public void presentValueCurveSensitivty() {
+    MultipleCurrencyMulticurveSensitivity pvcsComputed = METHOD_TRS_BND.presentValueCurveSensitivity(TRS_REC_IBOR_PAY_1_EFF, ISSUER_MULTICURVE).cleaned();
+    MultipleCurrencyMulticurveSensitivity pvcsFundingLeg = TRS_REC_IBOR_PAY_1_EFF.getFundingLeg().accept(PVCSIC, ISSUER_MULTICURVE).cleaned();
+    AssertSensitivityObjects.assertEquals("BondTRSDiscountingMethod: present value curve senstivity",
+        pvcsFundingLeg.getSensitivity(USD), pvcsComputed.getSensitivity(USD), TOLERANCE_PV_DELTA);
+    MultipleCurrencyMulticurveSensitivity pvcsBondLeg = TRS_REC_IBOR_PAY_1_EFF.getAsset().accept(PVCSIC, ISSUER_MULTICURVE).multipliedBy(NOTIONAL_BND).cleaned();
+    AssertSensitivityObjects.assertEquals("BondTRSDiscountingMethod: present value curve senstivity",
+        pvcsBondLeg.getSensitivity(GBP), pvcsComputed.getSensitivity(GBP), TOLERANCE_PV_DELTA);
+  }
+
+  @Test
+  public void pv01() {
+    ReferenceAmount<Pair<String, Currency>> pv01Computed = TRS_REC_IBOR_PAY_1_EFF.accept(PV01C, ISSUER_MULTICURVE);
+    ReferenceAmount<Pair<String, Currency>> pv01Funding = TRS_REC_IBOR_PAY_1_EFF.getFundingLeg().accept(PV01C, ISSUER_MULTICURVE);
+    ReferenceAmount<Pair<String, Currency>> pv01Bond = TRS_REC_IBOR_PAY_1_EFF.getAsset().accept(PV01C, ISSUER_MULTICURVE);
+    @SuppressWarnings("unused")
+    int t = 0;
+  }
+
+}
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTransactionDiscountingMethodTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTransactionDiscountingMethodTest.java
index e3de351..b9c2f8b 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTransactionDiscountingMethodTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondTransactionDiscountingMethodTest.java
@@ -169,7 +169,7 @@ public class BondTransactionDiscountingMethodTest {
   private static final double SHIFT_FD = 1.0E-6;
 
   private static final SimpleParameterSensitivityIssuerCalculator<ParameterIssuerProviderInterface> PS_I_AD =
-      new SimpleParameterSensitivityIssuerCalculator<ParameterIssuerProviderInterface>(PSRCSIDC);
+      new SimpleParameterSensitivityIssuerCalculator<>(PSRCSIDC);
   private static final SimpleParameterSensitivityIssuerDiscountInterpolatedFDCalculator PS_I_FD = new SimpleParameterSensitivityIssuerDiscountInterpolatedFDCalculator(PSRIDC, SHIFT_FD);
 
   private static final BondTransactionDiscountingMethod METHOD_BOND_TR = BondTransactionDiscountingMethod.getInstance();
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/IssuerProviderDiscountDataSets.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/IssuerProviderDiscountDataSets.java
index e723fdc..cc51e53 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/IssuerProviderDiscountDataSets.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/IssuerProviderDiscountDataSets.java
@@ -83,11 +83,16 @@ public class IssuerProviderDiscountDataSets {
 
   private static final IndexIborMaster MASTER_IBOR_INDEX = IndexIborMaster.getInstance();
   private static final IborIndex EURIBOR3M = MASTER_IBOR_INDEX.getIndex("EURIBOR3M");
+  private static final IborIndex USDLIBOR1M = MASTER_IBOR_INDEX.getIndex("USDLIBOR1M");
 
   private static final double[] USD_DSC_TIME = new double[] {0.0, 0.5, 1.0, 2.0, 5.0, 10.0 };
   private static final double[] USD_DSC_RATE = new double[] {0.0120, 0.0120, 0.0120, 0.0140, 0.0140, 0.0140 };
   private static final String USD_DSC_NAME = "USD Dsc";
   private static final YieldAndDiscountCurve USD_DSC = new YieldCurve(USD_DSC_NAME, new InterpolatedDoublesCurve(USD_DSC_TIME, USD_DSC_RATE, LINEAR_FLAT, true, USD_DSC_NAME));
+  private static final double[] USD_FWD1_TIME = new double[] {0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 10.0 };
+  private static final double[] USD_FWD1_RATE = new double[] {0.0150, 0.0125, 0.0150, 0.0175, 0.0175, 0.0190, 0.0200, 0.0210 };
+  private static final String USD_FWD1_NAME = "USD LIBOR 3M";
+  private static final YieldAndDiscountCurve USD_FWD1 = new YieldCurve(USD_FWD1_NAME, new InterpolatedDoublesCurve(USD_FWD1_TIME, USD_FWD1_RATE, LINEAR_FLAT, true, USD_FWD1_NAME));
 
   private static final double[] EUR_DSC_TIME = new double[] {0.0, 0.5, 1.0, 2.0, 5.0, 10.0 };
   private static final double[] EUR_DSC_RATE = new double[] {0.0150, 0.0125, 0.0150, 0.0175, 0.0150, 0.0150 };
@@ -128,13 +133,14 @@ public class IssuerProviderDiscountDataSets {
   private static final YieldAndDiscountCurve AUD_DSC = new YieldCurve(AUD_DSC_NAME, new InterpolatedDoublesCurve(USD_DSC_TIME, USD_DSC_RATE, LINEAR_FLAT, true, AUD_DSC_NAME));
   private static final String AUS_AUD_CURVE_NAME = "EUR " + AUS_NAME;
   private static final YieldAndDiscountCurve AUS_AUD_CURVE = new YieldCurve(AUS_AUD_CURVE_NAME, new InterpolatedDoublesCurve(EUR_GER_TIME, EUR_GER_RATE, LINEAR_FLAT, true, AUS_AUD_CURVE_NAME));
-  
+
   /** Extracts the short name (i.e. issuer name) from a legal entity */
   private static final LegalEntityFilter<LegalEntity> SHORT_NAME_FILTER = new LegalEntityShortName();
   /** A set of discounting curves for EUR, USD and GBP */
   private static final MulticurveProviderDiscount DISCOUNTING_CURVES = new MulticurveProviderDiscount();
   static {
     DISCOUNTING_CURVES.setCurve(USD, USD_DSC);
+    DISCOUNTING_CURVES.setCurve(USDLIBOR1M, USD_FWD1);
     DISCOUNTING_CURVES.setCurve(EUR, EUR_DSC);
     DISCOUNTING_CURVES.setCurve(EURIBOR3M, EUR_FWD3);
     DISCOUNTING_CURVES.setCurve(GBP, GBP_DSC);
@@ -239,6 +245,7 @@ public class IssuerProviderDiscountDataSets {
   public static IssuerProviderDiscount getIssuerSpecificProvider() {
     return ISSUER_SPECIFIC_MULTICURVE;
   }
+
   /**
    * Returns a multi-curves provider with a discounting currency (AUD) and an issuers (AUS Govt).
    * @return The provider.
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/MulticurveProviderDiscountDataSets.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/MulticurveProviderDiscountDataSets.java
index dc49506..ef6f6db 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/MulticurveProviderDiscountDataSets.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/provider/description/MulticurveProviderDiscountDataSets.java
@@ -213,6 +213,15 @@ public class MulticurveProviderDiscountDataSets {
     MULTICURVES_EUR_USD.setCurve(EURIBOR6M, EUR_FWD6);
   }
 
+  private static final MulticurveProviderDiscount MULTICURVES_GBP_USD = new MulticurveProviderDiscount();
+  static {
+    MULTICURVES_GBP_USD.setCurve(Currency.USD, USD_DSC);
+    MULTICURVES_GBP_USD.setCurve(FEDFUND, USD_DSC);
+    MULTICURVES_GBP_USD.setCurve(USDLIBOR3M, USD_FWD3);
+    MULTICURVES_GBP_USD.setCurve(USDLIBOR6M, USD_FWD6);
+    MULTICURVES_GBP_USD.setCurve(Currency.GBP, CURVE_GBP_30);
+  }
+
   private static final MulticurveProviderDiscount MULTICURVES_USD_WITHOUT_DISCOUNT = new MulticurveProviderDiscount();
 
   private static final MulticurveProviderDiscount MULTICURVES_CAD = new MulticurveProviderDiscount();
@@ -435,6 +444,14 @@ public class MulticurveProviderDiscountDataSets {
   }
 
   /**
+   * Returns a multi-curves provider with two currencies (GBP, USD), four Ibor indexes (UsdLibor3M, UsdLibor6M).
+   * @return The provider.
+   */
+  public static MulticurveProviderDiscount createMulticurveGbpUsd() {
+    return MULTICURVES_GBP_USD;
+  }
+
+  /**
    * Returns a multi-curves provider with two currencies USD without discount curve, four Ibor indexes (Euribor3M, Euribor6M, UsdLibor3M, UsdLibor6M).
    * @return The provider.
    */
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculatorTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculatorTest.java
index 4c7aff5..99f877a 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculatorTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/CarrLeeFXVolatilitySwapCalculatorTest.java
@@ -6,6 +6,7 @@
 package com.opengamma.analytics.financial.volatilityswap;
 
 import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
 import static org.testng.AssertJUnit.assertTrue;
 
 import java.util.Arrays;
@@ -115,6 +116,11 @@ public class CarrLeeFXVolatilitySwapCalculatorTest {
     final FXVolatilitySwap swap2 = new FXVolatilitySwap(1.e-4, timeToExpiry, PeriodFrequency.DAILY, timeToExpiry, spot, 1, base, base, counter, 252);
     assertEquals(swap1.accept(cal, data).getFairValue(), swap2.accept(cal, data).getFairValue(), 1.e-6);
 
+    final double[] strikeRange = new double[] {spot * 0.8, spot * 1.2 };
+    final CarrLeeFXVolatilitySwapCalculator cal1 = new CarrLeeFXVolatilitySwapCalculator(150, strikeRange);
+    swap.accept(cal1, data);
+    assertEquals(6., swap.accept(cal1, data).getFairValue(), eps * 10.0);
+
     /*
      * Error test
      */
@@ -122,70 +128,115 @@ public class CarrLeeFXVolatilitySwapCalculatorTest {
       new CarrLeeFXVolatilitySwapCalculator(0.1, 0.1, 10);
       throw new RuntimeException();
     } catch (final Exception e) {
-      assertTrue(e instanceof IllegalArgumentException);
+      assertEquals("-1 < lowestPutDelta < 0 should be true", e.getMessage());
     }
     try {
       new CarrLeeFXVolatilitySwapCalculator(-2.1, 0.1, 10);
       throw new RuntimeException();
     } catch (final Exception e) {
-      assertTrue(e instanceof IllegalArgumentException);
+      assertEquals("-1 < lowestPutDelta < 0 should be true", e.getMessage());
     }
     try {
       new CarrLeeFXVolatilitySwapCalculator(-0.1, -0.1, 10);
       throw new RuntimeException();
     } catch (final Exception e) {
-      assertTrue(e instanceof IllegalArgumentException);
+      assertEquals("0 < highestCallDelta < 1 should be true", e.getMessage());
     }
     try {
       new CarrLeeFXVolatilitySwapCalculator(-0.1, 3.1, 10);
       throw new RuntimeException();
     } catch (final Exception e) {
-      assertTrue(e instanceof IllegalArgumentException);
+      assertEquals("0 < highestCallDelta < 1 should be true", e.getMessage());
     }
     try {
       new CarrLeeFXVolatilitySwapCalculator(-0.1, 0.1, 1);
       throw new RuntimeException();
     } catch (final Exception e) {
-      assertTrue(e instanceof IllegalArgumentException);
+      assertEquals("numPoints should be greater than 2", e.getMessage());
+    }
+    try {
+      new CarrLeeFXVolatilitySwapCalculator(1, new double[] {1.1, 1.4 });
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("numPoints should be greater than 2", e.getMessage());
+    }
+    try {
+      new CarrLeeFXVolatilitySwapCalculator(10, new double[] {1.1, 1.4, 1.5 });
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("length of strikeRange should be 2", e.getMessage());
+    }
+    try {
+      new CarrLeeFXVolatilitySwapCalculator(10, new double[] {1.4, 1.1 });
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("upper bound should be greater than lower bound", e.getMessage());
     }
 
-    //    try {
-    //      cal.fairValueSeasoned(spot, -timeToExpiry, timeFromInception, dr, fr, realizedVar, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
-    //    try {
-    //      cal.fairValueSeasoned(spot, timeToExpiry, -timeFromInception, dr, fr, realizedVar, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
-    //    try {
-    //      cal.fairValueSeasoned(-spot, timeToExpiry, timeFromInception, dr, fr, realizedVar, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
-    //    try {
-    //      cal.fairValueSeasoned(spot, timeToExpiry, timeFromInception, dr, fr, -realizedVar, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
-
-    //    try {
-    //      cal.fairValueNew(spot, -timeToExpiry, dr, fr, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
-    //    try {
-    //      cal.fairValueNew(-spot, timeToExpiry, dr, fr, smile);
-    //      throw new RuntimeException();
-    //    } catch (final Exception e) {
-    //      assertTrue(e instanceof IllegalArgumentException);
-    //    }
+    try {
+      final FXVolatilitySwap swapNegativeTime = new FXVolatilitySwap(0., timeToExpiry, PeriodFrequency.DAILY, -timeToExpiry, spot, 1, base, base, counter, 252);
+      swapNegativeTime.accept(cal, data);
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("timeToExpiry should be positive", e.getMessage());
+    }
+    try {
+      final FXMatrix fxMatrixNegativeSpot = new FXMatrix(base, counter, -spot);
+      final MulticurveProviderDiscount curvesNegativeSpot = new MulticurveProviderDiscount(discountingCurves, new LinkedHashMap<IborIndex, YieldAndDiscountCurve>(),
+          new LinkedHashMap<IndexON, YieldAndDiscountCurve>(), fxMatrixNegativeSpot);
+      final CarrLeeFXData dataNegativeSpot = new CarrLeeFXData(Pairs.of(base, counter), smile, curvesNegativeSpot, realizedVar);
+      swap.accept(cal, dataNegativeSpot);
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("spot should be positive", e.getMessage());
+    }
+    try {
+      final CarrLeeFXVolatilitySwapCalculator calBadRange = new CarrLeeFXVolatilitySwapCalculator(10, new double[] {10.1, 10.4 });
+      swap.accept(calBadRange, data);
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("forward is outside of strike range", e.getMessage());
+    }
+    try {
+      final CarrLeeFXVolatilitySwapCalculator calBadRange = new CarrLeeFXVolatilitySwapCalculator(10, new double[] {0.1, 0.3 });
+      swap.accept(calBadRange, data);
+      throw new RuntimeException();
+    } catch (final Exception e) {
+      assertEquals("forward is outside of strike range", e.getMessage());
+    }
+  }
+
+  /**
+   * 
+   */
+  public void hashCodeAndEquals() {
+    final CarrLeeFXVolatilitySwapCalculator defaultCal = new CarrLeeFXVolatilitySwapCalculator();
+    final CarrLeeFXVolatilitySwapCalculator baseCal = new CarrLeeFXVolatilitySwapCalculator(-0.1, 0.1, 50);
+    final CarrLeeFXVolatilitySwapCalculator lowerCal = new CarrLeeFXVolatilitySwapCalculator(-0.2, 0.1, 50);
+    final CarrLeeFXVolatilitySwapCalculator upperCal = new CarrLeeFXVolatilitySwapCalculator(-0.1, 0.3, 50);
+    final CarrLeeFXVolatilitySwapCalculator pointsCal = new CarrLeeFXVolatilitySwapCalculator(-0.1, 0.1, 150);
+    final CarrLeeFXVolatilitySwapCalculator strikeBaseCal = new CarrLeeFXVolatilitySwapCalculator(50, new double[] {0.5, 1.5 });
+    final CarrLeeFXVolatilitySwapCalculator strikeIdCal = new CarrLeeFXVolatilitySwapCalculator(50, new double[] {0.5, 1.5 });
+    final CarrLeeFXVolatilitySwapCalculator strikeCal = new CarrLeeFXVolatilitySwapCalculator(50, new double[] {0.5, 2.5 });
+
+    assertTrue(defaultCal.equals(defaultCal));
+
+    assertTrue(defaultCal.hashCode() == baseCal.hashCode());
+    assertTrue(defaultCal.equals(baseCal));
+    assertTrue(baseCal.equals(defaultCal));
+
+    assertFalse(defaultCal.equals(lowerCal));
+    assertFalse(defaultCal.equals(upperCal));
+    assertFalse(defaultCal.equals(pointsCal));
+    assertFalse(defaultCal.equals(strikeBaseCal));
+    assertFalse(strikeBaseCal.equals(strikeCal));
+
+    assertTrue(strikeBaseCal.hashCode() == strikeIdCal.hashCode());
+    assertTrue(strikeBaseCal.equals(strikeIdCal));
+    assertTrue(strikeIdCal.equals(strikeBaseCal));
+
+    assertFalse(defaultCal.equals(null));
+    assertFalse(defaultCal.equals(new double[] {}));
   }
 
 }
diff --git a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksTest.java b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksTest.java
index 24f7da4..ba4f99f 100644
--- a/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksTest.java
+++ b/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/volatilityswap/VolatilitySwapFiniteDifferenceGreeksTest.java
@@ -6,6 +6,7 @@
 package com.opengamma.analytics.financial.volatilityswap;
 
 import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
 import static org.testng.AssertJUnit.assertTrue;
 
 import java.util.LinkedHashMap;
@@ -37,30 +38,37 @@ import com.opengamma.util.tuple.Pairs;
 public class VolatilitySwapFiniteDifferenceGreeksTest {
 
   /**
-  *
-  */
-  @Test
-  public void sampleDataTest() {
+   * 
+   */
+  public void newlyIssuedSwapTest() {
+
+    final double spot = 1.5;
+    final double timeToExpiry = 0.5;
+    final double timeFromInception = 0.;
+    final double dr = 0.01;
+    final double fr = 0.005;
+
+    final double bump = 1.e-5;
+    final double bumpVol = 1.e-7;
+
+    final CarrLeeFXVolatilitySwapCalculator baseCal = new CarrLeeFXVolatilitySwapCalculator();
     final VolatilitySwapFiniteDifferenceGreeksCalculator cal = new VolatilitySwapFiniteDifferenceGreeksCalculator();
 
-    final double spot = 1.3680000038304;
-    final double timeToExpiry = 129. / 252.;
-    final double timeFromInception = 0.0;
-    final double dr = 0.0;
-    final double fr = 0.0;
-    final double[] timeToExpiration = new double[] {timeToExpiry * 0.5, timeToExpiry };
-    final int nTime = timeToExpiration.length;
+    final CarrLeeFXVolatilitySwapCalculator baseCalRange = new CarrLeeFXVolatilitySwapCalculator(40, new double[] {0.8 * spot, 1.2 * spot });
+    final VolatilitySwapFiniteDifferenceGreeksCalculator calRange = new VolatilitySwapFiniteDifferenceGreeksCalculator(bump, baseCalRange);
+
+    final double[] timeSet = new double[] {timeToExpiry * 0.5, timeToExpiry };
+    final int nTime = timeSet.length;
     final double[] delta = new double[] {0.10, 0.25 };
     final int nVols = 2 * delta.length + 1;
     final double[][] volatility = new double[nTime][nVols];
-    final double[] volSmile = new double[] {8.7 / 100., 7.75 / 100., 7.0 / 100., 6.8 / 100., 6.95 / 100. };
+    final double[] volSmile = new double[] {9. / 100., 8. / 100., 7.5 / 100., 7.2 / 100., 7.85 / 100. };
     for (int i = 0; i < nTime; ++i) {
       System.arraycopy(volSmile, 0, volatility[i], 0, nVols);
     }
-    final Interpolator1D interp = CombinedInterpolatorExtrapolatorFactory.getInterpolator(Interpolator1DFactory.LOG_LINEAR, Interpolator1DFactory.LINEAR_EXTRAPOLATOR,
-        Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
-    final SmileDeltaTermStructureParametersStrikeInterpolation smile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeToExpiration, delta, volatility, interp);
-    //    final SmileDeltaTermStructureParametersStrikeInterpolation smile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeToExpiration, delta, volatility);
+    final Interpolator1D interp = CombinedInterpolatorExtrapolatorFactory.getInterpolator(Interpolator1DFactory.LINEAR, Interpolator1DFactory.FLAT_EXTRAPOLATOR,
+        Interpolator1DFactory.FLAT_EXTRAPOLATOR);
+    final SmileDeltaTermStructureParametersStrikeInterpolation smile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeSet, delta, volatility, interp);
     final Currency base = Currency.EUR;
     final Currency counter = Currency.USD;
     final Map<Currency, YieldAndDiscountCurve> discountingCurves = new LinkedHashMap<>();
@@ -73,31 +81,262 @@ public class VolatilitySwapFiniteDifferenceGreeksTest {
     final FXVolatilitySwap swap = new FXVolatilitySwap(-timeFromInception, timeToExpiry, PeriodFrequency.DAILY, timeToExpiry, spot, 1, base, base, counter, 252);
 
     final double[] greeks = cal.getFXVolatilitySwapGreeks(swap, data);
-    final double expDelta = 0.0000000000030515;
-    final double expTheta = -2.794370E-07;
-    final double expVega = 0.01001;
+    final double[] greeksRange = calRange.getFXVolatilitySwapGreeks(swap, data);
+
+    /**
+     * Tests with bumped data
+     */
+    final VolatilitySwapCalculatorResultWithStrikes baseResult = (VolatilitySwapCalculatorResultWithStrikes) swap.accept(baseCal, data);
+    final double baseFV = baseResult.getFairValue();
+    final VolatilitySwapCalculatorResultWithStrikes baseResultRange = (VolatilitySwapCalculatorResultWithStrikes) swap.accept(baseCalRange, data);
+    final double baseFVRange = baseResultRange.getFairValue();
+
+    final double bumpedSpot = spot + bump;
+    final FXMatrix bumpedFxMatrix = new FXMatrix(base, counter, bumpedSpot);
+    final MulticurveProviderDiscount spotBumpedCurves = new MulticurveProviderDiscount(discountingCurves, new LinkedHashMap<IborIndex, YieldAndDiscountCurve>(),
+        new LinkedHashMap<IndexON, YieldAndDiscountCurve>(), bumpedFxMatrix);
+    final CarrLeeFXData spotBumpedData = new CarrLeeFXData(Pairs.of(base, counter), smile, spotBumpedCurves);
+    final double spotBumpedFV = swap.accept(baseCal, spotBumpedData).getFairValue();
+    final double spotBumpedFVRange = swap.accept(baseCalRange, spotBumpedData).getFairValue();
+
+    final double[][] bumpedVolatility = new double[nTime][nVols];
+    final double[] bumpedVolSmile = new double[nVols];
+    for (int i = 0; i < nVols; ++i) {
+      /*
+       * Note interpolation is linear, but strike range affected
+       */
+      bumpedVolSmile[i] = volSmile[i] + bumpVol;
+    }
+    for (int i = 0; i < nTime; ++i) {
+      System.arraycopy(bumpedVolSmile, 0, bumpedVolatility[i], 0, nVols);
+    }
+    final SmileDeltaTermStructureParametersStrikeInterpolation volBumpedSmile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeSet, delta, bumpedVolatility, interp);
+    final CarrLeeFXData volBumpedData = new CarrLeeFXData(Pairs.of(base, counter), volBumpedSmile, curves);
+    final double volBumpedFV = swap.accept(baseCal, volBumpedData).getFairValue();
+    final double volBumpedFVRange = swap.accept(baseCalRange, volBumpedData).getFairValue();
+
+    final double bumpedTimeToExpiry = timeToExpiry - 1.0 / 252.0;
+    final FXVolatilitySwap timeBumpedSwap = new FXVolatilitySwap(-timeFromInception, bumpedTimeToExpiry, PeriodFrequency.DAILY, bumpedTimeToExpiry, spot, 1, base, base, counter, 252);
+    final double timeBumpedFV = timeBumpedSwap.accept(baseCal, data).getFairValue();
+    final double timeBumpedFVRange = timeBumpedSwap.accept(baseCalRange, data).getFairValue();
+
+    assertEquals((spotBumpedFV - baseFV) / bump, greeks[0], 1.e-12);
+    assertEquals((volBumpedFV - baseFV) / bumpVol / 100., greeks[1], 1.e-2);//Approximation
+    assertEquals(timeBumpedFV - baseFV, greeks[2], 1.e-12);
+
+    assertEquals((spotBumpedFVRange - baseFVRange) / bump, greeksRange[0], 1.e-12);
+    assertEquals((volBumpedFVRange - baseFVRange) / bumpVol / 100., greeksRange[1], 1.e-2);//Approximation
+    assertEquals(timeBumpedFVRange - baseFVRange, greeksRange[2], 1.e-12);
+
+    /**
+     * Consistency with separate methods
+     */
+    final CarrLeeFXVolatilitySwapDeltaCalculator del = new CarrLeeFXVolatilitySwapDeltaCalculator();
+    final CarrLeeFXVolatilitySwapVegaCalculator veg = new CarrLeeFXVolatilitySwapVegaCalculator();
+    final CarrLeeFXVolatilitySwapThetaCalculator the = new CarrLeeFXVolatilitySwapThetaCalculator();
+    assertEquals(swap.accept(del, data), greeks[0], 1.e-12);
+    assertEquals(swap.accept(veg, data), greeks[1], 1.e-12);
+    assertEquals(swap.accept(the, data), greeks[2], 1.e-12);
+
+    final CarrLeeFXVolatilitySwapDeltaCalculator delRange = new CarrLeeFXVolatilitySwapDeltaCalculator(bump, baseCalRange);
+    final CarrLeeFXVolatilitySwapVegaCalculator vegRange = new CarrLeeFXVolatilitySwapVegaCalculator(bumpVol, baseCalRange);
+    final CarrLeeFXVolatilitySwapThetaCalculator theRange = new CarrLeeFXVolatilitySwapThetaCalculator(baseCalRange);
+    assertEquals(swap.accept(delRange, data), greeksRange[0], 1.e-12);
+    assertEquals(swap.accept(vegRange, data), greeksRange[1], 1.e-12);
+    assertEquals(swap.accept(theRange, data), greeksRange[2], 1.e-12);
+
+  }
+
+  /**
+   * 
+   */
+  public void SeasonedSwapTest() {
+
+    final double spot = 1.5;
+    final double timeToExpiry = 0.5;
+    final double timeFromInception = 0.25;
+    final double dr = 0.01;
+    final double fr = 0.005;
+    final double rv = 8.1 * 8.1;
+
+    final double bump = 1.e-5;
+    final double bumpVol = 1.e-7;
+
+    final CarrLeeFXVolatilitySwapCalculator baseCal = new CarrLeeFXVolatilitySwapCalculator();
+    final VolatilitySwapFiniteDifferenceGreeksCalculator cal = new VolatilitySwapFiniteDifferenceGreeksCalculator();
+
+    final CarrLeeFXVolatilitySwapCalculator baseCalRange = new CarrLeeFXVolatilitySwapCalculator(40, new double[] {0.8 * spot, 1.2 * spot });
+    final VolatilitySwapFiniteDifferenceGreeksCalculator calRange = new VolatilitySwapFiniteDifferenceGreeksCalculator(bump, baseCalRange);
+
+    final double[] timeSet = new double[] {timeToExpiry * 0.5, timeToExpiry };
+    final int nTime = timeSet.length;
+    final double[] delta = new double[] {0.10, 0.25 };
+    final int nVols = 2 * delta.length + 1;
+    final double[][] volatility = new double[nTime][nVols];
+    final double[] volSmile = new double[] {9. / 100., 8. / 100., 7.5 / 100., 7.2 / 100., 7.85 / 100. };
+    for (int i = 0; i < nTime; ++i) {
+      System.arraycopy(volSmile, 0, volatility[i], 0, nVols);
+    }
+    final Interpolator1D interp = CombinedInterpolatorExtrapolatorFactory.getInterpolator(Interpolator1DFactory.LINEAR, Interpolator1DFactory.FLAT_EXTRAPOLATOR,
+        Interpolator1DFactory.FLAT_EXTRAPOLATOR);
+    final SmileDeltaTermStructureParametersStrikeInterpolation smile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeSet, delta, volatility, interp);
+    final Currency base = Currency.EUR;
+    final Currency counter = Currency.USD;
+    final Map<Currency, YieldAndDiscountCurve> discountingCurves = new LinkedHashMap<>();
+    discountingCurves.put(Currency.EUR, new YieldCurve("domestic", ConstantDoublesCurve.from(dr)));
+    discountingCurves.put(Currency.USD, new YieldCurve("foreign", ConstantDoublesCurve.from(fr)));
+    final FXMatrix fxMatrix = new FXMatrix(base, counter, spot);
+    final MulticurveProviderDiscount curves = new MulticurveProviderDiscount(discountingCurves, new LinkedHashMap<IborIndex, YieldAndDiscountCurve>(),
+        new LinkedHashMap<IndexON, YieldAndDiscountCurve>(), fxMatrix);
+    final CarrLeeFXData data = new CarrLeeFXData(Pairs.of(base, counter), smile, curves, rv);
+    final FXVolatilitySwap swap = new FXVolatilitySwap(-timeFromInception, timeToExpiry, PeriodFrequency.DAILY, timeToExpiry, spot, 1, base, base, counter, 252);
+
+    final double[] greeks = cal.getFXVolatilitySwapGreeks(swap, data);
+    final double[] greeksRange = calRange.getFXVolatilitySwapGreeks(swap, data);
 
-    assertEquals(expDelta, greeks[0], 1.e-4);
-    assertEquals(expVega, greeks[1] * 1.e-2, 1.e-4);
-    assertEquals(expTheta, greeks[2], 1.e-3);
-    assertTrue(expTheta * greeks[2] > 0.);
+    /**
+     * Tests with bumped data
+     */
+    final VolatilitySwapCalculatorResultWithStrikes baseResult = (VolatilitySwapCalculatorResultWithStrikes) swap.accept(baseCal, data);
+    final double baseFV = baseResult.getFairValue();
+    final VolatilitySwapCalculatorResultWithStrikes baseResultRange = (VolatilitySwapCalculatorResultWithStrikes) swap.accept(baseCalRange, data);
+    final double baseFVRange = baseResultRange.getFairValue();
 
-    //    final CarrLeeFXVolatilitySwapCalculator calbr = new CarrLeeFXVolatilitySwapCalculator();
-    //    System.out.println(swap.accept(calbr, data).getFairValue());
+    final double bumpedSpot = spot + bump;
+    final FXMatrix bumpedFxMatrix = new FXMatrix(base, counter, bumpedSpot);
+    final MulticurveProviderDiscount spotBumpedCurves = new MulticurveProviderDiscount(discountingCurves, new LinkedHashMap<IborIndex, YieldAndDiscountCurve>(),
+        new LinkedHashMap<IndexON, YieldAndDiscountCurve>(), bumpedFxMatrix);
+    final CarrLeeFXData spotBumpedData = new CarrLeeFXData(Pairs.of(base, counter), smile, spotBumpedCurves, rv);
+    final double spotBumpedFV = swap.accept(baseCal, spotBumpedData).getFairValue();
+    final double spotBumpedFVRange = swap.accept(baseCalRange, spotBumpedData).getFairValue();
+
+    final double[][] bumpedVolatility = new double[nTime][nVols];
+    final double[] bumpedVolSmile = new double[nVols];
+    for (int i = 0; i < nVols; ++i) {
+      /*
+       * Note interpolation is linear, but strike range affected
+       */
+      bumpedVolSmile[i] = volSmile[i] + bumpVol;
+    }
+    for (int i = 0; i < nTime; ++i) {
+      System.arraycopy(bumpedVolSmile, 0, bumpedVolatility[i], 0, nVols);
+    }
+    final SmileDeltaTermStructureParametersStrikeInterpolation volBumpedSmile = new SmileDeltaTermStructureParametersStrikeInterpolation(timeSet, delta, bumpedVolatility, interp);
+    final CarrLeeFXData volBumpedData = new CarrLeeFXData(Pairs.of(base, counter), volBumpedSmile, curves, rv);
+    final double volBumpedFV = swap.accept(baseCal, volBumpedData).getFairValue();
+    final double volBumpedFVRange = swap.accept(baseCalRange, volBumpedData).getFairValue();
+
+    final double bumpedTimeToExpiry = timeToExpiry - 1.0 / 252.0;
+    final FXVolatilitySwap timeBumpedSwap = new FXVolatilitySwap(-timeFromInception - 1.0 / 252.0, bumpedTimeToExpiry, PeriodFrequency.DAILY, bumpedTimeToExpiry, spot, 1, base, base, counter, 252);
+    final double timeBumpedFV = timeBumpedSwap.accept(baseCal, data).getFairValue();
+    final double timeBumpedFVRange = timeBumpedSwap.accept(baseCalRange, data).getFairValue();
+
+    assertEquals((spotBumpedFV - baseFV) / bump, greeks[0], 1.e-12);
+    assertEquals((volBumpedFV - baseFV) / bumpVol / 100., greeks[1], 1.e-1);//Approximation
+    assertEquals(timeBumpedFV - baseFV, greeks[2], 1.e-12);
+
+    assertEquals((spotBumpedFVRange - baseFVRange) / bump, greeksRange[0], 1.e-12);
+    assertEquals((volBumpedFVRange - baseFVRange) / bumpVol / 100., greeksRange[1], 1.e-1);//Approximation
+    assertEquals(timeBumpedFVRange - baseFVRange, greeksRange[2], 1.e-12);
 
     /**
-     * Consistency checked
+     * Consistency with separate methods
      */
-    final CarrLeeFXVolatilitySwapDeltaCalculator calDelta = new CarrLeeFXVolatilitySwapDeltaCalculator();
-    final CarrLeeFXVolatilitySwapVegaCalculator calVega = new CarrLeeFXVolatilitySwapVegaCalculator();
-    final CarrLeeFXVolatilitySwapThetaCalculator calTheta = new CarrLeeFXVolatilitySwapThetaCalculator();
+    final CarrLeeFXVolatilitySwapDeltaCalculator del = new CarrLeeFXVolatilitySwapDeltaCalculator();
+    final CarrLeeFXVolatilitySwapVegaCalculator veg = new CarrLeeFXVolatilitySwapVegaCalculator();
+    final CarrLeeFXVolatilitySwapThetaCalculator the = new CarrLeeFXVolatilitySwapThetaCalculator();
+    assertEquals(swap.accept(del, data), greeks[0], 1.e-12);
+    assertEquals(swap.accept(veg, data), greeks[1], 1.e-12);
+    assertEquals(swap.accept(the, data), greeks[2], 1.e-12);
+
+    final CarrLeeFXVolatilitySwapDeltaCalculator delRange = new CarrLeeFXVolatilitySwapDeltaCalculator(bump, baseCalRange);
+    final CarrLeeFXVolatilitySwapVegaCalculator vegRange = new CarrLeeFXVolatilitySwapVegaCalculator(bumpVol, baseCalRange);
+    final CarrLeeFXVolatilitySwapThetaCalculator theRange = new CarrLeeFXVolatilitySwapThetaCalculator(baseCalRange);
+    assertEquals(swap.accept(delRange, data), greeksRange[0], 1.e-12);
+    assertEquals(swap.accept(vegRange, data), greeksRange[1], 1.e-12);
+    assertEquals(swap.accept(theRange, data), greeksRange[2], 1.e-12);
+  }
+
+  public void hashCodeAndEqualsTest() {
+
+    final CarrLeeFXVolatilitySwapCalculator baseCal = new CarrLeeFXVolatilitySwapCalculator();
+    final CarrLeeFXVolatilitySwapCalculator baseCalRange = new CarrLeeFXVolatilitySwapCalculator(40, new double[] {0.8, 1.2 });
+
+    final VolatilitySwapFiniteDifferenceGreeksCalculator greeksDef = new VolatilitySwapFiniteDifferenceGreeksCalculator();
+    final VolatilitySwapFiniteDifferenceGreeksCalculator greeksBase = new VolatilitySwapFiniteDifferenceGreeksCalculator(1.e-5);
+    final VolatilitySwapFiniteDifferenceGreeksCalculator greeksBaseCal = new VolatilitySwapFiniteDifferenceGreeksCalculator(1.e-5, baseCal);
+    final VolatilitySwapFiniteDifferenceGreeksCalculator greeksRangeCal = new VolatilitySwapFiniteDifferenceGreeksCalculator(1.e-5, baseCalRange);
+    final VolatilitySwapFiniteDifferenceGreeksCalculator greeksBump = new VolatilitySwapFiniteDifferenceGreeksCalculator(1.e-7);
+
+    assertTrue(greeksDef.equals(greeksDef));
+
+    assertEquals(greeksDef.hashCode(), greeksBase.hashCode());
+    assertTrue(greeksDef.equals(greeksBase));
+    assertTrue(greeksBase.equals(greeksDef));
+
+    assertEquals(greeksDef.hashCode(), greeksBaseCal.hashCode());
+    assertTrue(greeksDef.equals(greeksBaseCal));
+    assertTrue(greeksBaseCal.equals(greeksDef));
+
+    assertFalse(greeksDef.equals(greeksRangeCal));
+    assertFalse(greeksDef.equals(greeksBump));
+    assertFalse(greeksDef.equals(new double[] {}));
+    assertFalse(greeksDef.equals(null));
+
+    final CarrLeeFXVolatilitySwapDeltaCalculator delDef = new CarrLeeFXVolatilitySwapDeltaCalculator();
+    final CarrLeeFXVolatilitySwapDeltaCalculator delBase = new CarrLeeFXVolatilitySwapDeltaCalculator(1.e-5);
+    final CarrLeeFXVolatilitySwapDeltaCalculator delBaseCal = new CarrLeeFXVolatilitySwapDeltaCalculator(1.e-5, baseCal);
+    final CarrLeeFXVolatilitySwapDeltaCalculator delRangeCal = new CarrLeeFXVolatilitySwapDeltaCalculator(1.e-5, baseCalRange);
+    final CarrLeeFXVolatilitySwapDeltaCalculator delBump = new CarrLeeFXVolatilitySwapDeltaCalculator(1.e-7);
+
+    assertTrue(delDef.equals(delDef));
+
+    assertEquals(delDef.hashCode(), delBase.hashCode());
+    assertTrue(delDef.equals(delBase));
+    assertTrue(delBase.equals(delDef));
+
+    assertEquals(delDef.hashCode(), delBaseCal.hashCode());
+    assertTrue(delDef.equals(delBaseCal));
+    assertTrue(delBaseCal.equals(delDef));
+
+    assertFalse(delDef.equals(delRangeCal));
+    assertFalse(delDef.equals(delBump));
+    assertFalse(delDef.equals(new double[] {}));
+    assertFalse(delDef.equals(null));
+
+    final CarrLeeFXVolatilitySwapVegaCalculator vegDef = new CarrLeeFXVolatilitySwapVegaCalculator();
+    final CarrLeeFXVolatilitySwapVegaCalculator vegBase = new CarrLeeFXVolatilitySwapVegaCalculator(1.e-7);
+    final CarrLeeFXVolatilitySwapVegaCalculator vegBaseCal = new CarrLeeFXVolatilitySwapVegaCalculator(1.e-7, baseCal);
+    final CarrLeeFXVolatilitySwapVegaCalculator vegRangeCal = new CarrLeeFXVolatilitySwapVegaCalculator(1.e-7, baseCalRange);
+    final CarrLeeFXVolatilitySwapVegaCalculator vegBump = new CarrLeeFXVolatilitySwapVegaCalculator(1.e-5);
+
+    assertTrue(vegDef.equals(vegDef));
+
+    assertEquals(vegDef.hashCode(), vegBase.hashCode());
+    assertTrue(vegDef.equals(vegBase));
+    assertTrue(vegBase.equals(vegDef));
+
+    assertEquals(vegDef.hashCode(), vegBaseCal.hashCode());
+    assertTrue(vegDef.equals(vegBaseCal));
+    assertTrue(vegBaseCal.equals(vegDef));
+
+    assertFalse(vegDef.equals(vegRangeCal));
+    assertFalse(vegDef.equals(vegBump));
+    assertFalse(vegDef.equals(new double[] {}));
+    assertFalse(vegDef.equals(null));
+
+    final CarrLeeFXVolatilitySwapThetaCalculator theDef = new CarrLeeFXVolatilitySwapThetaCalculator();
+    final CarrLeeFXVolatilitySwapThetaCalculator theBaseCal = new CarrLeeFXVolatilitySwapThetaCalculator(baseCal);
+    final CarrLeeFXVolatilitySwapThetaCalculator theRangeCal = new CarrLeeFXVolatilitySwapThetaCalculator(baseCalRange);
+
+    assertTrue(theDef.equals(theDef));
 
-    assertEquals(swap.accept(calDelta, data), greeks[0], 1.e-12);
-    assertEquals(swap.accept(calVega, data), greeks[1], 1.e-12);
-    assertEquals(swap.accept(calTheta, data), greeks[2], 1.e-12);
+    assertEquals(theDef.hashCode(), theBaseCal.hashCode());
+    assertTrue(theDef.equals(theBaseCal));
+    assertTrue(theBaseCal.equals(theDef));
 
-    //    System.out.println(greeks[0]);
-    //    System.out.println(greeks[1]);
-    //    System.out.println(greeks[2]);
+    assertFalse(theDef.equals(theRangeCal));
+    assertFalse(theDef.equals(new double[] {}));
+    assertFalse(theDef.equals(null));
   }
 }
diff --git a/projects/OG-Bloomberg/src/main/java/com/opengamma/bbg/component/BloombergBpipePermissionCheckProviderComponentFactory.java b/projects/OG-Bloomberg/src/main/java/com/opengamma/bbg/component/BloombergBpipePermissionCheckProviderComponentFactory.java
index b2bdddf..12f76ae 100644
--- a/projects/OG-Bloomberg/src/main/java/com/opengamma/bbg/component/BloombergBpipePermissionCheckProviderComponentFactory.java
+++ b/projects/OG-Bloomberg/src/main/java/com/opengamma/bbg/component/BloombergBpipePermissionCheckProviderComponentFactory.java
@@ -30,8 +30,10 @@ import com.opengamma.component.factory.AbstractComponentFactory;
 import com.opengamma.component.factory.ComponentInfoAttributes;
 import com.opengamma.provider.permission.PermissionCheckProvider;
 import com.opengamma.provider.permission.impl.DataPermissionCheckProviderResource;
+import com.opengamma.provider.permission.impl.ProviderBasedPermissionResolver;
 import com.opengamma.provider.permission.impl.RemotePermissionCheckProvider;
 import com.opengamma.util.ArgumentChecker;
+import com.opengamma.util.auth.AuthUtils;
 
 /**
  * Component factory for the Bloomberg permission check provider.
@@ -77,11 +79,16 @@ public class BloombergBpipePermissionCheckProviderComponentFactory extends Abstr
     info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemotePermissionCheckProvider.class);
     info.addAttribute(ComponentInfoAttributes.ACCEPTED_TYPES, BloombergPermissions.BLOOMBERG_PREFIX);
 
-    BloombergBpipePermissionCheckProvider provider = new BloombergBpipePermissionCheckProvider(getBloombergConnector(), getIdentityExpiryTime());
+    BloombergBpipePermissionCheckProvider provider = new BloombergBpipePermissionCheckProvider(
+        getBloombergConnector(), getIdentityExpiryTime());
     repo.registerComponent(info, provider);
     if (isPublishRest()) {
       repo.getRestComponents().publish(info, new DataPermissionCheckProviderResource(provider));
     }
+    if (AuthUtils.isPermissive() == false) {
+      AuthUtils.getPermissionResolver().register(
+          new ProviderBasedPermissionResolver(BloombergPermissions.BLOOMBERG_PREFIX, provider));
+    }
   }
 
   //------------------------- AUTOGENERATED START -------------------------
diff --git a/projects/OG-Component/src/main/java/com/opengamma/component/OpenGammaComponentServer.java b/projects/OG-Component/src/main/java/com/opengamma/component/OpenGammaComponentServer.java
index 913f66b..9ee125b 100644
--- a/projects/OG-Component/src/main/java/com/opengamma/component/OpenGammaComponentServer.java
+++ b/projects/OG-Component/src/main/java/com/opengamma/component/OpenGammaComponentServer.java
@@ -371,10 +371,10 @@ public class OpenGammaComponentServer {
    */
   protected void checkSecurityManager() {
     try {
-      if (AuthUtils.isPermissive()) {
-        _logger.logWarn("*********************************************************");
-        _logger.logWarn(" Warning: Server running with permissive SecurityManager ");
-        _logger.logWarn("*********************************************************");
+      if (AuthUtils.isDefault()) {
+        _logger.logWarn("*****************************************************************");
+        _logger.logWarn(" Warning: Server running with default permissive SecurityManager ");
+        _logger.logWarn("*****************************************************************");
       }
     } catch (UnavailableSecurityManagerException ex) {
       _logger.logError("***************************************************");
diff --git a/projects/OG-Component/src/main/java/com/opengamma/component/factory/infrastructure/ShiroSecurityComponentFactory.java b/projects/OG-Component/src/main/java/com/opengamma/component/factory/infrastructure/ShiroSecurityComponentFactory.java
index 795f360..e8d0d9e 100644
--- a/projects/OG-Component/src/main/java/com/opengamma/component/factory/infrastructure/ShiroSecurityComponentFactory.java
+++ b/projects/OG-Component/src/main/java/com/opengamma/component/factory/infrastructure/ShiroSecurityComponentFactory.java
@@ -12,7 +12,6 @@ import java.util.Map;
 import org.apache.shiro.authc.credential.DefaultPasswordService;
 import org.apache.shiro.authc.credential.PasswordMatcher;
 import org.apache.shiro.authc.credential.PasswordService;
-import org.apache.shiro.authz.ModularRealmAuthorizer;
 import org.apache.shiro.cache.MemoryConstrainedCacheManager;
 import org.apache.shiro.crypto.hash.DefaultHashService;
 import org.apache.shiro.mgt.SecurityManager;
@@ -97,10 +96,10 @@ public class ShiroSecurityComponentFactory extends AbstractComponentFactory {
       ArgumentChecker.notNull(getPrivateSalt(), "privateSalt");
       PasswordService pwService = initPasswordService(repo);
       SecurityManager securityManager = initSecurityManager(repo, pwService);
-      AuthUtils.setSecurityManager(securityManager);
+      AuthUtils.initSecurityManager(securityManager);
     } else {
       SecurityManager securityManager = initPermissiveSecurityManager(repo);
-      AuthUtils.setSecurityManager(securityManager);
+      AuthUtils.initSecurityManager(securityManager);
     }
   }
 
@@ -171,12 +170,12 @@ public class ShiroSecurityComponentFactory extends AbstractComponentFactory {
     realm.setAuthenticationCachingEnabled(true);
     realm.setAuthorizationCachingEnabled(true);
     realm.setCredentialsMatcher(pwMatcher);
+    realm.setPermissionResolver(AuthUtils.getPermissionResolver());
     // security manager
     DefaultWebSecurityManager sm = new DefaultWebSecurityManager();
     sm.setRealm(realm);
+    sm.setAuthorizer(realm);  // replace ModularRealmAuthorizer as not needed
     sm.setCacheManager(new MemoryConstrainedCacheManager());
-    // unchecked cast to cause RuntimeException if Apache Shiro changed
-    ((ModularRealmAuthorizer) sm.getAuthorizer()).setPermissionResolver(AuthUtils.getPermissionResolver());
     return sm;
   }
 
diff --git a/projects/OG-Component/src/main/java/com/opengamma/component/factory/provider/RemoteProvidersComponentFactory.java b/projects/OG-Component/src/main/java/com/opengamma/component/factory/provider/RemoteProvidersComponentFactory.java
index bbf7d8d..b300c06 100644
--- a/projects/OG-Component/src/main/java/com/opengamma/component/factory/provider/RemoteProvidersComponentFactory.java
+++ b/projects/OG-Component/src/main/java/com/opengamma/component/factory/provider/RemoteProvidersComponentFactory.java
@@ -95,7 +95,8 @@ public class RemoteProvidersComponentFactory extends AbstractComponentFactory {
     if (AuthUtils.isPermissive() == false && info.getAttributes().containsKey(ComponentInfoAttributes.ACCEPTED_TYPES)) {
       String[] permissionPrefixes = StringUtils.split(info.getAttribute(ComponentInfoAttributes.ACCEPTED_TYPES), ',');
       for (String permissionPrefix : permissionPrefixes) {
-        AuthUtils.getPermissionResolver().registerPrefix(permissionPrefix, new ProviderBasedPermissionResolver(provider));
+        AuthUtils.getPermissionResolver().register(
+            new ProviderBasedPermissionResolver(permissionPrefix, provider));
       }
     }
   }
diff --git a/projects/OG-Core/src/main/java/com/opengamma/core/user/impl/UserSourceRealm.java b/projects/OG-Core/src/main/java/com/opengamma/core/user/impl/UserSourceRealm.java
index 9077135..dff1494 100644
--- a/projects/OG-Core/src/main/java/com/opengamma/core/user/impl/UserSourceRealm.java
+++ b/projects/OG-Core/src/main/java/com/opengamma/core/user/impl/UserSourceRealm.java
@@ -6,6 +6,7 @@
 package com.opengamma.core.user.impl;
 
 import java.util.Collection;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
@@ -17,7 +18,9 @@ import org.apache.shiro.authc.UnknownAccountException;
 import org.apache.shiro.authc.UsernamePasswordToken;
 import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.AuthorizationInfo;
+import org.apache.shiro.authz.Permission;
 import org.apache.shiro.authz.SimpleAuthorizationInfo;
+import org.apache.shiro.authz.UnauthenticatedException;
 import org.apache.shiro.cache.Cache;
 import org.apache.shiro.cache.MapCache;
 import org.apache.shiro.realm.AuthorizingRealm;
@@ -26,6 +29,7 @@ import org.apache.shiro.subject.SimplePrincipalCollection;
 import org.apache.shiro.util.SoftHashMap;
 import org.threeten.bp.ZoneId;
 
+import com.google.common.collect.ImmutableList;
 import com.opengamma.DataNotFoundException;
 import com.opengamma.core.change.ChangeEvent;
 import com.opengamma.core.change.ChangeListener;
@@ -39,6 +43,7 @@ import com.opengamma.core.user.UserSource;
 import com.opengamma.id.ExternalIdBundle;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.auth.AuthUtils;
+import com.opengamma.util.auth.ShiroPermissionResolver;
 
 /**
  * A security {@code Realm} that accesses the user source.
@@ -308,4 +313,71 @@ public class UserSourceRealm extends AuthorizingRealm {
     }
   }
 
+  //-------------------------------------------------------------------------
+  // override Authorizer permission methods
+  // all interesting methods are overridden to insulate against changes in superclass
+  // the array versions of the methods are not overridden as they are not used
+  @Override
+  public ShiroPermissionResolver getPermissionResolver() {
+    return (ShiroPermissionResolver) super.getPermissionResolver();
+  }
+
+  @Override
+  public boolean isPermitted(PrincipalCollection subjectPrincipal, String requiredPermission) {
+    Permission required = getPermissionResolver().resolvePermission(requiredPermission);
+    return isPermitted(subjectPrincipal, required);
+  }
+
+  @Override
+  public boolean isPermitted(PrincipalCollection subjectPrincipal, Permission requiredPermission) {
+    return isPermittedAll(subjectPrincipal, ImmutableList.of(requiredPermission));
+  }
+
+  @Override
+  public boolean isPermittedAll(PrincipalCollection subjectPrincipal, String... requiredPermissions) {
+    if (requiredPermissions.length == 0) {
+      return true;
+    }
+    List<Permission> required = getPermissionResolver().resolvePermissions(requiredPermissions);
+    return isPermittedAll(subjectPrincipal, required);
+  }
+
+  @Override
+  public boolean isPermittedAll(PrincipalCollection subjectPrincipal, Collection<Permission> requiredPermissions) {
+    AuthorizationInfo info = getAuthorizationInfo(subjectPrincipal);
+    if (info == null) {
+      return false;
+    }
+    return getPermissionResolver().isPermittedAll(info.getObjectPermissions(), requiredPermissions);
+  }
+
+  //-------------------------------------------------------------------------
+  @Override
+  public void checkPermission(PrincipalCollection subjectPrincipal, String requiredPermission) throws AuthorizationException {
+    Permission required = getPermissionResolver().resolvePermission(requiredPermission);
+    checkPermission(subjectPrincipal, required);
+  }
+
+  @Override
+  public void checkPermission(PrincipalCollection subjectPrincipal, Permission requiredPermission) throws AuthorizationException {
+    checkPermissions(subjectPrincipal, ImmutableList.of(requiredPermission));
+  }
+
+  @Override
+  public void checkPermissions(PrincipalCollection subjectPrincipal, String... requiredPermissions) throws AuthorizationException {
+    if (requiredPermissions.length > 0) {
+      List<Permission> required = getPermissionResolver().resolvePermissions(requiredPermissions);
+      checkPermissions(subjectPrincipal, required);
+    }
+  }
+
+  @Override
+  public void checkPermissions(PrincipalCollection subjectPrincipal, Collection<Permission> requiredPermissions) throws AuthorizationException {
+    AuthorizationInfo info = getAuthorizationInfo(subjectPrincipal);
+    if (info == null) {
+      throw new UnauthenticatedException("Permission denied, user not authenticated");
+    }
+    getPermissionResolver().checkPermissions(info.getObjectPermissions(), requiredPermissions);
+  }
+
 }
diff --git a/projects/OG-Core/src/test/java/com/opengamma/core/user/impl/UserSourceRealmTest.java b/projects/OG-Core/src/test/java/com/opengamma/core/user/impl/UserSourceRealmTest.java
new file mode 100644
index 0000000..d82c235
--- /dev/null
+++ b/projects/OG-Core/src/test/java/com/opengamma/core/user/impl/UserSourceRealmTest.java
@@ -0,0 +1,211 @@
+/**
+ * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.core.user.impl;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.apache.shiro.authz.AuthorizationInfo;
+import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.SimpleAuthorizationInfo;
+import org.apache.shiro.authz.UnauthorizedException;
+import org.apache.shiro.subject.PrincipalCollection;
+import org.apache.shiro.subject.SimplePrincipalCollection;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import com.opengamma.core.change.BasicChangeManager;
+import com.opengamma.core.user.UserSource;
+import com.opengamma.util.auth.ShiroPermissionResolver;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * Tests UserSourceRealm.
+ */
+@Test(groups = TestGroup.UNIT)
+public class UserSourceRealmTest {
+
+  private static final PrincipalCollection PRINCIPALS = new SimplePrincipalCollection();
+  private static final Permission PERMISSION_OTHER_TYPE = new Permission() {
+    @Override
+    public boolean implies(Permission p) {
+      return false;
+    }
+  };
+
+  private UserSource _userSource;
+
+  @BeforeMethod
+  public void setUp() {
+    _userSource = mock(UserSource.class);
+    when(_userSource.changeManager()).thenReturn(new BasicChangeManager());
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void testIsPermitted_true() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(true, realm.isPermitted(PRINCIPALS, "Master:view"));
+  }
+
+  @Test
+  public void testIsPermitted_false() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(false, realm.isPermitted(PRINCIPALS, "Master:edit"));
+  }
+
+  @Test
+  public void testIsPermitted_otherType() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(false, realm.isPermitted(PRINCIPALS, PERMISSION_OTHER_TYPE));
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void testIsPermittedAll_none() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        info.addObjectPermission(resolver.resolvePermission("Source:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(true, realm.isPermittedAll(PRINCIPALS));
+  }
+
+  @Test
+  public void testIsPermittedAll_true() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        info.addObjectPermission(resolver.resolvePermission("Source:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(true, realm.isPermittedAll(PRINCIPALS, "Master:view", "Source:view"));
+  }
+
+  @Test
+  public void testIsPermittedAll_false() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        info.addObjectPermission(resolver.resolvePermission("Source:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    assertEquals(false, realm.isPermittedAll(PRINCIPALS, "Master:view", "Source:edit"));
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void testCheckPermission_true() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    realm.checkPermission(PRINCIPALS, "Master:view");
+  }
+
+  @Test(expectedExceptions = UnauthorizedException.class)
+  public void testCheckPermission_false() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    realm.checkPermission(PRINCIPALS, "Master:edit");
+  }
+
+  @Test(expectedExceptions = UnauthorizedException.class)
+  public void testCheckPermission_otherType() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    realm.checkPermission(PRINCIPALS, PERMISSION_OTHER_TYPE);
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void testCheckPermissions_true() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        info.addObjectPermission(resolver.resolvePermission("Source:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    realm.checkPermissions(PRINCIPALS, "Master:view", "Source:view");
+  }
+
+  @Test(expectedExceptions = UnauthorizedException.class)
+  public void testCheckPermissions_false() {
+    final ShiroPermissionResolver resolver = new ShiroPermissionResolver();
+    UserSourceRealm realm = new UserSourceRealm(_userSource) {
+      protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {
+        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
+        info.addObjectPermission(resolver.resolvePermission("Master:view"));
+        info.addObjectPermission(resolver.resolvePermission("Source:view"));
+        return info;
+      }
+    };
+    realm.setPermissionResolver(resolver);
+    realm.checkPermissions(PRINCIPALS, "Master:view", "Source:edit");
+  }
+
+}
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/AnnuityUtils.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/AnnuityUtils.java
index 96c2037..bd64b52 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/AnnuityUtils.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/AnnuityUtils.java
@@ -155,6 +155,9 @@ public class AnnuityUtils {
       case STRAIGHT:
         compoundingMethod = com.opengamma.analytics.financial.instrument.annuity.CompoundingMethod.STRAIGHT;
         break;
+      case SPREAD_EXCLUSIVE:
+        compoundingMethod = com.opengamma.analytics.financial.instrument.annuity.CompoundingMethod.SPREAD_EXCLUSIVE;
+        break; 
       case NONE:
         compoundingMethod = null;
         break;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/BondTotalReturnSwapSecurityConverter.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/BondTotalReturnSwapSecurityConverter.java
index fc0e498..11132f5 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/BondTotalReturnSwapSecurityConverter.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/BondTotalReturnSwapSecurityConverter.java
@@ -8,12 +8,13 @@ package com.opengamma.financial.analytics.conversion;
 import java.util.Collections;
 
 import org.threeten.bp.LocalDate;
+import org.threeten.bp.LocalTime;
 import org.threeten.bp.Period;
 import org.threeten.bp.ZoneId;
 import org.threeten.bp.ZonedDateTime;
 
 import com.opengamma.OpenGammaRuntimeException;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.instrument.InstrumentDefinition;
 import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
 import com.opengamma.analytics.financial.instrument.bond.BondFixedSecurityDefinition;
@@ -91,7 +92,7 @@ public class BondTotalReturnSwapSecurityConverter extends FinancialSecurityVisit
     final boolean isPayer = fundingLeg.getPayReceiveType() == PayReceiveType.PAY ? true : false;
     final LocalDate startDate = security.getEffectiveDate();
     final LocalDate endDate = security.getMaturityDate();
-    final NotionalExchange notionalExchange = NotionalExchange.NO_EXCHANGE;
+    final NotionalExchange notionalExchange = NotionalExchange.builder().exchangeFinalNotional(true).build(); //NotionalExchange.NO_EXCHANGE;
     final AnnuityDefinition<? extends PaymentDefinition> annuityDefinition = AnnuityUtils.buildFloatingAnnuityDefinition(_conventionSource, _holidaySource, isPayer,
         startDate, endDate, notionalExchange, fundingLeg);
     final BondSecurity bond = (BondSecurity) underlying;
@@ -127,9 +128,11 @@ public class BondTotalReturnSwapSecurityConverter extends FinancialSecurityVisit
     final double notional = security.getNotionalAmount();
     final int exDividendDays = 0;
     final BondFixedSecurityDefinition bondDefinition = BondFixedSecurityDefinition.from(currency, firstAccrualDate, firstCouponDate,
-        maturityDate, paymentPeriod, rate, settlementDays, notional, exDividendDays, calendar, dayCount, businessDay,
+        maturityDate, paymentPeriod, rate, settlementDays, 1.0d, exDividendDays, calendar, dayCount, businessDay,
         yieldConvention, isEOM, legalEntity);
-    return new BondTotalReturnSwapDefinition(annuityDefinition, bondDefinition);
+    final ZonedDateTime startDateTime = startDate.atTime(LocalTime.MIN).atZone(ZoneId.systemDefault());
+    final ZonedDateTime endDateTime = endDate.atTime(LocalTime.MIN).atZone(ZoneId.systemDefault());
+    return new BondTotalReturnSwapDefinition(startDateTime, endDateTime, annuityDefinition, bondDefinition, notional);
   }
 
   /**
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/EquityTotalReturnSwapSecurityConverter.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/EquityTotalReturnSwapSecurityConverter.java
index 48b2222..2166575 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/EquityTotalReturnSwapSecurityConverter.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/EquityTotalReturnSwapSecurityConverter.java
@@ -10,10 +10,13 @@ import java.util.Map;
 
 import org.joda.beans.impl.flexi.FlexiBean;
 import org.threeten.bp.LocalDate;
+import org.threeten.bp.LocalTime;
+import org.threeten.bp.ZoneId;
+import org.threeten.bp.ZonedDateTime;
 
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.equity.EquityDefinition;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.instrument.InstrumentDefinition;
 import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
 import com.opengamma.analytics.financial.instrument.bond.BondTotalReturnSwapDefinition;
@@ -80,7 +83,10 @@ public class EquityTotalReturnSwapSecurityConverter extends FinancialSecurityVis
     final EquitySecurity equity = (EquitySecurity) underlying;
     final LegalEntity legalEntity = getLegalEntityForEquity(equity);
     final EquityDefinition equityDefinition = new EquityDefinition(legalEntity, equity.getCurrency(), security.getNumberOfShares());
-    return new EquityTotalReturnSwapDefinition(annuityDefinition, equityDefinition, security.getNotionalAmount(), security.getNotionalCurrency(), security.getDividendPercentage() / 100.);
+    final ZonedDateTime startDateTime = startDate.atTime(LocalTime.MIN).atZone(ZoneId.systemDefault());
+    final ZonedDateTime endDateTime = endDate.atTime(LocalTime.MIN).atZone(ZoneId.systemDefault());
+    return new EquityTotalReturnSwapDefinition(startDateTime, endDateTime, annuityDefinition, equityDefinition, security.getNotionalAmount(), 
+        security.getNotionalCurrency(), security.getDividendPercentage() / 100.);
   }
 
   /**
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/InterestRateSwapSecurityConverter.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/InterestRateSwapSecurityConverter.java
index 3ff0bc8..954b82e 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/InterestRateSwapSecurityConverter.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/conversion/InterestRateSwapSecurityConverter.java
@@ -210,6 +210,9 @@ public class InterestRateSwapSecurityConverter extends FinancialSecurityVisitorA
       case STRAIGHT:
         compoundingMethod = com.opengamma.analytics.financial.instrument.annuity.CompoundingMethod.STRAIGHT;
         break;
+      case SPREAD_EXCLUSIVE:
+        compoundingMethod = com.opengamma.analytics.financial.instrument.annuity.CompoundingMethod.SPREAD_EXCLUSIVE;
+        break;
       case NONE:
         compoundingMethod = null;
         break;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/curve/exposure/ConfigDBInstrumentExposuresProvider.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/curve/exposure/ConfigDBInstrumentExposuresProvider.java
index d6399fd..2e2769e 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/curve/exposure/ConfigDBInstrumentExposuresProvider.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/curve/exposure/ConfigDBInstrumentExposuresProvider.java
@@ -10,6 +10,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.core.config.ConfigSource;
 import com.opengamma.core.security.SecuritySource;
@@ -83,11 +85,13 @@ public class ConfigDBInstrumentExposuresProvider implements InstrumentExposuresP
     final List<String> exposureFunctionNames = exposures.getExposureFunctions();
     List<ExternalId> ids = null;
     final Set<String> curveConstructionConfigurationNames = new HashSet<>();
+    Multimap<String, ExternalId> functionToIds = HashMultimap.create();
     for (final String exposureFunctionName : exposureFunctionNames) {
       final ExposureFunction exposureFunction = ExposureFunctionFactory.getExposureFunction(_securitySource, exposureFunctionName);
       ids = security.accept(exposureFunction);
       if (ids != null) {
         final Map<ExternalId, String> idsToNames = exposures.getIdsToNames();
+        functionToIds.putAll(exposureFunctionName, ids);
         for (final ExternalId id : ids) {
           final String name = idsToNames.get(id);
           if (name == null) {
@@ -100,8 +104,8 @@ public class ConfigDBInstrumentExposuresProvider implements InstrumentExposuresP
         }
       }
     }
-    throw new OpenGammaRuntimeException("Could not find a matching list of ids for " + security + " from "
-        + instrumentExposureConfigurationName);
+    throw new OpenGammaRuntimeException("Could not find a matching list of ids for " + security.getClass().getSimpleName() + "/" + security.getExternalIdBundle() + " from ExposureFunctions object '"
+        + instrumentExposureConfigurationName + "'. Ids attempted for referenced functions: " + functionToIds);
   }
 
 }
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/bondcurves/BondAndBondFuturePV01Function.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/bondcurves/BondAndBondFuturePV01Function.java
index 4f3f00d..8022ac8 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/bondcurves/BondAndBondFuturePV01Function.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/bondcurves/BondAndBondFuturePV01Function.java
@@ -82,7 +82,7 @@ public class BondAndBondFuturePV01Function extends BondAndBondFutureFromCurvesFu
     }
     if (!curveNameFound) {
       final ValueSpecification spec = new ValueSpecification(PV01, target.toSpecification(), properties.copy().with(CURVE, desiredCurveName).get());
-      return Collections.singleton(new ComputedValue(spec, 0));
+      return Collections.singleton(new ComputedValue(spec, .0));
     }
     return results;
   }
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeFunctions.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeFunctions.java
index a10ddd2..1a9f428 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeFunctions.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeFunctions.java
@@ -27,5 +27,10 @@ public class CarrLeeFunctions extends AbstractFunctionConfigurationBean {
   @Override
   protected void addAllConfigurations(final List<FunctionConfiguration> functions) {
     functions.add(functionConfiguration(CarrLeeFairValueFXVolatilitySwapFunction.class));
+    functions.add(functionConfiguration(CarrLeeCurrencyExposureFXVolatilitySwapFunction.class));
+    functions.add(functionConfiguration(CarrLeeDeltaFXVolatilitySwapFunction.class));
+    functions.add(functionConfiguration(CarrLeePresentValueFXVolatilitySwapFunction.class));
+    functions.add(functionConfiguration(CarrLeeThetaFXVolatilitySwapFunction.class));
+    functions.add(functionConfiguration(CarrLeeVegaFXVolatilitySwapFunction.class));
   }
 }
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeePresentValueFXVolatilitySwapFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeePresentValueFXVolatilitySwapFunction.java
index d728648..0ac7b22 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeePresentValueFXVolatilitySwapFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeePresentValueFXVolatilitySwapFunction.java
@@ -48,7 +48,7 @@ public class CarrLeePresentValueFXVolatilitySwapFunction extends CarrLeeFXVolati
 
   @Override
   public CompiledFunctionDefinition compile(final FunctionCompilationContext context, final Instant atInstant) {
-    return new CarrLeeFXVolatilitySwapCompiledFunction(getTargetToDefinitionConverter(context), getDefinitionToDerivativeConverter(context), false) {
+    return new CarrLeeFXVolatilitySwapCompiledFunction(getTargetToDefinitionConverter(context), getDefinitionToDerivativeConverter(context), true) {
 
       @SuppressWarnings("synthetic-access")
       @Override
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeThetaFXVolatilitySwapFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeThetaFXVolatilitySwapFunction.java
index cd9d461..8bbf050 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeThetaFXVolatilitySwapFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/carrlee/CarrLeeThetaFXVolatilitySwapFunction.java
@@ -17,7 +17,7 @@ import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
 import com.opengamma.analytics.financial.provider.description.volatilityswap.CarrLeeFXData;
-import com.opengamma.analytics.financial.volatilityswap.CarrLeeFXVolatilitySwapVegaCalculator;
+import com.opengamma.analytics.financial.volatilityswap.CarrLeeFXVolatilitySwapThetaCalculator;
 import com.opengamma.engine.ComputationTarget;
 import com.opengamma.engine.function.CompiledFunctionDefinition;
 import com.opengamma.engine.function.FunctionCompilationContext;
@@ -35,7 +35,7 @@ import com.opengamma.engine.value.ValueSpecification;
 public class CarrLeeThetaFXVolatilitySwapFunction extends CarrLeeFXVolatilitySwapFunction {
 
   /** The theta calculator */
-  private static final InstrumentDerivativeVisitor<CarrLeeFXData, Double> CALCULATOR = new CarrLeeFXVolatilitySwapVegaCalculator();
+  private static final InstrumentDerivativeVisitor<CarrLeeFXData, Double> CALCULATOR = new CarrLeeFXVolatilitySwapThetaCalculator();
 
   /**
    * Sets the value requirement to {@link ValueRequirementNames#THETA}.
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/discounting/DiscountingCurrencyExposureFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/discounting/DiscountingCurrencyExposureFunction.java
index da6d99d..00b7580 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/discounting/DiscountingCurrencyExposureFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/discounting/DiscountingCurrencyExposureFunction.java
@@ -16,7 +16,7 @@ import com.google.common.collect.Iterables;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
-import com.opengamma.analytics.financial.provider.calculator.discounting.PresentValueDiscountingCalculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.CurrencyExposureDiscountingCalculator;
 import com.opengamma.analytics.financial.provider.description.interestrate.MulticurveProviderInterface;
 import com.opengamma.core.security.Security;
 import com.opengamma.engine.ComputationTarget;
@@ -41,7 +41,8 @@ import com.opengamma.util.money.MultipleCurrencyAmount;
  */
 public class DiscountingCurrencyExposureFunction extends DiscountingFunction {
   /** The FX currency exposure calculator */
-  private static final InstrumentDerivativeVisitor<MulticurveProviderInterface, MultipleCurrencyAmount> CALCULATOR = PresentValueDiscountingCalculator.getInstance();
+  private static final InstrumentDerivativeVisitor<MulticurveProviderInterface, MultipleCurrencyAmount> CALCULATOR = 
+      CurrencyExposureDiscountingCalculator.getInstance();
 
   /**
    * Sets the value requirement to {@link ValueRequirementNames#FX_CURRENCY_EXPOSURE}
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/timeseries/HistoricalRealizedVarianceFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/timeseries/HistoricalRealizedVarianceFunction.java
index ac66965..10484fb 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/timeseries/HistoricalRealizedVarianceFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/timeseries/HistoricalRealizedVarianceFunction.java
@@ -18,6 +18,7 @@ import java.util.Set;
 import org.threeten.bp.LocalDate;
 
 import com.google.common.collect.Iterables;
+import com.opengamma.analytics.financial.volatilityswap.RealizedVolatilityCalculator;
 import com.opengamma.analytics.math.function.Function1D;
 import com.opengamma.analytics.math.statistics.descriptive.SampleVarianceCalculator;
 import com.opengamma.engine.ComputationTarget;
@@ -41,7 +42,7 @@ import com.opengamma.util.money.UnorderedCurrencyPair;
  */
 public class HistoricalRealizedVarianceFunction extends AbstractFunction.NonCompiledInvoker {
   /** The historical variance calculator */
-  private static final Function1D<double[], Double> CALCULATOR = new SampleVarianceCalculator();
+  private static final RealizedVolatilityCalculator CALCULATOR = new RealizedVolatilityCalculator();
 
   @Override
   public Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final FunctionInputs inputs, final ComputationTarget target,
@@ -67,7 +68,7 @@ public class HistoricalRealizedVarianceFunction extends AbstractFunction.NonComp
     if (history.isEmpty()) {
       return Collections.singleton(new ComputedValue(spec, 0.));
     }
-    final double variance = CALCULATOR.evaluate(history.valuesArrayFast());
+    final double variance = CALCULATOR.getRealizedVariance(history.valuesArrayFast());
     return Collections.singleton(new ComputedValue(spec, variance));
   }
 
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapBCSFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapBCSFunction.java
new file mode 100644
index 0000000..77bcc9f
--- /dev/null
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapBCSFunction.java
@@ -0,0 +1,127 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.financial.analytics.model.trs;
+
+import static com.opengamma.engine.value.ValuePropertyNames.CURVE_EXPOSURES;
+import static com.opengamma.engine.value.ValueRequirementNames.BLOCK_CURVE_SENSITIVITIES;
+import static com.opengamma.engine.value.ValueRequirementNames.JACOBIAN_BUNDLE;
+import static com.opengamma.financial.analytics.model.curve.CurveCalculationPropertyNamesAndValues.DISCOUNTING;
+import static com.opengamma.financial.analytics.model.curve.CurveCalculationPropertyNamesAndValues.PROPERTY_CURVE_TYPE;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.threeten.bp.Instant;
+
+import com.opengamma.analytics.financial.forex.method.FXMatrix;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
+import com.opengamma.analytics.financial.provider.calculator.generic.MarketQuoteSensitivityBlockCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueCurveSensitivityIssuerCalculator;
+import com.opengamma.analytics.financial.provider.curve.CurveBuildingBlockBundle;
+import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyMulticurveSensitivity;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyParameterSensitivity;
+import com.opengamma.analytics.financial.provider.sensitivity.parameter.ParameterSensitivityParameterCalculator;
+import com.opengamma.engine.ComputationTarget;
+import com.opengamma.engine.function.CompiledFunctionDefinition;
+import com.opengamma.engine.function.FunctionCompilationContext;
+import com.opengamma.engine.function.FunctionExecutionContext;
+import com.opengamma.engine.function.FunctionInputs;
+import com.opengamma.engine.value.ComputedValue;
+import com.opengamma.engine.value.ValueProperties;
+import com.opengamma.engine.value.ValueRequirement;
+import com.opengamma.engine.value.ValueSpecification;
+import com.opengamma.financial.security.swap.BondTotalReturnSwapSecurity;
+
+/**
+ * 
+ */
+public class BondTotalReturnSwapBCSFunction extends BondTotalReturnSwapFunction {
+  
+  private static final Logger s_logger = LoggerFactory.getLogger(BondTotalReturnSwapBCSFunction.class);
+  
+  /** The curve sensitivity calculator */
+  private static final InstrumentDerivativeVisitor<ParameterIssuerProviderInterface, MultipleCurrencyMulticurveSensitivity> PVCSDC =
+      PresentValueCurveSensitivityIssuerCalculator.getInstance();
+  /** The parameter sensitivity calculator */
+  private static final ParameterSensitivityParameterCalculator<ParameterIssuerProviderInterface> PSC =
+      new ParameterSensitivityParameterCalculator<>(PVCSDC);
+  /** The market quote sensitivity calculator */
+  private static final MarketQuoteSensitivityBlockCalculator<ParameterIssuerProviderInterface> CALCULATOR =
+      new MarketQuoteSensitivityBlockCalculator<>(PSC);
+
+  /**
+   * 
+   */
+  public BondTotalReturnSwapBCSFunction() {
+    super(BLOCK_CURVE_SENSITIVITIES);
+  }
+  
+  @Override
+  public CompiledFunctionDefinition compile(FunctionCompilationContext context, Instant atInstant) {
+    return new BondTotalReturnSwapCompiledFunction(getTargetToDefinitionConverter(context), 
+                                                   getDefinitionToDerivativeConverter(context), true) {
+
+      @Override
+      protected Set<ComputedValue> getValues(FunctionExecutionContext executionContext, FunctionInputs inputs, ComputationTarget target, Set<ValueRequirement> desiredValues,
+          InstrumentDerivative derivative, FXMatrix fxMatrix) {
+        ParameterIssuerProviderInterface issuerCurves = getMergedWithIssuerProviders(inputs, fxMatrix);
+        CurveBuildingBlockBundle blocks = new CurveBuildingBlockBundle();
+        for (ComputedValue cv : inputs.getAllValues()) {
+          if (JACOBIAN_BUNDLE.equals(cv.getSpecification().getValueName())) {
+            blocks.addAll((CurveBuildingBlockBundle) cv.getValue()); 
+          }
+        }
+        
+        Set<ComputedValue> result = new HashSet<>();
+        MultipleCurrencyParameterSensitivity sensitivities = CALCULATOR.fromInstrument(derivative, issuerCurves, blocks);
+        for (ValueRequirement desiredValue : desiredValues) {
+          final ValueSpecification spec = new ValueSpecification(BLOCK_CURVE_SENSITIVITIES, target.toSpecification(), desiredValue.getConstraints().copy().get());
+          result.add(new ComputedValue(spec, sensitivities));
+        }
+        return result;
+      }
+      
+
+      @Override
+      public Set<ValueRequirement> getRequirements(final FunctionCompilationContext compilationContext, final ComputationTarget target, final ValueRequirement desiredValue) {
+        return super.getRequirements(compilationContext, target, desiredValue);
+      }
+
+      @SuppressWarnings("synthetic-access")
+      @Override
+      public Set<ValueSpecification> getResults(final FunctionCompilationContext compilationContext, final ComputationTarget target, final Map<ValueSpecification, ValueRequirement> inputs) {
+        return super.getResults(compilationContext, target, inputs);
+
+      }
+
+      @Override
+      protected Collection<ValueProperties.Builder> getResultProperties(final FunctionCompilationContext compilationContext, final ComputationTarget target) {
+        return Collections.singleton(createValueProperties()
+            .with(PROPERTY_CURVE_TYPE, DISCOUNTING)
+            .withAny(CURVE_EXPOSURES).withAny(PROPERTY_CURVE_TYPE));
+      }
+
+      
+      @Override
+      protected String getCurrencyOfResult(final BondTotalReturnSwapSecurity security) {
+        throw new IllegalStateException("BondTotalReturnSwapBCSFunction does not set the Currency property in this method");
+      }
+
+    };
+    
+    
+  }
+  
+  
+
+}
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapCurrencyExposureFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapCurrencyExposureFunction.java
new file mode 100644
index 0000000..cd60a5e
--- /dev/null
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapCurrencyExposureFunction.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.financial.analytics.model.trs;
+
+import static com.opengamma.engine.value.ValueRequirementNames.FX_CURRENCY_EXPOSURE;
+
+import java.util.Set;
+
+import org.threeten.bp.Instant;
+
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.forex.method.FXMatrix;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
+import com.opengamma.analytics.financial.provider.calculator.issuer.CurrencyExposureIssuerCalculator;
+import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
+import com.opengamma.engine.ComputationTarget;
+import com.opengamma.engine.function.CompiledFunctionDefinition;
+import com.opengamma.engine.function.FunctionCompilationContext;
+import com.opengamma.engine.function.FunctionExecutionContext;
+import com.opengamma.engine.function.FunctionInputs;
+import com.opengamma.engine.value.ComputedValue;
+import com.opengamma.engine.value.ValueRequirement;
+import com.opengamma.engine.value.ValueSpecification;
+import com.opengamma.financial.security.swap.BondTotalReturnSwapSecurity;
+import com.opengamma.util.money.MultipleCurrencyAmount;
+
+/**
+ * 
+ */
+public class BondTotalReturnSwapCurrencyExposureFunction extends BondTotalReturnSwapFunction {
+  private static final InstrumentDerivativeVisitor<ParameterIssuerProviderInterface, MultipleCurrencyAmount> CALCULATOR =
+      CurrencyExposureIssuerCalculator.getInstance();
+  /**
+   * 
+   */
+  public BondTotalReturnSwapCurrencyExposureFunction() {
+    super(FX_CURRENCY_EXPOSURE);
+  }
+  
+  @Override
+  public CompiledFunctionDefinition compile(FunctionCompilationContext context, Instant atInstant) {
+    return new BondTotalReturnSwapCompiledFunction(getTargetToDefinitionConverter(context),
+        getDefinitionToDerivativeConverter(context), false) {
+
+      @Override
+      protected String getCurrencyOfResult(final BondTotalReturnSwapSecurity security) {
+        throw new IllegalStateException("BondTotalReturnSwapCurrencyExposureFunction does not set the Currency property in this method");
+      }
+
+      @Override
+      protected Set<ComputedValue> getValues(FunctionExecutionContext executionContext, FunctionInputs inputs, ComputationTarget target, Set<ValueRequirement> desiredValues,
+          InstrumentDerivative derivative, FXMatrix fxMatrix) {
+        
+        Set<ComputedValue> results = Sets.newHashSet();
+        for (ValueRequirement desiredValue : desiredValues) {
+          ParameterIssuerProviderInterface issuerCurves = getMergedWithIssuerProviders(inputs, fxMatrix);
+          
+          MultipleCurrencyAmount exposure = derivative.accept(CALCULATOR, issuerCurves);
+          ComputedValue result = new ComputedValue(ValueSpecification.of(FX_CURRENCY_EXPOSURE, target.toSpecification(), desiredValue.getConstraints()), exposure);
+          results.add(result);
+        }
+        
+        return results;
+      }
+
+    };
+  }
+
+}
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPV01Function.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPV01Function.java
index 56bbe45..e08ec02 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPV01Function.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPV01Function.java
@@ -28,7 +28,8 @@ import org.threeten.bp.Instant;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
-import com.opengamma.analytics.financial.interestrate.bond.calculator.BondTrsPV01Calculator;
+import com.opengamma.analytics.financial.provider.calculator.discounting.PV01CurveParametersCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueCurveSensitivityIssuerCalculator;
 import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderInterface;
 import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
 import com.opengamma.analytics.util.amount.ReferenceAmount;
@@ -54,7 +55,7 @@ public class BondTotalReturnSwapPV01Function extends BondTotalReturnSwapFunction
   private static final Logger s_logger = LoggerFactory.getLogger(BondTotalReturnSwapPV01Function.class);
   /** The calculator */
   private static final InstrumentDerivativeVisitor<ParameterIssuerProviderInterface, ReferenceAmount<Pair<String, Currency>>> CALCULATOR =
-      BondTrsPV01Calculator.getInstance();
+      new PV01CurveParametersCalculator<>(PresentValueCurveSensitivityIssuerCalculator.getInstance());
 
   /**
    * Sets the value requirement to {@link ValueRequirementNames#PV01}.
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPVFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPVFunction.java
index 6e1c0a1..5ba5aab 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPVFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapPVFunction.java
@@ -14,12 +14,12 @@ import java.util.Set;
 import org.threeten.bp.Instant;
 
 import com.google.common.collect.Iterables;
-import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
-import com.opengamma.analytics.financial.interestrate.bond.calculator.BondTrsPresentValueCalculator;
+import com.opengamma.analytics.financial.provider.calculator.issuer.PresentValueIssuerCalculator;
 import com.opengamma.analytics.financial.provider.description.interestrate.IssuerProviderInterface;
+import com.opengamma.analytics.financial.provider.description.interestrate.ParameterIssuerProviderInterface;
 import com.opengamma.engine.ComputationTarget;
 import com.opengamma.engine.function.CompiledFunctionDefinition;
 import com.opengamma.engine.function.FunctionCompilationContext;
@@ -31,6 +31,8 @@ import com.opengamma.engine.value.ValueRequirement;
 import com.opengamma.engine.value.ValueRequirementNames;
 import com.opengamma.engine.value.ValueSpecification;
 import com.opengamma.financial.security.swap.BondTotalReturnSwapSecurity;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.money.CurrencyAmount;
 import com.opengamma.util.money.MultipleCurrencyAmount;
 
 /**
@@ -38,8 +40,8 @@ import com.opengamma.util.money.MultipleCurrencyAmount;
  */
 public class BondTotalReturnSwapPVFunction extends BondTotalReturnSwapFunction {
   /** The calculator */
-  private static final InstrumentDerivativeVisitor<IssuerProviderInterface, MultipleCurrencyAmount> CALCULATOR =
-      BondTrsPresentValueCalculator.getInstance();
+  private static final InstrumentDerivativeVisitor<ParameterIssuerProviderInterface, MultipleCurrencyAmount> CALCULATOR =
+      PresentValueIssuerCalculator.getInstance();
 
   /**
    * Sets the value requirement to {@link ValueRequirementNames#PRESENT_VALUE}.
@@ -61,10 +63,8 @@ public class BondTotalReturnSwapPVFunction extends BondTotalReturnSwapFunction {
         final IssuerProviderInterface issuerCurves = getMergedWithIssuerProviders(inputs, fxMatrix);
         final MultipleCurrencyAmount pv = derivative.accept(CALCULATOR, issuerCurves);
         final String expectedCurrency = spec.getProperty(CURRENCY);
-        if (pv.size() != 1 || !(expectedCurrency.equals(pv.getCurrencyAmounts()[0].getCurrency().getCode()))) {
-          throw new OpenGammaRuntimeException("Expecting a single result in " + expectedCurrency);
-        }
-        return Collections.singleton(new ComputedValue(spec, pv.getCurrencyAmounts()[0].getAmount()));
+        final CurrencyAmount pvConverted = fxMatrix.convert(pv, Currency.of(expectedCurrency)); // Convert the MultipleCurrencyAmount in the expected currency.
+        return Collections.singleton(new ComputedValue(spec, pvConverted.getAmount()));
       }
 
       @Override
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapYCNSFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapYCNSFunction.java
new file mode 100644
index 0000000..b4aeba0
--- /dev/null
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/BondTotalReturnSwapYCNSFunction.java
@@ -0,0 +1,179 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ * 
+ * Please see distribution for license.
+ */
+package com.opengamma.financial.analytics.model.trs;
+
+import static com.opengamma.engine.value.ValuePropertyNames.CURRENCY;
+import static com.opengamma.engine.value.ValuePropertyNames.CURVE;
+import static com.opengamma.engine.value.ValuePropertyNames.CURVE_EXPOSURES;
+import static com.opengamma.engine.value.ValuePropertyNames.CURVE_SENSITIVITY_CURRENCY;
+import static com.opengamma.engine.value.ValuePropertyNames.FUNCTION;
+import static com.opengamma.engine.value.ValueRequirementNames.BLOCK_CURVE_SENSITIVITIES;
+import static com.opengamma.engine.value.ValueRequirementNames.CURVE_BUNDLE;
+import static com.opengamma.engine.value.ValueRequirementNames.CURVE_DEFINITION;
+import static com.opengamma.engine.value.ValueRequirementNames.YIELD_CURVE_NODE_SENSITIVITIES;
+import static com.opengamma.financial.analytics.model.curve.CurveCalculationPropertyNamesAndValues.DISCOUNTING;
+import static com.opengamma.financial.analytics.model.curve.CurveCalculationPropertyNamesAndValues.PROPERTY_CURVE_TYPE;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.threeten.bp.Instant;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.opengamma.analytics.financial.forex.method.FXMatrix;
+import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
+import com.opengamma.analytics.financial.provider.sensitivity.multicurve.MultipleCurrencyParameterSensitivity;
+import com.opengamma.analytics.math.matrix.DoubleMatrix1D;
+import com.opengamma.engine.ComputationTarget;
+import com.opengamma.engine.ComputationTargetSpecification;
+import com.opengamma.engine.function.CompiledFunctionDefinition;
+import com.opengamma.engine.function.FunctionCompilationContext;
+import com.opengamma.engine.function.FunctionExecutionContext;
+import com.opengamma.engine.function.FunctionInputs;
+import com.opengamma.engine.value.ComputedValue;
+import com.opengamma.engine.value.ValueProperties;
+import com.opengamma.engine.value.ValueProperties.Builder;
+import com.opengamma.engine.value.ValueRequirement;
+import com.opengamma.engine.value.ValueRequirementNames;
+import com.opengamma.engine.value.ValueSpecification;
+import com.opengamma.financial.analytics.DoubleLabelledMatrix1D;
+import com.opengamma.financial.analytics.curve.CurveDefinition;
+import com.opengamma.financial.analytics.model.multicurve.MultiCurveUtils;
+import com.opengamma.financial.security.swap.BondTotalReturnSwapSecurity;
+import com.opengamma.util.money.Currency;
+import com.opengamma.util.tuple.ObjectsPair;
+import com.opengamma.util.tuple.Pair;
+
+/**
+ * 
+ */
+public class BondTotalReturnSwapYCNSFunction extends BondTotalReturnSwapFunction {
+
+  
+  private static final Logger s_logger = LoggerFactory.getLogger(BondTotalReturnSwapYCNSFunction.class);
+  
+  /**
+   * 
+   */
+  public BondTotalReturnSwapYCNSFunction() {
+    super(YIELD_CURVE_NODE_SENSITIVITIES);
+  }
+  
+  @Override
+  public CompiledFunctionDefinition compile(FunctionCompilationContext context, Instant atInstant) {
+    return new BondTotalReturnSwapCompiledFunction(getTargetToDefinitionConverter(context), 
+        getDefinitionToDerivativeConverter(context), true) {
+      
+      @Override
+      protected Set<ComputedValue> getValues(FunctionExecutionContext executionContext, FunctionInputs inputs, ComputationTarget target, Set<ValueRequirement> desiredValues,
+          InstrumentDerivative derivative, FXMatrix fxMatrix) {
+        final MultipleCurrencyParameterSensitivity sensitivities = (MultipleCurrencyParameterSensitivity) inputs.getValue(BLOCK_CURVE_SENSITIVITIES);
+        Set<ComputedValue> results = Sets.newHashSet();
+        for (ValueRequirement desiredValue : desiredValues) {
+          final ValueProperties properties = desiredValue.getConstraints();
+          final String desiredCurveName = desiredValue.getConstraint(CURVE);
+          final Map<Pair<String, Currency>, DoubleMatrix1D> entries = sensitivities.getSensitivities();
+          for (final Map.Entry<Pair<String, Currency>, DoubleMatrix1D> entry : entries.entrySet()) {
+            final String curveName = entry.getKey().getFirst();
+            if (desiredCurveName.equals(curveName)) {
+              final ValueProperties curveSpecificProperties = properties.copy()
+                  .withoutAny(CURVE)
+                  .with(CURVE, curveName)
+                  .get();
+              final CurveDefinition curveDefinition = (CurveDefinition) inputs.getValue(new ValueRequirement(CURVE_DEFINITION, ComputationTargetSpecification.NULL,
+                  ValueProperties.builder().with(CURVE, curveName).get()));
+              final DoubleLabelledMatrix1D ycns = MultiCurveUtils.getLabelledMatrix(entry.getValue(), curveDefinition);
+              final ValueSpecification spec = new ValueSpecification(YIELD_CURVE_NODE_SENSITIVITIES, target.toSpecification(), curveSpecificProperties);
+              results.add(new ComputedValue(spec, ycns));
+            }
+          }
+        }
+        return results;
+
+      }
+      
+      @Override
+      protected String getCurrencyOfResult(final BondTotalReturnSwapSecurity security) {
+        throw new IllegalStateException("BondTotalReturnSwapYCNSFunction does not set the Currency property in this method");
+      }
+      
+      @Override
+      public Set<ValueSpecification> getResults(FunctionCompilationContext context, ComputationTarget target) {
+        return super.getResults(context, target);
+      }
+
+      @Override
+      public Set<ValueRequirement> getRequirements(FunctionCompilationContext context, ComputationTarget target, ValueRequirement desiredValue) {
+        String curveExposures = desiredValue.getConstraint(CURVE_EXPOSURES);
+        String curveType = desiredValue.getConstraint(PROPERTY_CURVE_TYPE);
+        Builder builder = ValueProperties.builder();
+        builder.with(CURVE_EXPOSURES, curveExposures);
+        builder.with(PROPERTY_CURVE_TYPE, curveType);
+        ImmutableSet<ValueRequirement> bcsReq = ImmutableSet.of(new ValueRequirement(ValueRequirementNames.BLOCK_CURVE_SENSITIVITIES, target.toSpecification(), builder.get()));
+        return Sets.union(bcsReq, super.getRequirements(context, target, desiredValue));
+      }
+
+      @Override
+      public Set<ValueSpecification> getResults(FunctionCompilationContext context, ComputationTarget target, Map<ValueSpecification, ValueRequirement> inputs) {
+        final Set<String> functionNames = new HashSet<>();
+        List<Pair<String, String>> ccyCurvePairs = Lists.newArrayList();
+        for (final Map.Entry<ValueSpecification, ValueRequirement> entry : inputs.entrySet()) {
+          final ValueSpecification specification = entry.getKey();
+          if (specification.getValueName().equals(CURVE_BUNDLE)) {
+            final ValueProperties constraints = specification.getProperties();
+            for (String ccy : constraints.getValues(CURVE_SENSITIVITY_CURRENCY)) {
+              for (String curve : constraints.getValues(CURVE)) {
+                ccyCurvePairs.add(ObjectsPair.of(ccy, curve));
+              }
+            }
+            functionNames.add(constraints.getSingleValue(FUNCTION));
+          }
+        }
+        if (ccyCurvePairs.isEmpty()) {
+          s_logger.error("Could not get currencies or curve name properties; have not been set in function(s) called {}", functionNames);
+          return null;
+        }
+        final Set<ValueSpecification> results = new HashSet<>();
+        for (Pair<String, String> ccyCurvePair : ccyCurvePairs) {
+          final ValueProperties properties = createValueProperties()
+              .with(PROPERTY_CURVE_TYPE, DISCOUNTING)
+              .withAny(CURVE_EXPOSURES)
+              .with(CURRENCY, ccyCurvePair.getFirst())
+              .with(CURVE_SENSITIVITY_CURRENCY, ccyCurvePair.getFirst())
+              .with(CURVE, ccyCurvePair.getSecond())
+              .get();
+          results.add(new ValueSpecification(YIELD_CURVE_NODE_SENSITIVITIES, target.toSpecification(), properties));
+        }
+        return results;
+      }
+      
+      @SuppressWarnings("synthetic-access")
+      @Override
+      protected Collection<ValueProperties.Builder> getResultProperties(final FunctionCompilationContext compilationContext, final ComputationTarget target) {
+        final ValueProperties.Builder properties = createValueProperties()
+            .with(PROPERTY_CURVE_TYPE, DISCOUNTING)
+            .withAny(CURVE_EXPOSURES)
+            .withAny(CURVE_SENSITIVITY_CURRENCY)
+            .withoutAny(CURRENCY)
+            .withAny(CURRENCY)
+            .withAny(CURVE);
+        return Collections.singleton(properties);
+      }
+
+    };
+    
+    
+  }
+
+}
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapAssetLegPVFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapAssetLegPVFunction.java
index a589b93..2bda955 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapAssetLegPVFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapAssetLegPVFunction.java
@@ -16,7 +16,7 @@ import org.threeten.bp.Instant;
 import com.google.common.collect.Iterables;
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
-import com.opengamma.analytics.financial.equity.EqyTrsAssetLegPresentValueCalculator;
+import com.opengamma.analytics.financial.equity.trs.EqyTrsAssetLegPresentValueCalculator;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapConstantSpreadThetaFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapConstantSpreadThetaFunction.java
index 247f07a..f910761 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapConstantSpreadThetaFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapConstantSpreadThetaFunction.java
@@ -22,7 +22,7 @@ import org.threeten.bp.ZonedDateTime;
 
 import com.google.common.collect.Iterables;
 import com.opengamma.OpenGammaRuntimeException;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.horizon.EqyTrsConstantSpreadHorizonCalculator;
 import com.opengamma.analytics.financial.horizon.HorizonCalculator;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegDetailsFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegDetailsFunction.java
index 5d7fffe..771e9a5 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegDetailsFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegDetailsFunction.java
@@ -16,8 +16,8 @@ import org.threeten.bp.LocalDate;
 import org.threeten.bp.ZonedDateTime;
 
 import com.google.common.collect.Iterables;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwapDefinition;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwapDefinition;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.instrument.annuity.AnnuityDefinition;
 import com.opengamma.analytics.financial.instrument.payment.PaymentDefinition;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegPVFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegPVFunction.java
index fd8812f..ffdeeba 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegPVFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapFundingLegPVFunction.java
@@ -20,7 +20,7 @@ import org.threeten.bp.Instant;
 import com.google.common.collect.Iterables;
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
-import com.opengamma.analytics.financial.equity.EqyTrsFundingLegPresentValueCalculator;
+import com.opengamma.analytics.financial.equity.trs.EqyTrsFundingLegPresentValueCalculator;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapGammaPV01Function.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapGammaPV01Function.java
index c73e45d..c76efe7 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapGammaPV01Function.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapGammaPV01Function.java
@@ -19,7 +19,7 @@ import org.threeten.bp.Instant;
 
 import com.google.common.collect.Iterables;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
-import com.opengamma.analytics.financial.equity.EqyTrsGammaPV01Calculator;
+import com.opengamma.analytics.financial.equity.trs.EqyTrsGammaPV01Calculator;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPV01Function.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPV01Function.java
index fbbebaf..2aed9f4 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPV01Function.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPV01Function.java
@@ -18,8 +18,8 @@ import java.util.Set;
 import org.threeten.bp.Instant;
 
 import com.google.common.collect.Iterables;
-import com.opengamma.analytics.financial.equity.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
+import com.opengamma.analytics.financial.equity.trs.EquityTotalReturnSwap;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPVFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPVFunction.java
index 020627f..43ef06c 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPVFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapPVFunction.java
@@ -16,7 +16,7 @@ import org.threeten.bp.Instant;
 import com.google.common.collect.Iterables;
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
-import com.opengamma.analytics.financial.equity.EqyTrsPresentValueCalculator;
+import com.opengamma.analytics.financial.equity.trs.EqyTrsPresentValueCalculator;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapValueDeltaFunction.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapValueDeltaFunction.java
index e970a8b..ed94e9a 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapValueDeltaFunction.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/EquityTotalReturnSwapValueDeltaFunction.java
@@ -16,7 +16,7 @@ import org.threeten.bp.Instant;
 import com.google.common.collect.Iterables;
 import com.opengamma.OpenGammaRuntimeException;
 import com.opengamma.analytics.financial.equity.EquityTrsDataBundle;
-import com.opengamma.analytics.financial.equity.EqyTrsValueDeltaCalculator;
+import com.opengamma.analytics.financial.equity.trs.EqyTrsValueDeltaCalculator;
 import com.opengamma.analytics.financial.forex.method.FXMatrix;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivative;
 import com.opengamma.analytics.financial.interestrate.InstrumentDerivativeVisitor;
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/TotalReturnSwapFunctions.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/TotalReturnSwapFunctions.java
index 939ca43..d875031 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/TotalReturnSwapFunctions.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/trs/TotalReturnSwapFunctions.java
@@ -28,12 +28,15 @@ public class TotalReturnSwapFunctions extends AbstractFunctionConfigurationBean
   protected void addAllConfigurations(final List<FunctionConfiguration> functions) {
     functions.add(functionConfiguration(BondTotalReturnSwapAssetLegDetailsFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapAssetLegPVFunction.class));
+    functions.add(functionConfiguration(BondTotalReturnSwapBCSFunction.class));
+    functions.add(functionConfiguration(BondTotalReturnSwapYCNSFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapConstantSpreadThetaFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapFundingLegDetailsFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapGammaPV01Function.class));
     functions.add(functionConfiguration(BondTotalReturnSwapFundingLegPVFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapPVFunction.class));
     functions.add(functionConfiguration(BondTotalReturnSwapPV01Function.class));
+    functions.add(functionConfiguration(BondTotalReturnSwapCurrencyExposureFunction.class));
 
     functions.add(functionConfiguration(EquityTotalReturnSwapAssetLegPVFunction.class));
     functions.add(functionConfiguration(EquityTotalReturnSwapFundingLegDetailsFunction.class));
diff --git a/projects/OG-Financial/src/main/java/com/opengamma/financial/convention/RUConventions.java b/projects/OG-Financial/src/main/java/com/opengamma/financial/convention/RUConventions.java
index 52cc782..215af7d 100644
--- a/projects/OG-Financial/src/main/java/com/opengamma/financial/convention/RUConventions.java
+++ b/projects/OG-Financial/src/main/java/com/opengamma/financial/convention/RUConventions.java
@@ -99,6 +99,10 @@ public class RUConventions {
       final ExternalId simple = simpleNameSecurityId(name);
       utils.addConventionBundle(ExternalIdBundle.of(tullett, simple), name, act360, following, Period.ofYears(i), 2, false, ru);
     }
+    
+    final String ruTreasuryName = "RU_TREASURY_BOND_CONVENTION";
+    utils.addConventionBundle(ExternalIdBundle.of(simpleNameSecurityId(ruTreasuryName)), ruTreasuryName, true, true, 0, 1, true);
+    
   }
 
 }
diff --git a/projects/OG-Integration/src/main/java/com/opengamma/integration/copier/snapshot/writer/CsvSnapshotWriter.java b/projects/OG-Integration/src/main/java/com/opengamma/integration/copier/snapshot/writer/CsvSnapshotWriter.java
index 6780cc7..38b4c15 100644
--- a/projects/OG-Integration/src/main/java/com/opengamma/integration/copier/snapshot/writer/CsvSnapshotWriter.java
+++ b/projects/OG-Integration/src/main/java/com/opengamma/integration/copier/snapshot/writer/CsvSnapshotWriter.java
@@ -35,7 +35,7 @@ import com.opengamma.util.tuple.Pair;
  */
 public class CsvSnapshotWriter implements SnapshotWriter {
 
-  private CsvSheetWriter _sheetWriter;
+  private final CsvSheetWriter _sheetWriter;
   private static final Logger s_logger = LoggerFactory.getLogger(CsvSnapshotWriter.class);
 
   public CsvSnapshotWriter(String filename) {
@@ -58,7 +58,7 @@ public class CsvSnapshotWriter implements SnapshotWriter {
 
       Pair<String, String> ordinals = MarketDataSnapshotToolUtils.ordinalsAsString(entry.getKey());
       String surfaceX  = ordinals.getFirst();
-      String surfaceY  = ordinals.getFirst();
+      String surfaceY  = ordinals.getSecond();
 
       tempRow.put(SnapshotColumns.SURFACE_X.get(), surfaceX);
       tempRow.put(SnapshotColumns.SURFACE_Y.get(), surfaceY);
diff --git a/projects/OG-Integration/src/main/java/com/opengamma/integration/marketdata/manipulator/dsl/VolatilitySurfaceSelector.java b/projects/OG-Integration/src/main/java/com/opengamma/integration/marketdata/manipulator/dsl/VolatilitySurfaceSelector.java
index bcacbfe..8731fcb 100644
--- a/projects/OG-Integration/src/main/java/com/opengamma/integration/marketdata/manipulator/dsl/VolatilitySurfaceSelector.java
+++ b/projects/OG-Integration/src/main/java/com/opengamma/integration/marketdata/manipulator/dsl/VolatilitySurfaceSelector.java
@@ -5,6 +5,7 @@
  */
 package com.opengamma.integration.marketdata.manipulator.dsl;
 
+import static com.opengamma.engine.value.ValueRequirementNames.BLACK_VOLATILITY_SURFACE;
 import static com.opengamma.engine.value.ValueRequirementNames.INTERPOLATED_VOLATILITY_SURFACE;
 import static com.opengamma.engine.value.ValueRequirementNames.VOLATILITY_SURFACE;
 
@@ -18,7 +19,6 @@ import com.opengamma.engine.marketdata.manipulator.DistinctMarketDataSelector;
 import com.opengamma.engine.marketdata.manipulator.SelectorResolver;
 import com.opengamma.engine.value.SurfaceAndCubePropertyNames;
 import com.opengamma.engine.value.ValuePropertyNames;
-import com.opengamma.engine.value.ValueRequirementNames;
 import com.opengamma.engine.value.ValueSpecification;
 import com.opengamma.id.UniqueId;
 import com.opengamma.util.ArgumentChecker;
@@ -28,7 +28,9 @@ import com.opengamma.util.ArgumentChecker;
  */
 public class VolatilitySurfaceSelector implements DistinctMarketDataSelector {
 
-  private static final ImmutableSet<String> s_compatibleVRNames = ImmutableSet.of(INTERPOLATED_VOLATILITY_SURFACE, VOLATILITY_SURFACE);
+  private static final ImmutableSet<String> s_compatibleVRNames = ImmutableSet.of(INTERPOLATED_VOLATILITY_SURFACE, 
+                                                                                  VOLATILITY_SURFACE, 
+                                                                                  BLACK_VOLATILITY_SURFACE);
   
   
   private final Set<String> _calcConfigNames;
diff --git a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/PermissionCheckProviderResult.java b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/PermissionCheckProviderResult.java
index 0aebfb5..caa1597 100644
--- a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/PermissionCheckProviderResult.java
+++ b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/PermissionCheckProviderResult.java
@@ -5,6 +5,7 @@
  */
 package com.opengamma.provider.permission;
 
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -36,6 +37,7 @@ import com.opengamma.util.PublicSPI;
  * It also contains error fields that provide more detail.
  * The map of checked permissions will contain no true values if there are errors
  * and will typically be empty.
+ * As such, there is no need for an {@code isErrors()} method.
  * <p>
  * This class is immutable and thread-safe.
  */
@@ -98,6 +100,23 @@ public final class PermissionCheckProviderResult implements ImmutableBean {
    * <p>
    * This method returns false rather than throwing an exception.
    * 
+   * @param requestedPermissions  the requested permissions, not null
+   * @return true if permitted, false if not
+   */
+  public boolean isPermittedAll(Collection<String> requestedPermissions) {
+    for (String requestedPermission : requestedPermissions) {
+      if (isPermitted(requestedPermission) == false) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Checks if the specified permission is true or false.
+   * <p>
+   * This method returns false rather than throwing an exception.
+   * 
    * @param requestedPermission  the requested permission, not null
    * @return true if permitted, false if not
    */
@@ -127,6 +146,7 @@ public final class PermissionCheckProviderResult implements ImmutableBean {
     }
   }
 
+  //-------------------------------------------------------------------------
   /**
    * Checks if any errors occurred, throwing an exception if there were errors.
    * <p>
diff --git a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermission.java b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermission.java
index ba7a9d3..ff25c22 100644
--- a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermission.java
+++ b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermission.java
@@ -5,12 +5,20 @@
  */
 package com.opengamma.provider.permission.impl;
 
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
 import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.UnauthenticatedException;
 
 import com.opengamma.core.user.UserPrincipals;
 import com.opengamma.provider.permission.PermissionCheckProvider;
+import com.opengamma.provider.permission.PermissionCheckProviderRequest;
+import com.opengamma.provider.permission.PermissionCheckProviderResult;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.auth.AuthUtils;
+import com.opengamma.util.auth.ExtendedPermission;
 
 /**
  * An Apache Shiro permission that uses a {@code PermissionCheckProvider}.
@@ -18,7 +26,7 @@ import com.opengamma.util.auth.AuthUtils;
  * This uses the underlying provider to check permissions.
  * See {@link ProviderBasedPermissionResolver} for public access.
  */
-final class ProviderBasedPermission implements Permission {
+final class ProviderBasedPermission implements ExtendedPermission {
 
   /**
    * The underlying provider.
@@ -41,19 +49,70 @@ final class ProviderBasedPermission implements Permission {
   }
 
   //-------------------------------------------------------------------------
+  private String getPermissionString() {
+    return _permissionString;
+  }
+
+  //-------------------------------------------------------------------------
   // this permission is the permission I have
   // the other permission is the permission being checked
   @Override
-  public boolean implies(Permission requestedPermission) {
-    if (requestedPermission instanceof ProviderBasedPermission == false) {
+  public boolean implies(Permission requiredPermission) {
+    if (requiredPermission instanceof ProviderBasedPermission == false) {
       return false;
     }
-    ProviderBasedPermission requestedPerm = (ProviderBasedPermission) requestedPermission;
+    ProviderBasedPermission requiredPerm = (ProviderBasedPermission) requiredPermission;
     UserPrincipals user = (UserPrincipals) AuthUtils.getSubject().getSession().getAttribute(UserPrincipals.ATTRIBUTE_KEY);
     if (user == null) {
       return false;
     }
-    return _provider.isPermitted(user.getAlternateIds(), user.getNetworkAddress(), requestedPerm._permissionString);
+    return _provider.isPermitted(user.getAlternateIds(), user.getNetworkAddress(), requiredPerm.getPermissionString());
+  }
+
+  @Override
+  public boolean checkImplies(Permission requiredPermission) {
+    if (requiredPermission instanceof ProviderBasedPermission == false) {
+      return false;
+    }
+    ProviderBasedPermission requiredPerm = (ProviderBasedPermission) requiredPermission;
+    UserPrincipals user = (UserPrincipals) AuthUtils.getSubject().getSession().getAttribute(UserPrincipals.ATTRIBUTE_KEY);
+    if (user == null) {
+      throw new UnauthenticatedException("Permission denied: User not logged in: " + requiredPermission);
+    }
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(
+        user.getAlternateIds(), user.getNetworkAddress(), requiredPerm.getPermissionString());
+    PermissionCheckProviderResult result = _provider.isPermitted(request);
+    result.checkErrors();
+    return result.isPermitted(requiredPerm.getPermissionString());
+  }
+
+  @Override
+  public Boolean checkImpliesAll(Collection<Permission> requiredPermissions, boolean exceptionsOnError) {
+    if (requiredPermissions.isEmpty()) {
+      return Boolean.TRUE;
+    }
+    Set<String> required = new HashSet<>();
+    for (Permission requiredPermission : requiredPermissions) {
+      if (requiredPermission instanceof ProviderBasedPermission == false) {
+        return null;
+      }
+      required.add(((ProviderBasedPermission) requiredPermission).getPermissionString());
+    }
+    UserPrincipals user = (UserPrincipals) AuthUtils.getSubject().getSession().getAttribute(UserPrincipals.ATTRIBUTE_KEY);
+    if (user == null) {
+      if (exceptionsOnError) {
+        throw new UnauthenticatedException("Permission denied: User not logged in: " + required);
+      } else {
+        return Boolean.FALSE;
+      }
+    }
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(
+        user.getAlternateIds(), user.getNetworkAddress(), required);
+    PermissionCheckProviderResult result = _provider.isPermitted(request);
+    if (exceptionsOnError) {
+      result.checkErrors();
+    }
+    return Boolean.valueOf(result.isPermittedAll(required));
   }
 
   //-------------------------------------------------------------------------
@@ -61,19 +120,19 @@ final class ProviderBasedPermission implements Permission {
   public boolean equals(Object obj) {
     if (obj instanceof ProviderBasedPermission) {
       ProviderBasedPermission other = (ProviderBasedPermission) obj;
-      return _permissionString.equals(other._permissionString);
+      return getPermissionString().equals(other.getPermissionString());
     }
     return false;
   }
 
   @Override
   public int hashCode() {
-    return _permissionString.hashCode();
+    return getPermissionString().hashCode();
   }
 
   @Override
   public String toString() {
-    return _permissionString;
+    return getPermissionString();
   }
 
 }
diff --git a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionResolver.java b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionResolver.java
index d698817..769cff8 100644
--- a/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionResolver.java
+++ b/projects/OG-Provider/src/main/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionResolver.java
@@ -6,21 +6,26 @@
 package com.opengamma.provider.permission.impl;
 
 import org.apache.shiro.authz.Permission;
-import org.apache.shiro.authz.permission.PermissionResolver;
 
 import com.opengamma.provider.permission.PermissionCheckProvider;
 import com.opengamma.util.ArgumentChecker;
 import com.opengamma.util.auth.AuthUtils;
+import com.opengamma.util.auth.PrefixedPermissionResolver;
+import com.opengamma.util.auth.ShiroPermissionResolver;
 
 /**
  * An Apache Shiro permission resolver that uses a {@code PermissionCheckProvider}.
  * <p>
- * Instances of this class are registered using {@code ShiroPermissionResolver#registerPrefix}
+ * Instances of this class are registered using {@link ShiroPermissionResolver#register(PrefixedPermissionResolver)}
  * accessed via {@link AuthUtils#getPermissionResolver()}.
  */
-public final class ProviderBasedPermissionResolver implements PermissionResolver {
+public final class ProviderBasedPermissionResolver implements PrefixedPermissionResolver {
 
   /**
+   * The permission prefix.
+   */
+  private final String _prefix;
+  /**
    * The underlying provider.
    */
   private final PermissionCheckProvider _provider;
@@ -28,14 +33,21 @@ public final class ProviderBasedPermissionResolver implements PermissionResolver
   /**
    * Creates an instance.
    * 
+   * @param prefix  the permission prefix, not null
    * @param provider  the underlying permission check provider, not null
    */
-  public ProviderBasedPermissionResolver(PermissionCheckProvider provider) {
+  public ProviderBasedPermissionResolver(String prefix, PermissionCheckProvider provider) {
+    _prefix = ArgumentChecker.notNull(prefix, "prefix");
     _provider = ArgumentChecker.notNull(provider, "provider");
   }
 
   //-------------------------------------------------------------------------
   @Override
+  public String getPrefix() {
+    return _prefix;
+  }
+
+  @Override
   public Permission resolvePermission(String permissionString) {
     return new ProviderBasedPermission(_provider, permissionString);
   }
diff --git a/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/PermissionCheckProviderResultTest.java b/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/PermissionCheckProviderResultTest.java
new file mode 100644
index 0000000..5f5b5e0
--- /dev/null
+++ b/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/PermissionCheckProviderResultTest.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.provider.permission.impl;
+
+import static org.testng.AssertJUnit.assertFalse;
+import static org.testng.AssertJUnit.assertTrue;
+
+import org.apache.shiro.authz.AuthorizationException;
+import org.apache.shiro.authz.UnauthenticatedException;
+import org.testng.annotations.Test;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.opengamma.provider.permission.PermissionCheckProviderResult;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * Test.
+ */
+@Test(groups = TestGroup.UNIT)
+public class PermissionCheckProviderResultTest {
+
+  @Test
+  public void isPermitted() {
+    ImmutableMap<String, Boolean> checked = ImmutableMap.of("Data:12345", Boolean.FALSE, "Data:67890", Boolean.TRUE);
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(checked);
+    assertFalse(result.isPermitted("Data:12345"));
+    assertTrue(result.isPermitted("Data:67890"));
+    assertFalse(result.isPermittedAll(ImmutableList.of("Data:12345")));
+    assertTrue(result.isPermittedAll(ImmutableList.of("Data:67890")));
+    assertFalse(result.isPermittedAll(ImmutableList.of("Data:12345", "Data:67890")));
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void isPermittedUnauthenticated() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthenticationError("Not authenticated");
+    assertFalse(result.isPermitted("Data:12345"));
+    assertFalse(result.isPermittedAll(ImmutableList.of("Data:12345")));
+  }
+
+  @Test(expectedExceptions = UnauthenticatedException.class)
+  public void checkPermittedUnauthenticated() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthenticationError("Not authenticated");
+    result.checkPermitted("Data:12345");
+  }
+
+  @Test(expectedExceptions = UnauthenticatedException.class)
+  public void checkErrorsUnauthenticated() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthenticationError("Not authenticated");
+    result.checkErrors();
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void isPermittedUnauthorized() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthorizationError("Not authorized");
+    assertFalse(result.isPermitted("Data:12345"));
+    assertFalse(result.isPermittedAll(ImmutableList.of("Data:12345")));
+  }
+
+  @Test(expectedExceptions = AuthorizationException.class)
+  public void checkPermittedUnauthorized() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthorizationError("Not authorized");
+    result.checkPermitted("Data:12345");
+  }
+
+  @Test(expectedExceptions = AuthorizationException.class)
+  public void checkErrorsUnauthorized() {
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthorizationError("Not authorized");
+    result.checkErrors();
+  }
+
+}
diff --git a/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionTest.java b/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionTest.java
index 9192fa6..8ab8e3a 100644
--- a/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionTest.java
+++ b/projects/OG-Provider/src/test/java/com/opengamma/provider/permission/impl/ProviderBasedPermissionTest.java
@@ -7,33 +7,41 @@ package com.opengamma.provider.permission.impl;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
+import static org.testng.AssertJUnit.assertEquals;
 import static org.testng.AssertJUnit.assertFalse;
 import static org.testng.AssertJUnit.assertTrue;
 
+import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.UnauthenticatedException;
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.util.ThreadContext;
 import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.opengamma.core.user.UserPrincipals;
 import com.opengamma.core.user.impl.SimpleUserPrincipals;
 import com.opengamma.id.ExternalIdBundle;
 import com.opengamma.provider.permission.PermissionCheckProvider;
+import com.opengamma.provider.permission.PermissionCheckProviderRequest;
+import com.opengamma.provider.permission.PermissionCheckProviderResult;
 import com.opengamma.util.auth.AuthUtils;
 import com.opengamma.util.auth.ShiroPermissionResolver;
 import com.opengamma.util.test.TestGroup;
-import com.opengamma.util.test.TestUtils;
 
 /**
  * Test.
  */
-@Test(groups = TestGroup.UNIT)
+@Test(groups = TestGroup.UNIT, singleThreaded = true)
 public class ProviderBasedPermissionTest {
 
-  private static final Permission SHIRO_PERM = new ShiroPermissionResolver().resolvePermission("Data:12345");
+  private static final Permission WILDCARD_PERM = new ShiroPermissionResolver().resolvePermission("Data:12345");
   private static final ExternalIdBundle USER_BUNDLE = ExternalIdBundle.of("DATAUSER", "TEST");
   private static final UserPrincipals PRINCIPALS;
   static {
-    TestUtils.initSecurity();
     SimpleUserPrincipals principals = new SimpleUserPrincipals();
     principals.setUserName("Tester");
     principals.setAlternateIds(USER_BUNDLE);
@@ -41,11 +49,18 @@ public class ProviderBasedPermissionTest {
     PRINCIPALS = principals;
   }
 
+  @BeforeMethod
+  public void setUp() {
+    ThreadContext.bind(new DefaultSecurityManager());
+  }
+
   @AfterMethod
   public void tearDown() {
-    AuthUtils.getSubject().getSession().removeAttribute(UserPrincipals.ATTRIBUTE_KEY);
+    ThreadContext.unbindSubject();
+    ThreadContext.unbindSecurityManager();
   }
 
+  //-------------------------------------------------------------------------
   @Test
   public void impliesTrue() {
     AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
@@ -67,11 +82,163 @@ public class ProviderBasedPermissionTest {
   }
 
   @Test
-  public void impliesFalseAgainstShiroPermission() {
+  public void impliesFalseAgainstWildcardPermission() {
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data:12345");
+    assertFalse(test.implies(WILDCARD_PERM));
+    assertFalse(WILDCARD_PERM.implies(test));
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void checkImpliesTrue() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.TRUE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test1 = new ProviderBasedPermission(provider, "Data");
+    ProviderBasedPermission test2 = new ProviderBasedPermission(provider, "Data:12345");
+    assertTrue(test1.checkImplies(test2));
+  }
+
+  @Test
+  public void checkImpliesFalse() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.FALSE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test1 = new ProviderBasedPermission(provider, "Data");
+    ProviderBasedPermission test2 = new ProviderBasedPermission(provider, "Data:12345");
+    assertFalse(test1.checkImplies(test2));
+  }
+
+  @Test(expectedExceptions = UnauthenticatedException.class)
+  public void checkImpliesUnauthenticated() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthenticationError("Not authenticated");
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test1 = new ProviderBasedPermission(provider, "Data");
+    ProviderBasedPermission test2 = new ProviderBasedPermission(provider, "Data:12345");
+    test1.checkImplies(test2);
+  }
+
+  @Test(expectedExceptions = AuthorizationException.class)
+  public void checkImpliesUnauthorized() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthorizationError("Not authorized");
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test1 = new ProviderBasedPermission(provider, "Data");
+    ProviderBasedPermission test2 = new ProviderBasedPermission(provider, "Data:12345");
+    test1.checkImplies(test2);
+  }
+
+  @Test
+  public void checkImpliesFalseAgainstWildcardPermission() {
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data:12345");
+    assertFalse(test.checkImplies(WILDCARD_PERM));
+  }
+
+  //-------------------------------------------------------------------------
+  @Test
+  public void checkImpliesAllOneTrue() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.TRUE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1), true));
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1), false));
+  }
+
+  @Test
+  public void checkImpliesAllManyTrue() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(
+        USER_BUNDLE, "1.1.1.1", "Data:12345", "Data:67890");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.TRUE, "Data:67890", Boolean.TRUE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    Permission required2 = new ProviderBasedPermission(provider, "Data:67890");
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1, required2), true));
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1, required2), false));
+  }
+
+  @Test
+  public void checkImpliesAllOneFalse() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.FALSE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    assertFalse(test.checkImpliesAll(ImmutableList.of(required1), true));
+    assertFalse(test.checkImpliesAll(ImmutableList.of(required1), false));
+  }
+
+  @Test
+  public void checkImpliesAllManyFalse() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(
+        USER_BUNDLE, "1.1.1.1", "Data:12345", "Data:67890");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.of(
+        ImmutableMap.of("Data:12345", Boolean.FALSE, "Data:67890", Boolean.TRUE));
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    Permission required2 = new ProviderBasedPermission(provider, "Data:67890");
+    assertFalse(test.checkImpliesAll(ImmutableList.of(required1, required2), true));
+    assertFalse(test.checkImpliesAll(ImmutableList.of(required1, required2), false));
+  }
+
+  @Test(expectedExceptions = UnauthenticatedException.class)
+  public void checkImpliesAllUnauthenticated() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthenticationError("Not authenticated");
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1), true));
+  }
+
+  @Test(expectedExceptions = AuthorizationException.class)
+  public void checkImpliesAllUnauthorized() {
+    AuthUtils.getSubject().getSession().setAttribute(UserPrincipals.ATTRIBUTE_KEY, PRINCIPALS);
+    PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
+    PermissionCheckProviderRequest request = PermissionCheckProviderRequest.createGet(USER_BUNDLE, "1.1.1.1", "Data:12345");
+    PermissionCheckProviderResult result = PermissionCheckProviderResult.ofAuthorizationError("Not authorized");
+    when(provider.isPermitted(request)).thenReturn(result);
+    ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data");
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    assertTrue(test.checkImpliesAll(ImmutableList.of(required1), true));
+  }
+
+  @Test
+  public void checkImpliesAllAgainstWildcardPermission() {
     PermissionCheckProvider provider = mock(PermissionCheckProvider.class);
     ProviderBasedPermission test = new ProviderBasedPermission(provider, "Data:12345");
-    assertFalse(test.implies(SHIRO_PERM));
-    assertFalse(SHIRO_PERM.implies(test));
+    Permission required1 = new ProviderBasedPermission(provider, "Data:12345");
+    assertEquals(null, test.checkImpliesAll(ImmutableList.of(required1, WILDCARD_PERM), true));
+    assertEquals(null, test.checkImpliesAll(ImmutableList.of(required1, WILDCARD_PERM), false));
   }
 
 }
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/StartupUtils.java b/projects/OG-Util/src/main/java/com/opengamma/util/StartupUtils.java
index 492476d..a8d7e2c 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/StartupUtils.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/StartupUtils.java
@@ -5,8 +5,6 @@
  */
 package com.opengamma.util;
 
-import com.opengamma.util.auth.AuthUtils;
-
 /**
  * Utility method to be run at system startup.
  */
@@ -31,8 +29,6 @@ public final class StartupUtils {
       if (System.getProperties().containsKey("org.terracotta.quartz.skipUpdateCheck") == false) {
         System.setProperty("org.terracotta.quartz.skipUpdateCheck", "true");
       }
-      // setup permissive security manager
-      AuthUtils.initPermissive();
       
     } catch (SecurityException ex) {
       // ignore silently
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/AuthUtils.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/AuthUtils.java
index 03e959a..466f148 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/auth/AuthUtils.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/AuthUtils.java
@@ -8,11 +8,13 @@ package com.opengamma.util.auth;
 import java.util.Set;
 
 import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.UnavailableSecurityManagerException;
+import org.apache.shiro.ShiroException;
 import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.Permission;
 import org.apache.shiro.authz.permission.PermissionResolver;
+import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.ThreadContext;
 
 import com.opengamma.util.ArgumentChecker;
 
@@ -21,13 +23,18 @@ import com.opengamma.util.ArgumentChecker;
  * <p>
  * This class is used instead of the standard Apache Shiro {@code SecurityUtils}.
  */
-public final class AuthUtils extends SecurityUtils {
+public final class AuthUtils {
 
   /**
    * The singleton permission resolver.
    */
   private static final ShiroPermissionResolver s_permissionResolver = new ShiroPermissionResolver();
 
+  // always setup a security manager
+  static {
+    SecurityUtils.setSecurityManager(PermissiveSecurityManager.DEFAULT);
+  }
+
   /**
    * Restricted constructor.
    */
@@ -52,11 +59,44 @@ public final class AuthUtils extends SecurityUtils {
 
   //-------------------------------------------------------------------------
   /**
+   * Gets the single shared security manager.
+   * <p>
+   * The shared security manager is used as a fallback when there is no manager
+   * in the {@link ThreadContext}.
+   * This will return a permissive security manager by default.
+   * 
+   * @return the security manager, not null
+   */
+  public static SecurityManager getSecurityManager() {
+    return SecurityUtils.getSecurityManager();
+  }
+
+  /**
+   * Sets the single shared security manager.
+   * <p>
+   * The shared security manager is used as a fallback when there is no manager
+   * in the {@link ThreadContext}.
+   * This method can only be called if the current manager is permissive.
+   * 
+   * @param securityManager  the new security manager, not null
+   */
+  public static void initSecurityManager(SecurityManager securityManager) {
+    if (isPermissive()) {
+      SecurityUtils.setSecurityManager(securityManager);
+    } else {
+      throw new ShiroException("A security manager cannot be changed once set");
+    }
+  }
+
+  /**
    * Initializes the authentication and authorization system to permissive mode.
    * Permissive mode has a logged on user with all permissions granted.
+   * <p>
+   * This is used during startup to deliberately select a mode of operation
+   * where security is switched off.
    */
-  public static void initPermissive() {
-    setSecurityManager(new PermissiveSecurityManager());
+  public static void initSecurityManagerPermissive() {
+    initSecurityManager(new PermissiveSecurityManager());
   }
 
   /**
@@ -64,12 +104,21 @@ public final class AuthUtils extends SecurityUtils {
    * Permissive mode has a logged on user with all permissions granted.
    * 
    * @return true if permissive
-   * @throws UnavailableSecurityManagerException if no security manager is installed
    */
   public static boolean isPermissive() {
     return getSecurityManager() instanceof PermissiveSecurityManager;
   }
 
+  /**
+   * Checks if the authentication and authorization system is still in the
+   * default permissive mode.
+   * 
+   * @return true if the security manager has not been set
+   */
+  public static boolean isDefault() {
+    return getSecurityManager() == PermissiveSecurityManager.DEFAULT;
+  }
+
   //-------------------------------------------------------------------------
   /**
    * Returns the {@code Subject} available to the calling code, typically based on a thread-local.
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ExtendedPermission.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ExtendedPermission.java
new file mode 100644
index 0000000..91d165a
--- /dev/null
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ExtendedPermission.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.auth;
+
+import java.util.Collection;
+
+import org.apache.shiro.authz.AuthorizationException;
+import org.apache.shiro.authz.Permission;
+
+/**
+ * An extension to the Apache Shiro {@code Permission} interface.
+ * <p>
+ * This extension supports the check operation which can throw exceptions.
+ * This allows implementations to throw meaningful exceptions.
+ * See {@link ShiroPermissionResolver} for public access to permissions.
+ * <p>
+ * This extension also supports bulk checking of permissions for efficiency.
+ * This is most useful if a remote call is involved.
+ */
+public interface ExtendedPermission extends Permission {
+
+  /**
+   * Checks that this permission implies the required permission.
+   * <p>
+   * This object will be the permission of the subject user.
+   * The specified permission is the one that is required.
+   * This only differs from {@link #implies(Permission)} in that this
+   * method is allowed to throw an exception if there was a problem
+   * determining the permission status.
+   * 
+   * @param requiredPermission  the required permission, not null
+   * @return true if implied, false if not implied or type not recognized
+   * @throws AuthorizationException if an exception occurred while determining the result
+   */
+  boolean checkImplies(Permission requiredPermission);
+
+  /**
+   * Checks that this permission implies all of the required permissions.
+   * <p>
+   * This object will be the permission of the subject user.
+   * The specified permissions are the ones that are required.
+   * <p>
+   * The optional exception is only thrown if there was a problem
+   * determining the permission status.
+   * A normal permission denied result is indicated by returning false.
+   * 
+   * @param requiredPermissions  the required permissions, not null
+   * @param exceptionsOnError  whether to allow meaningful exceptions
+   * @return true if all permissions checked and implied,
+   *  false if all permissions checked and at least one is not implied,
+   *  null if permissions not fully checked
+   * @throws AuthorizationException if an exception occurred while determining the result,
+   *  only thrown if {@code allowExceptions} is true
+   */
+  Boolean checkImpliesAll(Collection<Permission> requiredPermissions, boolean exceptionsOnError);
+
+}
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/PermissiveSecurityManager.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/PermissiveSecurityManager.java
index 32ed0cf..4096ac0 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/auth/PermissiveSecurityManager.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/PermissiveSecurityManager.java
@@ -21,7 +21,12 @@ import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
 /**
  * An Apache Shiro {@code SecurityManager} that permits everything.
  */
-public class PermissiveSecurityManager extends DefaultWebSecurityManager {
+public final class PermissiveSecurityManager extends DefaultWebSecurityManager {
+
+  /**
+   * The default security manager
+   */
+  static final PermissiveSecurityManager DEFAULT = new PermissiveSecurityManager();
 
   /**
    * Creates an instance.
@@ -46,7 +51,7 @@ public class PermissiveSecurityManager extends DefaultWebSecurityManager {
   /**
    * An Apache Shiro {@code Realm} that permits everything.
    */
-  public class PermissiveRealm extends AuthorizingRealm {
+  class PermissiveRealm extends AuthorizingRealm {
 
     @Override
     protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/PrefixedPermissionResolver.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/PrefixedPermissionResolver.java
new file mode 100644
index 0000000..cdc62e9
--- /dev/null
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/PrefixedPermissionResolver.java
@@ -0,0 +1,39 @@
+/**
+ * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.auth;
+
+import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.permission.InvalidPermissionStringException;
+import org.apache.shiro.authz.permission.PermissionResolver;
+
+/**
+ * Resolves Apache Shiro {@code Permission} instances from strings.
+ * <p>
+ * This resolver acts as a factory for {@code Permission} instances.
+ * Most permissions are resolved by {@link ShiroPermissionResolver} into
+ * {@link ShiroWildcardPermission} instances. However, permissions that
+ * have a registered prefix are resolved using this interface.
+ */
+public interface PrefixedPermissionResolver extends PermissionResolver {
+
+  /**
+   * Gets the prefix that this resolver matches.
+   * 
+   * @return the prefix for matched permission strings, not null
+   */
+  String getPrefix();
+
+  /**
+   * Resolves a single permission from the string form.
+   *
+   * @param permissionString  the string representation of a permission, not null
+   * @return the equivalent permission object, not null
+   * @throws InvalidPermissionStringException if the permission string is invalid
+   */
+  @Override
+  Permission resolvePermission(String permissionString);
+
+}
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermission.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermission.java
deleted file mode 100644
index 711c7ee..0000000
--- a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermission.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.util.auth;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.text.StrBuilder;
-import org.apache.shiro.authz.Permission;
-import org.apache.shiro.authz.permission.InvalidPermissionStringException;
-import org.apache.shiro.authz.permission.WildcardPermission;
-
-import com.google.common.collect.ImmutableSet;
-
-/**
- * An Apache Shiro {@code Permission} that allows permission resolving to be extended.
- * <p>
- * This is a faster version of {@link WildcardPermission}.
- * See {@link ShiroPermissionResolver} for public access.
- */
-final class ShiroPermission implements Permission {
-
-  /**
-   * The wildcard segment.
-   */
-  private static final ImmutableSet<String> WILDCARD_SEGMENT = ImmutableSet.of("*");
-
-  /**
-   * The permission segments.
-   */
-  private final List<Set<String>> _segments = new ArrayList<>();
-  /**
-   * The hash code.
-   */
-  private final int _hashCode;
-  /**
-   * The string form.
-   */
-  private final String _toString;
-
-  /**
-   * Creates an instance.
-   * 
-   * @param permissionString  the permission string, not null
-   * @return the permission object, not null
-   * @throws InvalidPermissionStringException if the permission string is invalid
-   */
-  static Permission of(String permissionString) {
-    return new ShiroPermission(permissionString);
-  }
-
-  //-------------------------------------------------------------------------
-  /**
-   * Creates an instance.
-   * 
-   * @param permissionString  the permission string, not null
-   * @throws InvalidPermissionStringException if the permission string is invalid
-   */
-  private ShiroPermission(final String permissionString) {
-    String permStr = StringUtils.stripToNull(permissionString);
-    if (permStr == null) {
-      throw new InvalidPermissionStringException("Permission string must not be blank: " + permissionString, permissionString);
-    }
-    // case insensitive
-    permStr = permStr.toLowerCase(Locale.ROOT);
-    // split once
-    List<Set<String>> wildcardSegments = new ArrayList<>();
-    String[] segmentStrs = StringUtils.splitPreserveAllTokens(permStr, ':');
-    for (String segmentStr : segmentStrs) {
-      String[] partStrs = StringUtils.splitPreserveAllTokens(segmentStr, ',');
-      if (partStrs.length == 0) {
-        throw new InvalidPermissionStringException("Permission string must not contain an empty segment: " + permissionString, permissionString);
-      }
-      Set<String> parts = new LinkedHashSet<>();
-      for (String partStr : partStrs) {
-        partStr = partStr.trim();
-        if (partStr.isEmpty()) {
-          throw new InvalidPermissionStringException("Permission string must not contain an empty part: " + permissionString, permissionString);
-        }
-        if (partStr.contains("*") && partStr.equals("*") == false) {
-          throw new InvalidPermissionStringException("Permission string wildcard can only be applied to whole segment: " + permissionString, permissionString);
-        }
-        parts.add(partStr);
-      }
-      // simplify
-      if (parts.contains("*")) {
-        wildcardSegments.add(WILDCARD_SEGMENT);
-      } else {
-        _segments.addAll(wildcardSegments);
-        wildcardSegments.clear();
-        _segments.add(parts);
-      }
-    }
-    _hashCode = _segments.hashCode();
-    _toString = createToString(_segments);
-  }
-
-  private static String createToString(List<Set<String>> segments) {
-    StrBuilder buf = new StrBuilder();
-    for (Iterator<Set<String>> it1 = segments.iterator(); it1.hasNext();) {
-      for (Iterator<String> it2 = it1.next().iterator(); it2.hasNext();) {
-        buf.append(it2.next());
-        if (it2.hasNext()) {
-          buf.append(',');
-        }
-      }
-      if (it1.hasNext()) {
-        buf.append(':');
-      }
-    }
-    return buf.toString();
-  }
-
-  //-------------------------------------------------------------------------
-  // this permission is the permission I have
-  // the other permission is the permission being checked
-  @Override
-  public boolean implies(Permission permission) {
-    if (permission instanceof ShiroPermission == false) {
-      return false;
-    }
-    ShiroPermission perm = (ShiroPermission) permission;
-    List<Set<String>> thisSegments = _segments;
-    List<Set<String>> otherSegments = perm._segments;
-    if (thisSegments.size() > otherSegments.size()) {
-      return false;
-    }
-    int commonLen = Math.min(thisSegments.size(), otherSegments.size());
-    for (int i = 0; i < commonLen; i++) {
-      Set<String> thisSegment = thisSegments.get(i);
-      Set<String> otherSegment = otherSegments.get(i);
-      if (thisSegment != WILDCARD_SEGMENT && thisSegment.containsAll(otherSegment) == false) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  //-------------------------------------------------------------------------
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof ShiroPermission) {
-      ShiroPermission other = (ShiroPermission) obj;
-      return _segments.equals(other._segments);
-    }
-    return false;
-  }
-
-  @Override
-  public int hashCode() {
-    return _hashCode;
-  }
-
-  @Override
-  public String toString() {
-    return _toString;
-  }
-
-}
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermissionResolver.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermissionResolver.java
index 316e3fb..3d4f96c 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermissionResolver.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroPermissionResolver.java
@@ -6,13 +6,13 @@
 package com.opengamma.util.auth;
 
 import java.util.Collection;
-import java.util.HashSet;
-import java.util.Map.Entry;
-import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.UnauthenticatedException;
+import org.apache.shiro.authz.UnauthorizedException;
 import org.apache.shiro.authz.permission.InvalidPermissionStringException;
 import org.apache.shiro.authz.permission.PermissionResolver;
 
@@ -20,6 +20,8 @@ import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.opengamma.util.ArgumentChecker;
 
@@ -57,7 +59,7 @@ public final class ShiroPermissionResolver implements PermissionResolver {
    * A pluggable set of resolvers by prefix.
    * Registration should occur only during startup, but still need concurrent map.
    */
-  private final ConcurrentMap<String, PermissionResolver> _prefixResolvers = new ConcurrentHashMap<>(16, 0.75f, 1);
+  private final ConcurrentMap<String, PrefixedPermissionResolver> _prefixed = new ConcurrentHashMap<>(16, 0.75f, 1);
 
   /**
    * Creates an instance.
@@ -67,16 +69,17 @@ public final class ShiroPermissionResolver implements PermissionResolver {
 
   //-------------------------------------------------------------------------
   /**
-   * Registers a prefix that maps to a different permission resolver.
+   * Registers a factory that handles permissions with a specific prefix.
+   * <p>
+   * This allows different implementations of the {@code Permission} interface
+   * to be created based on a prefix.
    * 
-   * @param prefix  the permission prefix, not null
    * @param resolver  the permission resolver, not null
    * @throws IllegalArgumentException if the prefix is already registered
    */
-  public void registerPrefix(String prefix, PermissionResolver resolver) {
-    ArgumentChecker.notNull(prefix, "prefix");
+  public void register(PrefixedPermissionResolver resolver) {
     ArgumentChecker.notNull(resolver, "resolver");
-    PermissionResolver existing = _prefixResolvers.putIfAbsent(prefix, resolver);
+    PrefixedPermissionResolver existing = _prefixed.putIfAbsent(resolver.getPrefix(), resolver);
     if (existing != null && existing.equals(resolver) == false) {
       throw new IllegalArgumentException("Prefix is already registered");
     }
@@ -113,13 +116,122 @@ public final class ShiroPermissionResolver implements PermissionResolver {
    * @return the set of permission objects, not null
    * @throws InvalidPermissionStringException if the permission string is invalid
    */
-  public Set<Permission> resolvePermissions(Collection<String> permissionStrings) {
+  public ImmutableList<Permission> resolvePermissions(String... permissionStrings) {
     ArgumentChecker.notNull(permissionStrings, "permissionStrings");
-    Set<Permission> permissions = new HashSet<>();
+    ImmutableList.Builder<Permission> builder = ImmutableList.builder();
     for (String permissionString : permissionStrings) {
-      permissions.add(resolvePermission(permissionString));
+      builder.add(resolvePermission(permissionString));
     }
-    return permissions;
+    return builder.build();
+  }
+
+  /**
+   * Resolves a set of permissions from string to object form.
+   * <p>
+   * The returned set of permissions may be smaller than the input set.
+   * 
+   * @param permissionStrings  the set of permission strings, not null
+   * @return the set of permission objects, not null
+   * @throws InvalidPermissionStringException if the permission string is invalid
+   */
+  public ImmutableSet<Permission> resolvePermissions(Collection<String> permissionStrings) {
+    ArgumentChecker.notNull(permissionStrings, "permissionStrings");
+    ImmutableSet.Builder<Permission> builder = ImmutableSet.builder();
+    for (String permissionString : permissionStrings) {
+      builder.add(resolvePermission(permissionString));
+    }
+    return builder.build();
+  }
+
+  //-------------------------------------------------------------------------
+  /**
+   * Checks if the subject permissions grant all the required permissions.
+   * <p>
+   * The first collection contains the set of permissions held by the subject.
+   * The second collection contains the permissions that are required.
+   * This returns true if the set of subject permissions grants all the required permissions.
+   * 
+   * @param subjectPermissions  the set of permissions held by the subject, not null
+   * @param requiredPermissions  the permissions that are required, not null
+   * @return true if all the required permissions are granted
+   */
+  public boolean isPermittedAll(Collection<Permission> subjectPermissions, Collection<Permission> requiredPermissions) {
+    // try bulk check
+    for (Permission subjectPermission : subjectPermissions) {
+      if (subjectPermission instanceof ExtendedPermission) {
+        ExtendedPermission subjectPerm = (ExtendedPermission) subjectPermission;
+        Boolean implied = subjectPerm.checkImpliesAll(requiredPermissions, false);
+        if (implied != null) {
+          return implied.booleanValue();
+        }
+      }
+    }
+    // normal non-bulk check
+    for (Permission requiredPermission : requiredPermissions) {
+      if (implies(subjectPermissions, requiredPermission) == false) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  // does one of the subject permissions imply the required permission
+  private boolean implies(Collection<? extends Permission> subjectPermissions, Permission requiredPermission) {
+    for (Permission subjectPermission : subjectPermissions) {
+      if (subjectPermission.implies(requiredPermission)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Checks if the subject permissions grant all the required permissions.
+   * <p>
+   * The first collection contains the set of permissions held by the subject.
+   * The second collection contains the permissions that are required.
+   * This returns true if the set of subject permissions grants all the required permissions.
+   * 
+   * @param subjectPermissions  the set of permissions held by the subject, not null
+   * @param requiredPermissions  the permissions that are required, not null
+   * @throws UnauthenticatedException if permission was denied due to invalid user authentication
+   * @throws UnauthorizedException if the user does not have the requested permission
+   * @throws AuthorizationException if permission was denied due to some other issue
+   */
+  public void checkPermissions(Collection<Permission> subjectPermissions, Collection<Permission> requiredPermissions) {
+    // try bulk check
+    for (Permission subjectPermission : subjectPermissions) {
+      if (subjectPermission instanceof ExtendedPermission) {
+        ExtendedPermission subjectPerm = (ExtendedPermission) subjectPermission;
+        Boolean implied = subjectPerm.checkImpliesAll(requiredPermissions, true);
+        if (implied != null) {
+          if (implied) {
+            return;
+          }
+          throw new UnauthorizedException("Permission denied: " + requiredPermissions);
+        }
+      }
+    }
+    // normal non-bulk check
+    for (Permission requiredPermission : requiredPermissions) {
+      checkImplies(subjectPermissions, requiredPermission);
+    }
+  }
+
+  // does one of the subject permissions imply the required permission, exception if not
+  private void checkImplies(Collection<? extends Permission> subjectPermissions, Permission requiredPermission) {
+    for (Permission subjectPermission : subjectPermissions) {
+      if (subjectPermission instanceof ExtendedPermission) {
+        if (((ExtendedPermission) subjectPermission).checkImplies(requiredPermission)) {
+          return;
+        }
+      } else {
+        if (subjectPermission.implies(requiredPermission)) {
+          return;
+        }
+      }
+    }
+    throw new UnauthorizedException("Permission denied: " + requiredPermission);
   }
 
   //-------------------------------------------------------------------------
@@ -131,17 +243,17 @@ public final class ShiroPermissionResolver implements PermissionResolver {
    * <p>
    * This is called directly from the cache.
    * 
-   * @param permissionStr  the permission string, not null
+   * @param permissionString  the permission string, not null
    * @return the new permission object, not null
    * @throws InvalidPermissionStringException if the permission string is invalid
    */
-  private Permission doResolvePermission(String permissionStr) {
-    for (Entry<String, PermissionResolver> entry : _prefixResolvers.entrySet()) {
-      if (permissionStr.startsWith(entry.getKey())) {
-        return entry.getValue().resolvePermission(permissionStr);
+  private Permission doResolvePermission(String permissionString) {
+    for (PrefixedPermissionResolver prefixedResolver : _prefixed.values()) {
+      if (permissionString.startsWith(prefixedResolver.getPrefix())) {
+        return prefixedResolver.resolvePermission(permissionString);
       }
     }
-    return ShiroPermission.of(permissionStr);
+    return ShiroWildcardPermission.of(permissionString);
   }
 
 }
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroWildcardPermission.java b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroWildcardPermission.java
new file mode 100644
index 0000000..461e113
--- /dev/null
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/auth/ShiroWildcardPermission.java
@@ -0,0 +1,167 @@
+/**
+ * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.auth;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang.text.StrBuilder;
+import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.permission.InvalidPermissionStringException;
+import org.apache.shiro.authz.permission.WildcardPermission;
+
+import com.google.common.collect.ImmutableSet;
+
+/**
+ * An Apache Shiro {@code Permission} that allows permission resolving to be extended.
+ * <p>
+ * This is a faster version of {@link WildcardPermission}.
+ * See {@link ShiroPermissionResolver} for public access.
+ */
+final class ShiroWildcardPermission implements Permission {
+
+  /**
+   * The wildcard segment.
+   */
+  private static final ImmutableSet<String> WILDCARD_SEGMENT = ImmutableSet.of("*");
+
+  /**
+   * The permission segments.
+   */
+  private final List<Set<String>> _segments = new ArrayList<>();
+  /**
+   * The hash code.
+   */
+  private final int _hashCode;
+  /**
+   * The string form.
+   */
+  private final String _toString;
+
+  /**
+   * Creates an instance.
+   * 
+   * @param permissionString  the permission string, not null
+   * @return the permission object, not null
+   * @throws InvalidPermissionStringException if the permission string is invalid
+   */
+  static Permission of(String permissionString) {
+    return new ShiroWildcardPermission(permissionString);
+  }
+
+  //-------------------------------------------------------------------------
+  /**
+   * Creates an instance.
+   * 
+   * @param permissionString  the permission string, not null
+   * @throws InvalidPermissionStringException if the permission string is invalid
+   */
+  private ShiroWildcardPermission(final String permissionString) {
+    String permStr = StringUtils.stripToNull(permissionString);
+    if (permStr == null) {
+      throw new InvalidPermissionStringException("Permission string must not be blank: " + permissionString, permissionString);
+    }
+    // case insensitive
+    permStr = permStr.toLowerCase(Locale.ROOT);
+    // split once
+    List<Set<String>> wildcardSegments = new ArrayList<>();
+    String[] segmentStrs = StringUtils.splitPreserveAllTokens(permStr, ':');
+    for (String segmentStr : segmentStrs) {
+      String[] partStrs = StringUtils.splitPreserveAllTokens(segmentStr, ',');
+      if (partStrs.length == 0) {
+        throw new InvalidPermissionStringException("Permission string must not contain an empty segment: " + permissionString, permissionString);
+      }
+      Set<String> parts = new LinkedHashSet<>();
+      for (String partStr : partStrs) {
+        partStr = partStr.trim();
+        if (partStr.isEmpty()) {
+          throw new InvalidPermissionStringException("Permission string must not contain an empty part: " + permissionString, permissionString);
+        }
+        if (partStr.contains("*") && partStr.equals("*") == false) {
+          throw new InvalidPermissionStringException("Permission string wildcard can only be applied to whole segment: " + permissionString, permissionString);
+        }
+        parts.add(partStr);
+      }
+      // simplify
+      if (parts.contains("*")) {
+        wildcardSegments.add(WILDCARD_SEGMENT);
+      } else {
+        _segments.addAll(wildcardSegments);
+        wildcardSegments.clear();
+        _segments.add(parts);
+      }
+    }
+    _hashCode = _segments.hashCode();
+    _toString = createToString(_segments);
+  }
+
+  private static String createToString(List<Set<String>> segments) {
+    StrBuilder buf = new StrBuilder();
+    for (Iterator<Set<String>> it1 = segments.iterator(); it1.hasNext();) {
+      for (Iterator<String> it2 = it1.next().iterator(); it2.hasNext();) {
+        buf.append(it2.next());
+        if (it2.hasNext()) {
+          buf.append(',');
+        }
+      }
+      if (it1.hasNext()) {
+        buf.append(':');
+      }
+    }
+    return buf.toString();
+  }
+
+  //-------------------------------------------------------------------------
+  // this permission is the permission I have
+  // the other permission is the permission being checked
+  @Override
+  public boolean implies(Permission requiredPermission) {
+    if (requiredPermission instanceof ShiroWildcardPermission == false) {
+      return false;
+    }
+    ShiroWildcardPermission requiredPerm = (ShiroWildcardPermission) requiredPermission;
+    List<Set<String>> thisSegments = _segments;
+    List<Set<String>> otherSegments = requiredPerm._segments;
+    if (thisSegments.size() > otherSegments.size()) {
+      return false;
+    }
+    int commonLen = Math.min(thisSegments.size(), otherSegments.size());
+    for (int i = 0; i < commonLen; i++) {
+      Set<String> thisSegment = thisSegments.get(i);
+      Set<String> otherSegment = otherSegments.get(i);
+      if (thisSegment != WILDCARD_SEGMENT && thisSegment.containsAll(otherSegment) == false) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  //-------------------------------------------------------------------------
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof ShiroWildcardPermission) {
+      ShiroWildcardPermission other = (ShiroWildcardPermission) obj;
+      return _segments.equals(other._segments);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return _hashCode;
+  }
+
+  @Override
+  public String toString() {
+    return _toString;
+  }
+
+}
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/fudgemsg/DirectBeanFudgeBuilder.java b/projects/OG-Util/src/main/java/com/opengamma/util/fudgemsg/DirectBeanFudgeBuilder.java
index bec3cb6..57e07c8 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/fudgemsg/DirectBeanFudgeBuilder.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/fudgemsg/DirectBeanFudgeBuilder.java
@@ -7,6 +7,7 @@ package com.opengamma.util.fudgemsg;
 
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -31,7 +32,13 @@ import org.joda.beans.JodaBeanUtils;
 import org.joda.beans.MetaBean;
 import org.joda.beans.MetaProperty;
 
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.SortedSetMultimap;
+import com.google.common.collect.TreeMultimap;
 
 /**
  * Builder to convert DirectBean to and from Fudge.
@@ -83,6 +90,9 @@ public final class DirectBeanFudgeBuilder<T extends Bean> implements FudgeBuilde
           } else if (obj instanceof Map<?, ?>) {
             MutableFudgeMsg subMsg = buildMessageMap(serializer, bean.getClass(), prop, (Map<?, ?>) obj);
             msg.add(prop.name(), null, FudgeWireType.SUB_MESSAGE, subMsg);
+          } else if (obj instanceof Multimap<?, ?>) {
+            MutableFudgeMsg subMsg = buildMessageMultimap(serializer, bean.getClass(), prop, (Multimap<?, ?>) obj);
+            msg.add(prop.name(), null, FudgeWireType.SUB_MESSAGE, subMsg);
           } else {
             serializer.addToMessageWithClassHeaders(msg, prop.name(), null, obj, prop.propertyType()); // ignores null
           }
@@ -109,11 +119,24 @@ public final class DirectBeanFudgeBuilder<T extends Bean> implements FudgeBuilde
     return msg;
   }
 
-  private MutableFudgeMsg buildMessageMap(FudgeSerializer serializer, Class<?> beanType, MetaProperty<?> prop, Map<?, ?> map) {
+  private MutableFudgeMsg buildMessageMap(FudgeSerializer serializer, Class<?> beanType, MetaProperty<?> prop,
+                                          Map<?, ?> map) {
+    return buildMessageMapFromEntries(map.entrySet(), serializer, beanType, prop);
+  }
+
+  private MutableFudgeMsg buildMessageMultimap(FudgeSerializer serializer, Class<?> beanType, MetaProperty<?> prop,
+                                               Multimap<?, ?> multimap) {
+    return buildMessageMapFromEntries(multimap.entries(), serializer, beanType, prop);
+  }
+
+  private MutableFudgeMsg buildMessageMapFromEntries(Collection<? extends Map.Entry<?, ?>> entries,
+                                                     FudgeSerializer serializer,
+                                                     Class<?> beanType,
+                                                     MetaProperty<?> prop) {
     Class<?> keyType = JodaBeanUtils.mapKeyType(prop, beanType);
     Class<?> valueType = JodaBeanUtils.mapValueType(prop, beanType);
     MutableFudgeMsg msg = serializer.newMessage();
-    for (Map.Entry<?, ?> entry : map.entrySet()) {
+    for (Map.Entry<?, ?> entry : entries) {
       if (entry.getKey() == null) {
         msg.add(null, 1, FudgeWireType.INDICATOR, IndicatorType.INSTANCE);
       } else if (keyType == null) {
@@ -151,18 +174,34 @@ public final class DirectBeanFudgeBuilder<T extends Bean> implements FudgeBuilde
             } else if (SortedSet.class.isAssignableFrom(mp.propertyType())) {
               value = field.getValue();
               if (value instanceof FudgeMsg) {
-                value = buildObjectSet(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, new TreeSet<Object>());
+                value = buildObjectSet(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, new TreeSet<>());
               }
             } else if (Set.class.isAssignableFrom(mp.propertyType())) {
               value = field.getValue();
               if (value instanceof FudgeMsg) {
-                value = buildObjectSet(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, new LinkedHashSet<Object>());
+                value = buildObjectSet(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, new LinkedHashSet<>());
               }
             } else if (Map.class.isAssignableFrom(mp.propertyType())) {
               value = field.getValue();
               if (value instanceof FudgeMsg) {
                 value = buildObjectMap(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value);
               }
+            } else if (ListMultimap.class.isAssignableFrom(mp.propertyType())) {
+              value = field.getValue();
+              if (value instanceof FudgeMsg) {
+                value = buildObjectMultimap(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, ArrayListMultimap.create());
+              }
+            } else if (SortedSetMultimap.class.isAssignableFrom(mp.propertyType())) {
+              value = field.getValue();
+              if (value instanceof FudgeMsg) {
+                value = buildObjectMultimap(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, TreeMultimap.create());
+              }
+            } else if (Multimap.class.isAssignableFrom(mp.propertyType())) {
+              // In the absence of other information we'll create a hash multimap
+              value = field.getValue();
+              if (value instanceof FudgeMsg) {
+                value = buildObjectMultimap(deserializer, mp, _metaBean.beanType(), (FudgeMsg) value, HashMultimap.create());
+              }
             }
             if (value == null) {
               try {
@@ -219,8 +258,8 @@ public final class DirectBeanFudgeBuilder<T extends Bean> implements FudgeBuilde
     Class<?> valueType = JodaBeanUtils.mapValueType(prop, type);
     boolean valueAbstractOrInterface = (valueType == null || valueType.isInterface() || Modifier.isAbstract(valueType.getModifiers()));
     Map<Object, Object> map = Maps.newHashMap();  // should be Map<keyType,contentType>
-    Queue<Object> keys = new LinkedList<Object>();
-    Queue<Object> values = new LinkedList<Object>();
+    Queue<Object> keys = new LinkedList<>();
+    Queue<Object> values = new LinkedList<>();
     for (FudgeField field : msg) {
       if (field.getOrdinal() == 1) {
         Object fieldValue = (keyAbstractOrInterface ? deserializer.fieldValueToObject(field) : deserializer.fieldValueToObject(keyType, field));
@@ -253,4 +292,49 @@ public final class DirectBeanFudgeBuilder<T extends Bean> implements FudgeBuilde
     return map;
   }
 
+  @SuppressWarnings("unchecked")
+  private Multimap<Object, Object> buildObjectMultimap(FudgeDeserializer deserializer,
+                                                       MetaProperty<?> prop,
+                                                       Class<?> type,
+                                                       FudgeMsg msg,
+                                                       Multimap multimap) {
+
+    Class<?> keyType = JodaBeanUtils.mapKeyType(prop, type);
+    boolean keyAbstractOrInterface = (keyType == null || keyType.isInterface() || Modifier.isAbstract(keyType.getModifiers()));
+    Class<?> valueType = JodaBeanUtils.mapValueType(prop, type);
+    boolean valueAbstractOrInterface = (valueType == null || valueType.isInterface() || Modifier.isAbstract(valueType.getModifiers()));
+    Queue<Object> keys = new LinkedList<>();
+    Queue<Object> values = new LinkedList<>();
+    for (FudgeField field : msg) {
+      if (field.getOrdinal() == 1) {
+        Object fieldValue = (keyAbstractOrInterface ? deserializer.fieldValueToObject(field) : deserializer.fieldValueToObject(keyType, field));
+        if (fieldValue instanceof IndicatorType) {
+          fieldValue = null;
+        }
+        if (values.isEmpty()) {
+          // no values ready, so store the key till next time
+          keys.add(fieldValue);
+        } else {
+          // store key along with next value
+          multimap.put(fieldValue, values.remove());
+        }
+      } else if (field.getOrdinal() == 2) {
+        Object fieldValue = (valueAbstractOrInterface ? deserializer.fieldValueToObject(field) : deserializer.fieldValueToObject(valueType, field));
+        if (fieldValue instanceof IndicatorType) {
+          fieldValue = null;
+        }
+        if (keys.isEmpty()) {
+          // no keys ready, so store the value till next time
+          values.add(fieldValue);
+        } else {
+          // store value along with next key
+          multimap.put(keys.remove(), fieldValue);
+        }
+      } else {
+        throw new IllegalArgumentException("Sub-message doesn't contain a map (bad field " + field + ")");
+      }
+    }
+    return multimap;
+  }
+
 }
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/result/Failure.java b/projects/OG-Util/src/main/java/com/opengamma/util/result/Failure.java
index dbc0be7..f49d9a4 100644
--- a/projects/OG-Util/src/main/java/com/opengamma/util/result/Failure.java
+++ b/projects/OG-Util/src/main/java/com/opengamma/util/result/Failure.java
@@ -48,24 +48,18 @@ public final class Failure implements ImmutableBean {
   private final ThrowableDetails _causeDetails;
 
   @ImmutableConstructor
-  Failure(FailureStatus status, String message, ThrowableDetails causeDetails) {
+  private Failure(FailureStatus status, String message, ThrowableDetails causeDetails) {
     _status = ArgumentChecker.notNull(status, "status");
     _message = ArgumentChecker.notEmpty(message, "message");
     _causeDetails = causeDetails;
   }
 
   Failure(FailureStatus status, String message, Exception cause) {
-    _status = ArgumentChecker.notNull(status, "status");
-    _message = ArgumentChecker.notEmpty(message, "message");
-    if (cause != null) {
-      _causeDetails = ThrowableDetails.of(cause);
-    } else {
-      _causeDetails = null;
-    }
+    this(status, message, ThrowableDetails.of(ArgumentChecker.notNull(cause, "cause")));
   }
 
   Failure(FailureStatus failureStatus, Exception cause) {
-    this(failureStatus, getMessage(ArgumentChecker.notNull(cause, "cause")), (ThrowableDetails) null);
+    this(failureStatus, getMessage(cause), cause);
   }
 
   Failure(FailureStatus failureStatus, String message) {
@@ -73,7 +67,7 @@ public final class Failure implements ImmutableBean {
   }
 
   Failure(Exception cause, String message) {
-    this(FailureStatus.ERROR, message, ArgumentChecker.notNull(cause, "cause"));
+    this(FailureStatus.ERROR, message, cause);
   }
 
   Failure(Exception cause) {
@@ -81,13 +75,13 @@ public final class Failure implements ImmutableBean {
   }
 
   /**
-   * Extracts the mesage from an exception.
+   * Extracts the message from an exception.
    * 
-   * @param cause  an exception that caused a failure, not null
+   * @param cause  an exception that caused a failure
    * @return the exception's message or it's simple class name if it doesn't have one
    */
   private static String getMessage(Exception cause) {
-    String message = cause.getMessage();
+    String message = ArgumentChecker.notNull(cause, "cause").getMessage();
     return !StringUtils.isEmpty(message) ? message : cause.getClass().getSimpleName();
   }
 
diff --git a/projects/OG-Util/src/main/java/com/opengamma/util/test/TestUtils.java b/projects/OG-Util/src/main/java/com/opengamma/util/test/TestUtils.java
deleted file mode 100644
index 3238988..0000000
--- a/projects/OG-Util/src/main/java/com/opengamma/util/test/TestUtils.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.util.test;
-
-import org.apache.shiro.UnavailableSecurityManagerException;
-import org.apache.shiro.mgt.DefaultSecurityManager;
-
-import com.opengamma.util.auth.AuthUtils;
-
-/**
- * Utility methods for working with tests.
- */
-public final class TestUtils {
-
-  /**
-   * Restricted constructor.
-   */
-  private TestUtils() {
-  }
-
-  //-------------------------------------------------------------------------
-  /**
-   * Sets up the security manager for testing.
-   */
-  public static void initSecurity() {
-    try {
-      AuthUtils.getSecurityManager();
-    } catch (UnavailableSecurityManagerException ex) {
-      AuthUtils.setSecurityManager(new DefaultSecurityManager());
-    }
-  }
-
-}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroPermissionTest.java b/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroPermissionTest.java
deleted file mode 100644
index 146f28a..0000000
--- a/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroPermissionTest.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/**
- * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
- *
- * Please see distribution for license.
- */
-package com.opengamma.util.auth;
-
-import static org.testng.AssertJUnit.assertEquals;
-
-import org.apache.shiro.authz.Permission;
-import org.apache.shiro.authz.permission.InvalidPermissionStringException;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-/**
- * Test.
- */
-public class ShiroPermissionTest {
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_null() {
-    ShiroPermission.of(null);
-  }
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_empty() {
-    ShiroPermission.of("");
-  }
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_blank() {
-    ShiroPermission.of("   ");
-  }
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_onlyColons() {
-    ShiroPermission.of("::");
-  }
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_onlyCommas() {
-    ShiroPermission.of("a:,:b");
-  }
-
-  @Test(expectedExceptions = InvalidPermissionStringException.class)
-  public void test_of_invalidWildcard() {
-    ShiroPermission.of("a:beta*");
-  }
-
-  @Test
-  public void test_of_caseInsensitive() {
-    Permission p1 = ShiroPermission.of("something");
-    Permission p2 = ShiroPermission.of("SOMETHING");
-    assertEquals(p1, p2);
-  }
-
-  //-------------------------------------------------------------------------
-  @DataProvider(name = "simplifications")
-  Object[][] data_simplifications() {
-    return new Object[][] {
-        {"a", "a"},
-        {"a:*", "a"},
-        {"a:*:*", "a"},
-        {"a:*:*:*", "a"},
-        
-        {"a,b", "a,b"},
-        {"a,b:*", "a,b"},
-        {"a,b:*:*", "a,b"},
-        
-        {"a,b:c,d", "a,b:c,d"},
-        {"a,b:c,d:*", "a,b:c,d"},
-        {"a,b:c,d:*:*", "a,b:c,d"},
-        
-        {"a,b:*:c,d", "a,b:*:c,d"},
-        {"a,b:*:c,d:*", "a,b:*:c,d"},
-        {"a,b:*:c,d:*:*", "a,b:*:c,d"},
-        
-        {"a,b:*:*:*:c,d", "a,b:*:*:*:c,d"},
-        {"a,b:*:*:*:c,d:*", "a,b:*:*:*:c,d"},
-        {"a,b:*:*:*:c,d:*:*", "a,b:*:*:*:c,d"},
-        
-        {"a,b:x,*:c,d", "a,b:*:c,d"},
-        {"a,b:x,*:c,d:*", "a,b:*:c,d"},
-        {"a,b:x,*:c,d:*:*", "a,b:*:c,d"},
-    };
-  }
-
-  @Test(dataProvider = "simplifications")
-  public void test_simplifications(String perm, String simplification) {
-    Permission sp = ShiroPermission.of(perm);
-    assertEquals(simplification, sp.toString());
-  }
-
-  //-------------------------------------------------------------------------
-  @DataProvider(name = "permissions")
-  Object[][] data_permissions() {
-    return new Object[][] {
-        {"a", "a", true, true},
-        {"a", "b", false, false},
-        
-        {"a,b", "a,b", true, true},
-        {"a,b", "a", true, false},
-        
-        {"a,b,c", "a", true, false},
-        {"a,b,c", "a,b", true, false},
-        {"a,b,c", "a,c", true, false},
-        {"a,b,c", "b,c", true, false},
-        
-        {"c,a,b", "a", true, false},
-        {"c,a,b", "a,b", true, false},
-        {"c,a,b", "a,c", true, false},
-        {"c,a,b", "b,c", true, false},
-        
-        {"c,a,b", "a", true, false},
-        {"c,a,b", "a,b", true, false},
-        {"c,a,b", "a,c", true, false},
-        {"c,a,b", "b,c", true, false},
-        
-        {"a,b,c:d,e", "a:e", true, false},
-        {"a,b,c:d,e", "b:e", true, false},
-        {"a,b,c:d,e", "c:e", true, false},
-        {"a,b,c:d,e", "a:d", true, false},
-        {"a,b,c:d,e", "b:d", true, false},
-        {"a,b,c:d,e", "c:d", true, false},
-        {"a,b,c:d,e", "a:d,e", true, false},
-        {"a,b,c:d,e", "b,c:d,e", true, false},
-        {"a,b,c:d,e", "a,c:d,e", true, false},
-        
-        {"a,b:d,e:g,h", "a:e:h", true, false},
-        
-        {"a", "a:e", true, false},
-        {"a", "a:e:h", true, false},
-        {"a", "a:d,e:g,h", true, false},
-        
-        {"*", "*", true, true},
-        {"*", "a", true, false},
-        {"*", "a:d", true, false},
-        {"*", "a:d:g", true, false},
-        
-        {"a:*", "*", false, true},
-        {"a:*", "a", true, true},
-        {"a:*", "a:d", true, false},
-        {"a:*", "a:d,e", true, false},
-        {"a:*", "a:d:g", true, false},
-        
-        {"a:*:*", "*", false, true},
-        {"a:*:*", "a", true, true},
-        {"a:*:*", "a:d", true, false},
-        {"a:*:*", "a:d,e", true, false},
-        {"a:*:*", "a:d:g", true, false},
-        
-        {"a:*:g,h", "*", false, true},
-        {"a:*:g,h", "a", false, true},
-        {"a:*:g,h", "a:d", false, false},
-        {"a:*:g,h", "a:d,e", false, false},
-        {"a:*:g,h", "a:d:g", true, false},
-        {"a:*:g,h", "a:d:g,i", false, false},
-        {"a:*:g,h", "a:d:g:x", true, false},
-        
-        {"a:b,*", "a:b", true, false},
-        {"a:b,*", "a:c", true, false},
-        {"a:b,*", "a:d", true, false},
-    };
-  }
-
-  @Test(dataProvider = "permissions")
-  public void test_permissions(String perm1, String perm2, boolean impliesForward, boolean impliesBackward) {
-    Permission sp1 = ShiroPermission.of(perm1);
-    Permission sp2 = ShiroPermission.of(perm2);
-    assertEquals("Foward", impliesForward, sp1.implies(sp2));
-    assertEquals("Backward", impliesBackward, sp2.implies(sp1));
-  }
-
-}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroWildcardPermissionTest.java b/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroWildcardPermissionTest.java
new file mode 100644
index 0000000..51a1a56
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/auth/ShiroWildcardPermissionTest.java
@@ -0,0 +1,174 @@
+/**
+ * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.auth;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.apache.shiro.authz.Permission;
+import org.apache.shiro.authz.permission.InvalidPermissionStringException;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+/**
+ * Test.
+ */
+public class ShiroWildcardPermissionTest {
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_null() {
+    ShiroWildcardPermission.of(null);
+  }
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_empty() {
+    ShiroWildcardPermission.of("");
+  }
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_blank() {
+    ShiroWildcardPermission.of("   ");
+  }
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_onlyColons() {
+    ShiroWildcardPermission.of("::");
+  }
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_onlyCommas() {
+    ShiroWildcardPermission.of("a:,:b");
+  }
+
+  @Test(expectedExceptions = InvalidPermissionStringException.class)
+  public void test_of_invalidWildcard() {
+    ShiroWildcardPermission.of("a:beta*");
+  }
+
+  @Test
+  public void test_of_caseInsensitive() {
+    Permission p1 = ShiroWildcardPermission.of("something");
+    Permission p2 = ShiroWildcardPermission.of("SOMETHING");
+    assertEquals(p1, p2);
+  }
+
+  //-------------------------------------------------------------------------
+  @DataProvider(name = "simplifications")
+  Object[][] data_simplifications() {
+    return new Object[][] {
+        {"a", "a"},
+        {"a:*", "a"},
+        {"a:*:*", "a"},
+        {"a:*:*:*", "a"},
+        
+        {"a,b", "a,b"},
+        {"a,b:*", "a,b"},
+        {"a,b:*:*", "a,b"},
+        
+        {"a,b:c,d", "a,b:c,d"},
+        {"a,b:c,d:*", "a,b:c,d"},
+        {"a,b:c,d:*:*", "a,b:c,d"},
+        
+        {"a,b:*:c,d", "a,b:*:c,d"},
+        {"a,b:*:c,d:*", "a,b:*:c,d"},
+        {"a,b:*:c,d:*:*", "a,b:*:c,d"},
+        
+        {"a,b:*:*:*:c,d", "a,b:*:*:*:c,d"},
+        {"a,b:*:*:*:c,d:*", "a,b:*:*:*:c,d"},
+        {"a,b:*:*:*:c,d:*:*", "a,b:*:*:*:c,d"},
+        
+        {"a,b:x,*:c,d", "a,b:*:c,d"},
+        {"a,b:x,*:c,d:*", "a,b:*:c,d"},
+        {"a,b:x,*:c,d:*:*", "a,b:*:c,d"},
+    };
+  }
+
+  @Test(dataProvider = "simplifications")
+  public void test_simplifications(String perm, String simplification) {
+    Permission sp = ShiroWildcardPermission.of(perm);
+    assertEquals(simplification, sp.toString());
+  }
+
+  //-------------------------------------------------------------------------
+  @DataProvider(name = "permissions")
+  Object[][] data_permissions() {
+    return new Object[][] {
+        {"a", "a", true, true},
+        {"a", "b", false, false},
+        
+        {"a,b", "a,b", true, true},
+        {"a,b", "a", true, false},
+        
+        {"a,b,c", "a", true, false},
+        {"a,b,c", "a,b", true, false},
+        {"a,b,c", "a,c", true, false},
+        {"a,b,c", "b,c", true, false},
+        
+        {"c,a,b", "a", true, false},
+        {"c,a,b", "a,b", true, false},
+        {"c,a,b", "a,c", true, false},
+        {"c,a,b", "b,c", true, false},
+        
+        {"c,a,b", "a", true, false},
+        {"c,a,b", "a,b", true, false},
+        {"c,a,b", "a,c", true, false},
+        {"c,a,b", "b,c", true, false},
+        
+        {"a,b,c:d,e", "a:e", true, false},
+        {"a,b,c:d,e", "b:e", true, false},
+        {"a,b,c:d,e", "c:e", true, false},
+        {"a,b,c:d,e", "a:d", true, false},
+        {"a,b,c:d,e", "b:d", true, false},
+        {"a,b,c:d,e", "c:d", true, false},
+        {"a,b,c:d,e", "a:d,e", true, false},
+        {"a,b,c:d,e", "b,c:d,e", true, false},
+        {"a,b,c:d,e", "a,c:d,e", true, false},
+        
+        {"a,b:d,e:g,h", "a:e:h", true, false},
+        
+        {"a", "a:e", true, false},
+        {"a", "a:e:h", true, false},
+        {"a", "a:d,e:g,h", true, false},
+        
+        {"*", "*", true, true},
+        {"*", "a", true, false},
+        {"*", "a:d", true, false},
+        {"*", "a:d:g", true, false},
+        
+        {"a:*", "*", false, true},
+        {"a:*", "a", true, true},
+        {"a:*", "a:d", true, false},
+        {"a:*", "a:d,e", true, false},
+        {"a:*", "a:d:g", true, false},
+        
+        {"a:*:*", "*", false, true},
+        {"a:*:*", "a", true, true},
+        {"a:*:*", "a:d", true, false},
+        {"a:*:*", "a:d,e", true, false},
+        {"a:*:*", "a:d:g", true, false},
+        
+        {"a:*:g,h", "*", false, true},
+        {"a:*:g,h", "a", false, true},
+        {"a:*:g,h", "a:d", false, false},
+        {"a:*:g,h", "a:d,e", false, false},
+        {"a:*:g,h", "a:d:g", true, false},
+        {"a:*:g,h", "a:d:g,i", false, false},
+        {"a:*:g,h", "a:d:g:x", true, false},
+        
+        {"a:b,*", "a:b", true, false},
+        {"a:b,*", "a:c", true, false},
+        {"a:b,*", "a:d", true, false},
+    };
+  }
+
+  @Test(dataProvider = "permissions")
+  public void test_permissions(String perm1, String perm2, boolean impliesForward, boolean impliesBackward) {
+    Permission sp1 = ShiroWildcardPermission.of(perm1);
+    Permission sp2 = ShiroWildcardPermission.of(perm2);
+    assertEquals("Forward", impliesForward, sp1.implies(sp2));
+    assertEquals("Backward", impliesBackward, sp2.implies(sp1));
+  }
+
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/CombinedMultimapMockBean.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/CombinedMultimapMockBean.java
new file mode 100644
index 0000000..b9dee73
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/CombinedMultimapMockBean.java
@@ -0,0 +1,502 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.joda.beans.Bean;
+import org.joda.beans.BeanDefinition;
+import org.joda.beans.ImmutableBean;
+import org.joda.beans.JodaBeanUtils;
+import org.joda.beans.MetaProperty;
+import org.joda.beans.Property;
+import org.joda.beans.PropertyDefinition;
+import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
+import org.joda.beans.impl.direct.DirectMetaBean;
+import org.joda.beans.impl.direct.DirectMetaProperty;
+import org.joda.beans.impl.direct.DirectMetaPropertyMap;
+
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.SortedSetMultimap;
+
+@BeanDefinition
+public class CombinedMultimapMockBean implements ImmutableBean {
+
+  @PropertyDefinition(validate = "notNull")
+  private final SetMultimap<String, String> _setMultimap;
+
+  @PropertyDefinition(validate = "notNull")
+  private final ListMultimap<String, String> _listMultimap;
+
+  @PropertyDefinition(validate = "notNull")
+  private final SortedSetMultimap<String, String> _sortedMultimap;
+
+  @PropertyDefinition(validate = "notNull")
+  private final Multimap<String, String> _noTypeMultimap;
+
+  //------------------------- AUTOGENERATED START -------------------------
+  ///CLOVER:OFF
+  /**
+   * The meta-bean for {@code CombinedMultimapMockBean}.
+   * @return the meta-bean, not null
+   */
+  public static CombinedMultimapMockBean.Meta meta() {
+    return CombinedMultimapMockBean.Meta.INSTANCE;
+  }
+
+  static {
+    JodaBeanUtils.registerMetaBean(CombinedMultimapMockBean.Meta.INSTANCE);
+  }
+
+  /**
+   * Returns a builder used to create an instance of the bean.
+   * @return the builder, not null
+   */
+  public static CombinedMultimapMockBean.Builder builder() {
+    return new CombinedMultimapMockBean.Builder();
+  }
+
+  /**
+   * Restricted constructor.
+   * @param builder  the builder to copy from, not null
+   */
+  protected CombinedMultimapMockBean(CombinedMultimapMockBean.Builder builder) {
+    JodaBeanUtils.notNull(builder._setMultimap, "setMultimap");
+    JodaBeanUtils.notNull(builder._listMultimap, "listMultimap");
+    JodaBeanUtils.notNull(builder._sortedMultimap, "sortedMultimap");
+    JodaBeanUtils.notNull(builder._noTypeMultimap, "noTypeMultimap");
+    this._setMultimap = ImmutableSetMultimap.copyOf(builder._setMultimap);
+    this._listMultimap = ImmutableListMultimap.copyOf(builder._listMultimap);
+    this._sortedMultimap = builder._sortedMultimap;
+    this._noTypeMultimap = ImmutableMultimap.copyOf(builder._noTypeMultimap);
+  }
+
+  @Override
+  public CombinedMultimapMockBean.Meta metaBean() {
+    return CombinedMultimapMockBean.Meta.INSTANCE;
+  }
+
+  @Override
+  public <R> Property<R> property(String propertyName) {
+    return metaBean().<R>metaProperty(propertyName).createProperty(this);
+  }
+
+  @Override
+  public Set<String> propertyNames() {
+    return metaBean().metaPropertyMap().keySet();
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the setMultimap.
+   * @return the value of the property, not null
+   */
+  public SetMultimap<String, String> getSetMultimap() {
+    return _setMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the listMultimap.
+   * @return the value of the property, not null
+   */
+  public ListMultimap<String, String> getListMultimap() {
+    return _listMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the sortedMultimap.
+   * @return the value of the property, not null
+   */
+  public SortedSetMultimap<String, String> getSortedMultimap() {
+    return _sortedMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the noTypeMultimap.
+   * @return the value of the property, not null
+   */
+  public Multimap<String, String> getNoTypeMultimap() {
+    return _noTypeMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Returns a builder that allows this bean to be mutated.
+   * @return the mutable builder, not null
+   */
+  public Builder toBuilder() {
+    return new Builder(this);
+  }
+
+  @Override
+  public CombinedMultimapMockBean clone() {
+    return this;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    }
+    if (obj != null && obj.getClass() == this.getClass()) {
+      CombinedMultimapMockBean other = (CombinedMultimapMockBean) obj;
+      return JodaBeanUtils.equal(getSetMultimap(), other.getSetMultimap()) &&
+          JodaBeanUtils.equal(getListMultimap(), other.getListMultimap()) &&
+          JodaBeanUtils.equal(getSortedMultimap(), other.getSortedMultimap()) &&
+          JodaBeanUtils.equal(getNoTypeMultimap(), other.getNoTypeMultimap());
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = getClass().hashCode();
+    hash += hash * 31 + JodaBeanUtils.hashCode(getSetMultimap());
+    hash += hash * 31 + JodaBeanUtils.hashCode(getListMultimap());
+    hash += hash * 31 + JodaBeanUtils.hashCode(getSortedMultimap());
+    hash += hash * 31 + JodaBeanUtils.hashCode(getNoTypeMultimap());
+    return hash;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder(160);
+    buf.append("CombinedMultimapMockBean{");
+    int len = buf.length();
+    toString(buf);
+    if (buf.length() > len) {
+      buf.setLength(buf.length() - 2);
+    }
+    buf.append('}');
+    return buf.toString();
+  }
+
+  protected void toString(StringBuilder buf) {
+    buf.append("setMultimap").append('=').append(JodaBeanUtils.toString(getSetMultimap())).append(',').append(' ');
+    buf.append("listMultimap").append('=').append(JodaBeanUtils.toString(getListMultimap())).append(',').append(' ');
+    buf.append("sortedMultimap").append('=').append(JodaBeanUtils.toString(getSortedMultimap())).append(',').append(' ');
+    buf.append("noTypeMultimap").append('=').append(JodaBeanUtils.toString(getNoTypeMultimap())).append(',').append(' ');
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The meta-bean for {@code CombinedMultimapMockBean}.
+   */
+  public static class Meta extends DirectMetaBean {
+    /**
+     * The singleton instance of the meta-bean.
+     */
+    static final Meta INSTANCE = new Meta();
+
+    /**
+     * The meta-property for the {@code setMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<SetMultimap<String, String>> _setMultimap = DirectMetaProperty.ofImmutable(
+        this, "setMultimap", CombinedMultimapMockBean.class, (Class) SetMultimap.class);
+    /**
+     * The meta-property for the {@code listMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<ListMultimap<String, String>> _listMultimap = DirectMetaProperty.ofImmutable(
+        this, "listMultimap", CombinedMultimapMockBean.class, (Class) ListMultimap.class);
+    /**
+     * The meta-property for the {@code sortedMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<SortedSetMultimap<String, String>> _sortedMultimap = DirectMetaProperty.ofImmutable(
+        this, "sortedMultimap", CombinedMultimapMockBean.class, (Class) SortedSetMultimap.class);
+    /**
+     * The meta-property for the {@code noTypeMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<Multimap<String, String>> _noTypeMultimap = DirectMetaProperty.ofImmutable(
+        this, "noTypeMultimap", CombinedMultimapMockBean.class, (Class) Multimap.class);
+    /**
+     * The meta-properties.
+     */
+    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
+        this, null,
+        "setMultimap",
+        "listMultimap",
+        "sortedMultimap",
+        "noTypeMultimap");
+
+    /**
+     * Restricted constructor.
+     */
+    protected Meta() {
+    }
+
+    @Override
+    protected MetaProperty<?> metaPropertyGet(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case -1651820539:  // setMultimap
+          return _setMultimap;
+        case 1737633857:  // listMultimap
+          return _listMultimap;
+        case 1018561376:  // sortedMultimap
+          return _sortedMultimap;
+        case -395084994:  // noTypeMultimap
+          return _noTypeMultimap;
+      }
+      return super.metaPropertyGet(propertyName);
+    }
+
+    @Override
+    public CombinedMultimapMockBean.Builder builder() {
+      return new CombinedMultimapMockBean.Builder();
+    }
+
+    @Override
+    public Class<? extends CombinedMultimapMockBean> beanType() {
+      return CombinedMultimapMockBean.class;
+    }
+
+    @Override
+    public Map<String, MetaProperty<?>> metaPropertyMap() {
+      return _metaPropertyMap$;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The meta-property for the {@code setMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<SetMultimap<String, String>> setMultimap() {
+      return _setMultimap;
+    }
+
+    /**
+     * The meta-property for the {@code listMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<ListMultimap<String, String>> listMultimap() {
+      return _listMultimap;
+    }
+
+    /**
+     * The meta-property for the {@code sortedMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<SortedSetMultimap<String, String>> sortedMultimap() {
+      return _sortedMultimap;
+    }
+
+    /**
+     * The meta-property for the {@code noTypeMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<Multimap<String, String>> noTypeMultimap() {
+      return _noTypeMultimap;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
+      switch (propertyName.hashCode()) {
+        case -1651820539:  // setMultimap
+          return ((CombinedMultimapMockBean) bean).getSetMultimap();
+        case 1737633857:  // listMultimap
+          return ((CombinedMultimapMockBean) bean).getListMultimap();
+        case 1018561376:  // sortedMultimap
+          return ((CombinedMultimapMockBean) bean).getSortedMultimap();
+        case -395084994:  // noTypeMultimap
+          return ((CombinedMultimapMockBean) bean).getNoTypeMultimap();
+      }
+      return super.propertyGet(bean, propertyName, quiet);
+    }
+
+    @Override
+    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
+      metaProperty(propertyName);
+      if (quiet) {
+        return;
+      }
+      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
+    }
+
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The bean-builder for {@code CombinedMultimapMockBean}.
+   */
+  public static class Builder extends DirectFieldsBeanBuilder<CombinedMultimapMockBean> {
+
+    private SetMultimap<String, String> _setMultimap = HashMultimap.create();
+    private ListMultimap<String, String> _listMultimap = ArrayListMultimap.create();
+    private SortedSetMultimap<String, String> _sortedMultimap;
+    private Multimap<String, String> _noTypeMultimap = HashMultimap.create();
+
+    /**
+     * Restricted constructor.
+     */
+    protected Builder() {
+    }
+
+    /**
+     * Restricted copy constructor.
+     * @param beanToCopy  the bean to copy from, not null
+     */
+    protected Builder(CombinedMultimapMockBean beanToCopy) {
+      this._setMultimap = HashMultimap.create(beanToCopy.getSetMultimap());
+      this._listMultimap = ArrayListMultimap.create(beanToCopy.getListMultimap());
+      this._sortedMultimap = beanToCopy.getSortedMultimap();
+      this._noTypeMultimap = HashMultimap.create(beanToCopy.getNoTypeMultimap());
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public Object get(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case -1651820539:  // setMultimap
+          return _setMultimap;
+        case 1737633857:  // listMultimap
+          return _listMultimap;
+        case 1018561376:  // sortedMultimap
+          return _sortedMultimap;
+        case -395084994:  // noTypeMultimap
+          return _noTypeMultimap;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Builder set(String propertyName, Object newValue) {
+      switch (propertyName.hashCode()) {
+        case -1651820539:  // setMultimap
+          this._setMultimap = (SetMultimap<String, String>) newValue;
+          break;
+        case 1737633857:  // listMultimap
+          this._listMultimap = (ListMultimap<String, String>) newValue;
+          break;
+        case 1018561376:  // sortedMultimap
+          this._sortedMultimap = (SortedSetMultimap<String, String>) newValue;
+          break;
+        case -395084994:  // noTypeMultimap
+          this._noTypeMultimap = (Multimap<String, String>) newValue;
+          break;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+      return this;
+    }
+
+    @Override
+    public Builder set(MetaProperty<?> property, Object value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(String propertyName, String value) {
+      setString(meta().metaProperty(propertyName), value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(MetaProperty<?> property, String value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
+      super.setAll(propertyValueMap);
+      return this;
+    }
+
+    @Override
+    public CombinedMultimapMockBean build() {
+      return new CombinedMultimapMockBean(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the {@code setMultimap} property in the builder.
+     * @param setMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder setMultimap(SetMultimap<String, String> setMultimap) {
+      JodaBeanUtils.notNull(setMultimap, "setMultimap");
+      this._setMultimap = setMultimap;
+      return this;
+    }
+
+    /**
+     * Sets the {@code listMultimap} property in the builder.
+     * @param listMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder listMultimap(ListMultimap<String, String> listMultimap) {
+      JodaBeanUtils.notNull(listMultimap, "listMultimap");
+      this._listMultimap = listMultimap;
+      return this;
+    }
+
+    /**
+     * Sets the {@code sortedMultimap} property in the builder.
+     * @param sortedMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder sortedMultimap(SortedSetMultimap<String, String> sortedMultimap) {
+      JodaBeanUtils.notNull(sortedMultimap, "sortedMultimap");
+      this._sortedMultimap = sortedMultimap;
+      return this;
+    }
+
+    /**
+     * Sets the {@code noTypeMultimap} property in the builder.
+     * @param noTypeMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder noTypeMultimap(Multimap<String, String> noTypeMultimap) {
+      JodaBeanUtils.notNull(noTypeMultimap, "noTypeMultimap");
+      this._noTypeMultimap = noTypeMultimap;
+      return this;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(160);
+      buf.append("CombinedMultimapMockBean.Builder{");
+      int len = buf.length();
+      toString(buf);
+      if (buf.length() > len) {
+        buf.setLength(buf.length() - 2);
+      }
+      buf.append('}');
+      return buf.toString();
+    }
+
+    protected void toString(StringBuilder buf) {
+      buf.append("setMultimap").append('=').append(JodaBeanUtils.toString(_setMultimap)).append(',').append(' ');
+      buf.append("listMultimap").append('=').append(JodaBeanUtils.toString(_listMultimap)).append(',').append(' ');
+      buf.append("sortedMultimap").append('=').append(JodaBeanUtils.toString(_sortedMultimap)).append(',').append(' ');
+      buf.append("noTypeMultimap").append('=').append(JodaBeanUtils.toString(_noTypeMultimap)).append(',').append(' ');
+    }
+
+  }
+
+  ///CLOVER:ON
+  //-------------------------- AUTOGENERATED END --------------------------
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/HashMultimapMockBean.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/HashMultimapMockBean.java
new file mode 100644
index 0000000..f14ffa7
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/HashMultimapMockBean.java
@@ -0,0 +1,329 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.joda.beans.Bean;
+import org.joda.beans.BeanDefinition;
+import org.joda.beans.ImmutableBean;
+import org.joda.beans.JodaBeanUtils;
+import org.joda.beans.MetaProperty;
+import org.joda.beans.Property;
+import org.joda.beans.PropertyDefinition;
+import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
+import org.joda.beans.impl.direct.DirectMetaBean;
+import org.joda.beans.impl.direct.DirectMetaProperty;
+import org.joda.beans.impl.direct.DirectMetaPropertyMap;
+
+import com.google.common.collect.HashMultimap;
+
+@BeanDefinition
+public class HashMultimapMockBean implements ImmutableBean {
+
+  @PropertyDefinition(validate = "notNull")
+  private final HashMultimap<String, String> _hashMultimap;
+
+  //------------------------- AUTOGENERATED START -------------------------
+  ///CLOVER:OFF
+  /**
+   * The meta-bean for {@code HashMultimapMockBean}.
+   * @return the meta-bean, not null
+   */
+  public static HashMultimapMockBean.Meta meta() {
+    return HashMultimapMockBean.Meta.INSTANCE;
+  }
+
+  static {
+    JodaBeanUtils.registerMetaBean(HashMultimapMockBean.Meta.INSTANCE);
+  }
+
+  /**
+   * Returns a builder used to create an instance of the bean.
+   * @return the builder, not null
+   */
+  public static HashMultimapMockBean.Builder builder() {
+    return new HashMultimapMockBean.Builder();
+  }
+
+  /**
+   * Restricted constructor.
+   * @param builder  the builder to copy from, not null
+   */
+  protected HashMultimapMockBean(HashMultimapMockBean.Builder builder) {
+    JodaBeanUtils.notNull(builder._hashMultimap, "hashMultimap");
+    this._hashMultimap = builder._hashMultimap;
+  }
+
+  @Override
+  public HashMultimapMockBean.Meta metaBean() {
+    return HashMultimapMockBean.Meta.INSTANCE;
+  }
+
+  @Override
+  public <R> Property<R> property(String propertyName) {
+    return metaBean().<R>metaProperty(propertyName).createProperty(this);
+  }
+
+  @Override
+  public Set<String> propertyNames() {
+    return metaBean().metaPropertyMap().keySet();
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the hashMultimap.
+   * @return the value of the property, not null
+   */
+  public HashMultimap<String, String> getHashMultimap() {
+    return _hashMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Returns a builder that allows this bean to be mutated.
+   * @return the mutable builder, not null
+   */
+  public Builder toBuilder() {
+    return new Builder(this);
+  }
+
+  @Override
+  public HashMultimapMockBean clone() {
+    return this;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    }
+    if (obj != null && obj.getClass() == this.getClass()) {
+      HashMultimapMockBean other = (HashMultimapMockBean) obj;
+      return JodaBeanUtils.equal(getHashMultimap(), other.getHashMultimap());
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = getClass().hashCode();
+    hash += hash * 31 + JodaBeanUtils.hashCode(getHashMultimap());
+    return hash;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder(64);
+    buf.append("HashMultimapMockBean{");
+    int len = buf.length();
+    toString(buf);
+    if (buf.length() > len) {
+      buf.setLength(buf.length() - 2);
+    }
+    buf.append('}');
+    return buf.toString();
+  }
+
+  protected void toString(StringBuilder buf) {
+    buf.append("hashMultimap").append('=').append(JodaBeanUtils.toString(getHashMultimap())).append(',').append(' ');
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The meta-bean for {@code HashMultimapMockBean}.
+   */
+  public static class Meta extends DirectMetaBean {
+    /**
+     * The singleton instance of the meta-bean.
+     */
+    static final Meta INSTANCE = new Meta();
+
+    /**
+     * The meta-property for the {@code hashMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<HashMultimap<String, String>> _hashMultimap = DirectMetaProperty.ofImmutable(
+        this, "hashMultimap", HashMultimapMockBean.class, (Class) HashMultimap.class);
+    /**
+     * The meta-properties.
+     */
+    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
+        this, null,
+        "hashMultimap");
+
+    /**
+     * Restricted constructor.
+     */
+    protected Meta() {
+    }
+
+    @Override
+    protected MetaProperty<?> metaPropertyGet(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case -1368338255:  // hashMultimap
+          return _hashMultimap;
+      }
+      return super.metaPropertyGet(propertyName);
+    }
+
+    @Override
+    public HashMultimapMockBean.Builder builder() {
+      return new HashMultimapMockBean.Builder();
+    }
+
+    @Override
+    public Class<? extends HashMultimapMockBean> beanType() {
+      return HashMultimapMockBean.class;
+    }
+
+    @Override
+    public Map<String, MetaProperty<?>> metaPropertyMap() {
+      return _metaPropertyMap$;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The meta-property for the {@code hashMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<HashMultimap<String, String>> hashMultimap() {
+      return _hashMultimap;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
+      switch (propertyName.hashCode()) {
+        case -1368338255:  // hashMultimap
+          return ((HashMultimapMockBean) bean).getHashMultimap();
+      }
+      return super.propertyGet(bean, propertyName, quiet);
+    }
+
+    @Override
+    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
+      metaProperty(propertyName);
+      if (quiet) {
+        return;
+      }
+      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
+    }
+
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The bean-builder for {@code HashMultimapMockBean}.
+   */
+  public static class Builder extends DirectFieldsBeanBuilder<HashMultimapMockBean> {
+
+    private HashMultimap<String, String> _hashMultimap;
+
+    /**
+     * Restricted constructor.
+     */
+    protected Builder() {
+    }
+
+    /**
+     * Restricted copy constructor.
+     * @param beanToCopy  the bean to copy from, not null
+     */
+    protected Builder(HashMultimapMockBean beanToCopy) {
+      this._hashMultimap = beanToCopy.getHashMultimap();
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public Object get(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case -1368338255:  // hashMultimap
+          return _hashMultimap;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Builder set(String propertyName, Object newValue) {
+      switch (propertyName.hashCode()) {
+        case -1368338255:  // hashMultimap
+          this._hashMultimap = (HashMultimap<String, String>) newValue;
+          break;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+      return this;
+    }
+
+    @Override
+    public Builder set(MetaProperty<?> property, Object value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(String propertyName, String value) {
+      setString(meta().metaProperty(propertyName), value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(MetaProperty<?> property, String value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
+      super.setAll(propertyValueMap);
+      return this;
+    }
+
+    @Override
+    public HashMultimapMockBean build() {
+      return new HashMultimapMockBean(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the {@code hashMultimap} property in the builder.
+     * @param hashMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder hashMultimap(HashMultimap<String, String> hashMultimap) {
+      JodaBeanUtils.notNull(hashMultimap, "hashMultimap");
+      this._hashMultimap = hashMultimap;
+      return this;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(64);
+      buf.append("HashMultimapMockBean.Builder{");
+      int len = buf.length();
+      toString(buf);
+      if (buf.length() > len) {
+        buf.setLength(buf.length() - 2);
+      }
+      buf.append('}');
+      return buf.toString();
+    }
+
+    protected void toString(StringBuilder buf) {
+      buf.append("hashMultimap").append('=').append(JodaBeanUtils.toString(_hashMultimap)).append(',').append(' ');
+    }
+
+  }
+
+  ///CLOVER:ON
+  //-------------------------- AUTOGENERATED END --------------------------
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/ListMultimapMockBean.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/ListMultimapMockBean.java
new file mode 100644
index 0000000..ef675c4
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/ListMultimapMockBean.java
@@ -0,0 +1,331 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.joda.beans.Bean;
+import org.joda.beans.BeanDefinition;
+import org.joda.beans.ImmutableBean;
+import org.joda.beans.JodaBeanUtils;
+import org.joda.beans.MetaProperty;
+import org.joda.beans.Property;
+import org.joda.beans.PropertyDefinition;
+import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
+import org.joda.beans.impl.direct.DirectMetaBean;
+import org.joda.beans.impl.direct.DirectMetaProperty;
+import org.joda.beans.impl.direct.DirectMetaPropertyMap;
+
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ListMultimap;
+
+@BeanDefinition
+public class ListMultimapMockBean implements ImmutableBean {
+
+  @PropertyDefinition(validate = "notNull")
+  private final ListMultimap<String, String> _listMultimap;
+
+  //------------------------- AUTOGENERATED START -------------------------
+  ///CLOVER:OFF
+  /**
+   * The meta-bean for {@code ListMultimapMockBean}.
+   * @return the meta-bean, not null
+   */
+  public static ListMultimapMockBean.Meta meta() {
+    return ListMultimapMockBean.Meta.INSTANCE;
+  }
+
+  static {
+    JodaBeanUtils.registerMetaBean(ListMultimapMockBean.Meta.INSTANCE);
+  }
+
+  /**
+   * Returns a builder used to create an instance of the bean.
+   * @return the builder, not null
+   */
+  public static ListMultimapMockBean.Builder builder() {
+    return new ListMultimapMockBean.Builder();
+  }
+
+  /**
+   * Restricted constructor.
+   * @param builder  the builder to copy from, not null
+   */
+  protected ListMultimapMockBean(ListMultimapMockBean.Builder builder) {
+    JodaBeanUtils.notNull(builder._listMultimap, "listMultimap");
+    this._listMultimap = ImmutableListMultimap.copyOf(builder._listMultimap);
+  }
+
+  @Override
+  public ListMultimapMockBean.Meta metaBean() {
+    return ListMultimapMockBean.Meta.INSTANCE;
+  }
+
+  @Override
+  public <R> Property<R> property(String propertyName) {
+    return metaBean().<R>metaProperty(propertyName).createProperty(this);
+  }
+
+  @Override
+  public Set<String> propertyNames() {
+    return metaBean().metaPropertyMap().keySet();
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the listMultimap.
+   * @return the value of the property, not null
+   */
+  public ListMultimap<String, String> getListMultimap() {
+    return _listMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Returns a builder that allows this bean to be mutated.
+   * @return the mutable builder, not null
+   */
+  public Builder toBuilder() {
+    return new Builder(this);
+  }
+
+  @Override
+  public ListMultimapMockBean clone() {
+    return this;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    }
+    if (obj != null && obj.getClass() == this.getClass()) {
+      ListMultimapMockBean other = (ListMultimapMockBean) obj;
+      return JodaBeanUtils.equal(getListMultimap(), other.getListMultimap());
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = getClass().hashCode();
+    hash += hash * 31 + JodaBeanUtils.hashCode(getListMultimap());
+    return hash;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder(64);
+    buf.append("ListMultimapMockBean{");
+    int len = buf.length();
+    toString(buf);
+    if (buf.length() > len) {
+      buf.setLength(buf.length() - 2);
+    }
+    buf.append('}');
+    return buf.toString();
+  }
+
+  protected void toString(StringBuilder buf) {
+    buf.append("listMultimap").append('=').append(JodaBeanUtils.toString(getListMultimap())).append(',').append(' ');
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The meta-bean for {@code ListMultimapMockBean}.
+   */
+  public static class Meta extends DirectMetaBean {
+    /**
+     * The singleton instance of the meta-bean.
+     */
+    static final Meta INSTANCE = new Meta();
+
+    /**
+     * The meta-property for the {@code listMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<ListMultimap<String, String>> _listMultimap = DirectMetaProperty.ofImmutable(
+        this, "listMultimap", ListMultimapMockBean.class, (Class) ListMultimap.class);
+    /**
+     * The meta-properties.
+     */
+    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
+        this, null,
+        "listMultimap");
+
+    /**
+     * Restricted constructor.
+     */
+    protected Meta() {
+    }
+
+    @Override
+    protected MetaProperty<?> metaPropertyGet(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1737633857:  // listMultimap
+          return _listMultimap;
+      }
+      return super.metaPropertyGet(propertyName);
+    }
+
+    @Override
+    public ListMultimapMockBean.Builder builder() {
+      return new ListMultimapMockBean.Builder();
+    }
+
+    @Override
+    public Class<? extends ListMultimapMockBean> beanType() {
+      return ListMultimapMockBean.class;
+    }
+
+    @Override
+    public Map<String, MetaProperty<?>> metaPropertyMap() {
+      return _metaPropertyMap$;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The meta-property for the {@code listMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<ListMultimap<String, String>> listMultimap() {
+      return _listMultimap;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
+      switch (propertyName.hashCode()) {
+        case 1737633857:  // listMultimap
+          return ((ListMultimapMockBean) bean).getListMultimap();
+      }
+      return super.propertyGet(bean, propertyName, quiet);
+    }
+
+    @Override
+    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
+      metaProperty(propertyName);
+      if (quiet) {
+        return;
+      }
+      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
+    }
+
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The bean-builder for {@code ListMultimapMockBean}.
+   */
+  public static class Builder extends DirectFieldsBeanBuilder<ListMultimapMockBean> {
+
+    private ListMultimap<String, String> _listMultimap = ArrayListMultimap.create();
+
+    /**
+     * Restricted constructor.
+     */
+    protected Builder() {
+    }
+
+    /**
+     * Restricted copy constructor.
+     * @param beanToCopy  the bean to copy from, not null
+     */
+    protected Builder(ListMultimapMockBean beanToCopy) {
+      this._listMultimap = ArrayListMultimap.create(beanToCopy.getListMultimap());
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public Object get(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1737633857:  // listMultimap
+          return _listMultimap;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Builder set(String propertyName, Object newValue) {
+      switch (propertyName.hashCode()) {
+        case 1737633857:  // listMultimap
+          this._listMultimap = (ListMultimap<String, String>) newValue;
+          break;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+      return this;
+    }
+
+    @Override
+    public Builder set(MetaProperty<?> property, Object value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(String propertyName, String value) {
+      setString(meta().metaProperty(propertyName), value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(MetaProperty<?> property, String value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
+      super.setAll(propertyValueMap);
+      return this;
+    }
+
+    @Override
+    public ListMultimapMockBean build() {
+      return new ListMultimapMockBean(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the {@code listMultimap} property in the builder.
+     * @param listMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder listMultimap(ListMultimap<String, String> listMultimap) {
+      JodaBeanUtils.notNull(listMultimap, "listMultimap");
+      this._listMultimap = listMultimap;
+      return this;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(64);
+      buf.append("ListMultimapMockBean.Builder{");
+      int len = buf.length();
+      toString(buf);
+      if (buf.length() > len) {
+        buf.setLength(buf.length() - 2);
+      }
+      buf.append('}');
+      return buf.toString();
+    }
+
+    protected void toString(StringBuilder buf) {
+      buf.append("listMultimap").append('=').append(JodaBeanUtils.toString(_listMultimap)).append(',').append(' ');
+    }
+
+  }
+
+  ///CLOVER:ON
+  //-------------------------- AUTOGENERATED END --------------------------
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/MultimapBeanFudgeBuilderTest.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/MultimapBeanFudgeBuilderTest.java
new file mode 100644
index 0000000..565cdea
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/MultimapBeanFudgeBuilderTest.java
@@ -0,0 +1,142 @@
+/**
+ * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import org.testng.annotations.Test;
+
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.SortedSetMultimap;
+import com.google.common.collect.TreeMultimap;
+import com.opengamma.util.test.AbstractFudgeBuilderTestCase;
+import com.opengamma.util.test.TestGroup;
+
+/**
+ * Tests the Multimap support in joda-beans/fudge.
+ */
+@Test(groups = TestGroup.UNIT)
+public class MultimapBeanFudgeBuilderTest extends AbstractFudgeBuilderTestCase {
+
+  public void test_empty_simple_multimap() {
+    SimpleMultimapMockBean bean = SimpleMultimapMockBean.builder()
+        .simpleMultimap(ArrayListMultimap.<String, String>create())
+        .build();
+    assertThat(cycleObject(SimpleMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_non_empty_simple_multimap() {
+    Multimap<String, String> mmap = HashMultimap.create();
+    mmap.put("one", "1");
+    mmap.put("one", "42");
+    mmap.put("two", "2");
+
+    SimpleMultimapMockBean bean = SimpleMultimapMockBean.builder()
+        .simpleMultimap(mmap)
+        .build();
+    assertThat(cycleObject(SimpleMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_empty_list_multimap() {
+    ListMultimapMockBean bean = ListMultimapMockBean.builder()
+        .listMultimap(ArrayListMultimap.<String, String>create())
+        .build();
+    assertThat(cycleObject(ListMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_non_empty_list_multimap() {
+    ListMultimap<String, String> mmap = ArrayListMultimap.create();
+    mmap.put("one", "1");
+    mmap.put("one", "42");
+    mmap.put("two", "2");
+
+    ListMultimapMockBean bean = ListMultimapMockBean.builder()
+        .listMultimap(mmap)
+        .build();
+    assertThat(cycleObject(ListMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_empty_hash_multimap() {
+    HashMultimapMockBean bean = HashMultimapMockBean.builder()
+        .hashMultimap(HashMultimap.<String, String>create())
+        .build();
+    assertThat(cycleObject(HashMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_non_empty_hash_multimap() {
+    HashMultimap<String, String> mmap = HashMultimap.create();
+    mmap.put("one", "1");
+    mmap.put("one", "42");
+    mmap.put("two", "2");
+    HashMultimapMockBean bean = HashMultimapMockBean.builder()
+        .hashMultimap(mmap)
+        .build();
+    assertThat(cycleObject(HashMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_empty_sorted_multimap() {
+    SortedMultimapMockBean bean = SortedMultimapMockBean.builder()
+        .sortedMultimap(TreeMultimap.<String, String>create())
+        .build();
+    assertThat(cycleObject(SortedMultimapMockBean.class, bean), is(bean));
+  }
+
+  public void test_non_empty_sorted_multimap() {
+    SortedSetMultimap<String, String> mmap = TreeMultimap.create();
+    mmap.put("one", "1");
+    mmap.put("one", "42");
+    mmap.put("two", "2");
+    SortedMultimapMockBean bean = SortedMultimapMockBean.builder()
+        .sortedMultimap(mmap)
+        .build();
+    assertThat(cycleObject(SortedMultimapMockBean.class, bean), is(bean));
+  }
+
+  /**
+   * This test is unreliable at the moment and so disabled. This is due
+   * to the way joda-beans treats a property of Multimap. Joda-beans
+   * creates a HashMultiMap, but this gets copied by ImmutableMultimap.copyOf()
+   * which uses a ListMultimap which depending on JVM means that
+   * the created multimaps don't compare as equals.
+   * If https://github.com/JodaOrg/joda-beans/issues/64 gets fixed, it should
+   * be possible to enable this test.
+   */
+  @Test(enabled = false)
+  public void test_combined_multimap() {
+    ListMultimap<String, String> lmmap = ArrayListMultimap.create();
+    lmmap.put("one", "1");
+    lmmap.put("one", "42");
+    lmmap.put("two", "2");
+
+    HashMultimap<String, String> hmmap = HashMultimap.create();
+    hmmap.put("three", "100");
+    hmmap.put("three", "4200");
+    hmmap.put("four", "200");
+
+    SortedSetMultimap<String, String> smmap = TreeMultimap.create();
+    smmap.put("five", "-1");
+    smmap.put("five", "-42");
+    smmap.put("six", "-2");
+
+    HashMultimap<String, String> mmap = HashMultimap.create();
+    mmap.put("seven", "-13");
+    mmap.put("seven", "-423");
+    mmap.put("eight", "-24");
+
+    CombinedMultimapMockBean bean = CombinedMultimapMockBean.builder()
+        .listMultimap(lmmap)
+        .setMultimap(hmmap)
+        .sortedMultimap(smmap)
+        .noTypeMultimap(mmap)
+        .build();
+    assertThat(cycleObject(CombinedMultimapMockBean.class, bean), is(bean));
+  }
+
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SimpleMultimapMockBean.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SimpleMultimapMockBean.java
new file mode 100644
index 0000000..0ab6b10
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SimpleMultimapMockBean.java
@@ -0,0 +1,331 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.joda.beans.Bean;
+import org.joda.beans.BeanDefinition;
+import org.joda.beans.ImmutableBean;
+import org.joda.beans.JodaBeanUtils;
+import org.joda.beans.MetaProperty;
+import org.joda.beans.Property;
+import org.joda.beans.PropertyDefinition;
+import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
+import org.joda.beans.impl.direct.DirectMetaBean;
+import org.joda.beans.impl.direct.DirectMetaProperty;
+import org.joda.beans.impl.direct.DirectMetaPropertyMap;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.Multimap;
+
+@BeanDefinition
+public class SimpleMultimapMockBean implements ImmutableBean {
+
+  @PropertyDefinition(validate = "notNull")
+  private final Multimap<String, String> _simpleMultimap;
+
+  //------------------------- AUTOGENERATED START -------------------------
+  ///CLOVER:OFF
+  /**
+   * The meta-bean for {@code SimpleMultimapMockBean}.
+   * @return the meta-bean, not null
+   */
+  public static SimpleMultimapMockBean.Meta meta() {
+    return SimpleMultimapMockBean.Meta.INSTANCE;
+  }
+
+  static {
+    JodaBeanUtils.registerMetaBean(SimpleMultimapMockBean.Meta.INSTANCE);
+  }
+
+  /**
+   * Returns a builder used to create an instance of the bean.
+   * @return the builder, not null
+   */
+  public static SimpleMultimapMockBean.Builder builder() {
+    return new SimpleMultimapMockBean.Builder();
+  }
+
+  /**
+   * Restricted constructor.
+   * @param builder  the builder to copy from, not null
+   */
+  protected SimpleMultimapMockBean(SimpleMultimapMockBean.Builder builder) {
+    JodaBeanUtils.notNull(builder._simpleMultimap, "simpleMultimap");
+    this._simpleMultimap = ImmutableMultimap.copyOf(builder._simpleMultimap);
+  }
+
+  @Override
+  public SimpleMultimapMockBean.Meta metaBean() {
+    return SimpleMultimapMockBean.Meta.INSTANCE;
+  }
+
+  @Override
+  public <R> Property<R> property(String propertyName) {
+    return metaBean().<R>metaProperty(propertyName).createProperty(this);
+  }
+
+  @Override
+  public Set<String> propertyNames() {
+    return metaBean().metaPropertyMap().keySet();
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the simpleMultimap.
+   * @return the value of the property, not null
+   */
+  public Multimap<String, String> getSimpleMultimap() {
+    return _simpleMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Returns a builder that allows this bean to be mutated.
+   * @return the mutable builder, not null
+   */
+  public Builder toBuilder() {
+    return new Builder(this);
+  }
+
+  @Override
+  public SimpleMultimapMockBean clone() {
+    return this;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    }
+    if (obj != null && obj.getClass() == this.getClass()) {
+      SimpleMultimapMockBean other = (SimpleMultimapMockBean) obj;
+      return JodaBeanUtils.equal(getSimpleMultimap(), other.getSimpleMultimap());
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = getClass().hashCode();
+    hash += hash * 31 + JodaBeanUtils.hashCode(getSimpleMultimap());
+    return hash;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder(64);
+    buf.append("SimpleMultimapMockBean{");
+    int len = buf.length();
+    toString(buf);
+    if (buf.length() > len) {
+      buf.setLength(buf.length() - 2);
+    }
+    buf.append('}');
+    return buf.toString();
+  }
+
+  protected void toString(StringBuilder buf) {
+    buf.append("simpleMultimap").append('=').append(JodaBeanUtils.toString(getSimpleMultimap())).append(',').append(' ');
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The meta-bean for {@code SimpleMultimapMockBean}.
+   */
+  public static class Meta extends DirectMetaBean {
+    /**
+     * The singleton instance of the meta-bean.
+     */
+    static final Meta INSTANCE = new Meta();
+
+    /**
+     * The meta-property for the {@code simpleMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<Multimap<String, String>> _simpleMultimap = DirectMetaProperty.ofImmutable(
+        this, "simpleMultimap", SimpleMultimapMockBean.class, (Class) Multimap.class);
+    /**
+     * The meta-properties.
+     */
+    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
+        this, null,
+        "simpleMultimap");
+
+    /**
+     * Restricted constructor.
+     */
+    protected Meta() {
+    }
+
+    @Override
+    protected MetaProperty<?> metaPropertyGet(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1843354965:  // simpleMultimap
+          return _simpleMultimap;
+      }
+      return super.metaPropertyGet(propertyName);
+    }
+
+    @Override
+    public SimpleMultimapMockBean.Builder builder() {
+      return new SimpleMultimapMockBean.Builder();
+    }
+
+    @Override
+    public Class<? extends SimpleMultimapMockBean> beanType() {
+      return SimpleMultimapMockBean.class;
+    }
+
+    @Override
+    public Map<String, MetaProperty<?>> metaPropertyMap() {
+      return _metaPropertyMap$;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The meta-property for the {@code simpleMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<Multimap<String, String>> simpleMultimap() {
+      return _simpleMultimap;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
+      switch (propertyName.hashCode()) {
+        case 1843354965:  // simpleMultimap
+          return ((SimpleMultimapMockBean) bean).getSimpleMultimap();
+      }
+      return super.propertyGet(bean, propertyName, quiet);
+    }
+
+    @Override
+    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
+      metaProperty(propertyName);
+      if (quiet) {
+        return;
+      }
+      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
+    }
+
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The bean-builder for {@code SimpleMultimapMockBean}.
+   */
+  public static class Builder extends DirectFieldsBeanBuilder<SimpleMultimapMockBean> {
+
+    private Multimap<String, String> _simpleMultimap = HashMultimap.create();
+
+    /**
+     * Restricted constructor.
+     */
+    protected Builder() {
+    }
+
+    /**
+     * Restricted copy constructor.
+     * @param beanToCopy  the bean to copy from, not null
+     */
+    protected Builder(SimpleMultimapMockBean beanToCopy) {
+      this._simpleMultimap = HashMultimap.create(beanToCopy.getSimpleMultimap());
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public Object get(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1843354965:  // simpleMultimap
+          return _simpleMultimap;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Builder set(String propertyName, Object newValue) {
+      switch (propertyName.hashCode()) {
+        case 1843354965:  // simpleMultimap
+          this._simpleMultimap = (Multimap<String, String>) newValue;
+          break;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+      return this;
+    }
+
+    @Override
+    public Builder set(MetaProperty<?> property, Object value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(String propertyName, String value) {
+      setString(meta().metaProperty(propertyName), value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(MetaProperty<?> property, String value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
+      super.setAll(propertyValueMap);
+      return this;
+    }
+
+    @Override
+    public SimpleMultimapMockBean build() {
+      return new SimpleMultimapMockBean(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the {@code simpleMultimap} property in the builder.
+     * @param simpleMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder simpleMultimap(Multimap<String, String> simpleMultimap) {
+      JodaBeanUtils.notNull(simpleMultimap, "simpleMultimap");
+      this._simpleMultimap = simpleMultimap;
+      return this;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(64);
+      buf.append("SimpleMultimapMockBean.Builder{");
+      int len = buf.length();
+      toString(buf);
+      if (buf.length() > len) {
+        buf.setLength(buf.length() - 2);
+      }
+      buf.append('}');
+      return buf.toString();
+    }
+
+    protected void toString(StringBuilder buf) {
+      buf.append("simpleMultimap").append('=').append(JodaBeanUtils.toString(_simpleMultimap)).append(',').append(' ');
+    }
+
+  }
+
+  ///CLOVER:ON
+  //-------------------------- AUTOGENERATED END --------------------------
+}
diff --git a/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SortedMultimapMockBean.java b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SortedMultimapMockBean.java
new file mode 100644
index 0000000..77d14ad
--- /dev/null
+++ b/projects/OG-Util/src/test/java/com/opengamma/util/fudgemsg/multimap/SortedMultimapMockBean.java
@@ -0,0 +1,329 @@
+/**
+ * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
+ *
+ * Please see distribution for license.
+ */
+package com.opengamma.util.fudgemsg.multimap;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.joda.beans.Bean;
+import org.joda.beans.BeanDefinition;
+import org.joda.beans.ImmutableBean;
+import org.joda.beans.JodaBeanUtils;
+import org.joda.beans.MetaProperty;
+import org.joda.beans.Property;
+import org.joda.beans.PropertyDefinition;
+import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
+import org.joda.beans.impl.direct.DirectMetaBean;
+import org.joda.beans.impl.direct.DirectMetaProperty;
+import org.joda.beans.impl.direct.DirectMetaPropertyMap;
+
+import com.google.common.collect.SortedSetMultimap;
+
+@BeanDefinition
+public class SortedMultimapMockBean implements ImmutableBean {
+
+  @PropertyDefinition(validate = "notNull")
+  private final SortedSetMultimap<String, String> _sortedMultimap;
+
+  //------------------------- AUTOGENERATED START -------------------------
+  ///CLOVER:OFF
+  /**
+   * The meta-bean for {@code SortedMultimapMockBean}.
+   * @return the meta-bean, not null
+   */
+  public static SortedMultimapMockBean.Meta meta() {
+    return SortedMultimapMockBean.Meta.INSTANCE;
+  }
+
+  static {
+    JodaBeanUtils.registerMetaBean(SortedMultimapMockBean.Meta.INSTANCE);
+  }
+
+  /**
+   * Returns a builder used to create an instance of the bean.
+   * @return the builder, not null
+   */
+  public static SortedMultimapMockBean.Builder builder() {
+    return new SortedMultimapMockBean.Builder();
+  }
+
+  /**
+   * Restricted constructor.
+   * @param builder  the builder to copy from, not null
+   */
+  protected SortedMultimapMockBean(SortedMultimapMockBean.Builder builder) {
+    JodaBeanUtils.notNull(builder._sortedMultimap, "sortedMultimap");
+    this._sortedMultimap = builder._sortedMultimap;
+  }
+
+  @Override
+  public SortedMultimapMockBean.Meta metaBean() {
+    return SortedMultimapMockBean.Meta.INSTANCE;
+  }
+
+  @Override
+  public <R> Property<R> property(String propertyName) {
+    return metaBean().<R>metaProperty(propertyName).createProperty(this);
+  }
+
+  @Override
+  public Set<String> propertyNames() {
+    return metaBean().metaPropertyMap().keySet();
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Gets the sortedMultimap.
+   * @return the value of the property, not null
+   */
+  public SortedSetMultimap<String, String> getSortedMultimap() {
+    return _sortedMultimap;
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * Returns a builder that allows this bean to be mutated.
+   * @return the mutable builder, not null
+   */
+  public Builder toBuilder() {
+    return new Builder(this);
+  }
+
+  @Override
+  public SortedMultimapMockBean clone() {
+    return this;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    }
+    if (obj != null && obj.getClass() == this.getClass()) {
+      SortedMultimapMockBean other = (SortedMultimapMockBean) obj;
+      return JodaBeanUtils.equal(getSortedMultimap(), other.getSortedMultimap());
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = getClass().hashCode();
+    hash += hash * 31 + JodaBeanUtils.hashCode(getSortedMultimap());
+    return hash;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder(64);
+    buf.append("SortedMultimapMockBean{");
+    int len = buf.length();
+    toString(buf);
+    if (buf.length() > len) {
+      buf.setLength(buf.length() - 2);
+    }
+    buf.append('}');
+    return buf.toString();
+  }
+
+  protected void toString(StringBuilder buf) {
+    buf.append("sortedMultimap").append('=').append(JodaBeanUtils.toString(getSortedMultimap())).append(',').append(' ');
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The meta-bean for {@code SortedMultimapMockBean}.
+   */
+  public static class Meta extends DirectMetaBean {
+    /**
+     * The singleton instance of the meta-bean.
+     */
+    static final Meta INSTANCE = new Meta();
+
+    /**
+     * The meta-property for the {@code sortedMultimap} property.
+     */
+    @SuppressWarnings({"unchecked", "rawtypes" })
+    private final MetaProperty<SortedSetMultimap<String, String>> _sortedMultimap = DirectMetaProperty.ofImmutable(
+        this, "sortedMultimap", SortedMultimapMockBean.class, (Class) SortedSetMultimap.class);
+    /**
+     * The meta-properties.
+     */
+    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
+        this, null,
+        "sortedMultimap");
+
+    /**
+     * Restricted constructor.
+     */
+    protected Meta() {
+    }
+
+    @Override
+    protected MetaProperty<?> metaPropertyGet(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1018561376:  // sortedMultimap
+          return _sortedMultimap;
+      }
+      return super.metaPropertyGet(propertyName);
+    }
+
+    @Override
+    public SortedMultimapMockBean.Builder builder() {
+      return new SortedMultimapMockBean.Builder();
+    }
+
+    @Override
+    public Class<? extends SortedMultimapMockBean> beanType() {
+      return SortedMultimapMockBean.class;
+    }
+
+    @Override
+    public Map<String, MetaProperty<?>> metaPropertyMap() {
+      return _metaPropertyMap$;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The meta-property for the {@code sortedMultimap} property.
+     * @return the meta-property, not null
+     */
+    public final MetaProperty<SortedSetMultimap<String, String>> sortedMultimap() {
+      return _sortedMultimap;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
+      switch (propertyName.hashCode()) {
+        case 1018561376:  // sortedMultimap
+          return ((SortedMultimapMockBean) bean).getSortedMultimap();
+      }
+      return super.propertyGet(bean, propertyName, quiet);
+    }
+
+    @Override
+    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
+      metaProperty(propertyName);
+      if (quiet) {
+        return;
+      }
+      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
+    }
+
+  }
+
+  //-----------------------------------------------------------------------
+  /**
+   * The bean-builder for {@code SortedMultimapMockBean}.
+   */
+  public static class Builder extends DirectFieldsBeanBuilder<SortedMultimapMockBean> {
+
+    private SortedSetMultimap<String, String> _sortedMultimap;
+
+    /**
+     * Restricted constructor.
+     */
+    protected Builder() {
+    }
+
+    /**
+     * Restricted copy constructor.
+     * @param beanToCopy  the bean to copy from, not null
+     */
+    protected Builder(SortedMultimapMockBean beanToCopy) {
+      this._sortedMultimap = beanToCopy.getSortedMultimap();
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public Object get(String propertyName) {
+      switch (propertyName.hashCode()) {
+        case 1018561376:  // sortedMultimap
+          return _sortedMultimap;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Builder set(String propertyName, Object newValue) {
+      switch (propertyName.hashCode()) {
+        case 1018561376:  // sortedMultimap
+          this._sortedMultimap = (SortedSetMultimap<String, String>) newValue;
+          break;
+        default:
+          throw new NoSuchElementException("Unknown property: " + propertyName);
+      }
+      return this;
+    }
+
+    @Override
+    public Builder set(MetaProperty<?> property, Object value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(String propertyName, String value) {
+      setString(meta().metaProperty(propertyName), value);
+      return this;
+    }
+
+    @Override
+    public Builder setString(MetaProperty<?> property, String value) {
+      super.set(property, value);
+      return this;
+    }
+
+    @Override
+    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
+      super.setAll(propertyValueMap);
+      return this;
+    }
+
+    @Override
+    public SortedMultimapMockBean build() {
+      return new SortedMultimapMockBean(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the {@code sortedMultimap} property in the builder.
+     * @param sortedMultimap  the new value, not null
+     * @return this, for chaining, not null
+     */
+    public Builder sortedMultimap(SortedSetMultimap<String, String> sortedMultimap) {
+      JodaBeanUtils.notNull(sortedMultimap, "sortedMultimap");
+      this._sortedMultimap = sortedMultimap;
+      return this;
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(64);
+      buf.append("SortedMultimapMockBean.Builder{");
+      int len = buf.length();
+      toString(buf);
+      if (buf.length() > len) {
+        buf.setLength(buf.length() - 2);
+      }
+      buf.append('}');
+      return buf.toString();
+    }
+
+    protected void toString(StringBuilder buf) {
+      buf.append("sortedMultimap").append('=').append(JodaBeanUtils.toString(_sortedMultimap)).append(',').append(' ');
+    }
+
+  }
+
+  ///CLOVER:ON
+  //-------------------------- AUTOGENERATED END --------------------------
+}
diff --git a/projects/OG-UtilDB/src/main/java/com/opengamma/util/test/AbstractDbTest.java b/projects/OG-UtilDB/src/main/java/com/opengamma/util/test/AbstractDbTest.java
index 178d381..a3ed5aa 100644
--- a/projects/OG-UtilDB/src/main/java/com/opengamma/util/test/AbstractDbTest.java
+++ b/projects/OG-UtilDB/src/main/java/com/opengamma/util/test/AbstractDbTest.java
@@ -68,7 +68,6 @@ public abstract class AbstractDbTest implements TableCreationCallback {
    */
   @BeforeClass(alwaysRun = true)
   public final void setUpClass() throws Exception {
-    TestUtils.initSecurity();
     doSetUpClass();
   }
 
diff --git a/projects/OG-Web/src/test/java/com/opengamma/web/position/AbstractWebPositionResourceTestCase.java b/projects/OG-Web/src/test/java/com/opengamma/web/position/AbstractWebPositionResourceTestCase.java
index 5fb6f83..f01847c 100644
--- a/projects/OG-Web/src/test/java/com/opengamma/web/position/AbstractWebPositionResourceTestCase.java
+++ b/projects/OG-Web/src/test/java/com/opengamma/web/position/AbstractWebPositionResourceTestCase.java
@@ -17,8 +17,6 @@ import java.util.Map;
 import javax.ws.rs.core.Response;
 import javax.ws.rs.core.UriInfo;
 
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.mgt.DefaultSecurityManager;
 import org.springframework.core.io.FileSystemResourceLoader;
 import org.springframework.mock.web.MockServletContext;
 import org.testng.annotations.BeforeMethod;
@@ -61,7 +59,6 @@ import com.opengamma.master.security.impl.AbstractSecurityLoader;
 import com.opengamma.master.security.impl.InMemorySecurityMaster;
 import com.opengamma.util.money.Currency;
 import com.opengamma.util.test.TestGroup;
-import com.opengamma.util.test.TestUtils;
 import com.opengamma.web.FreemarkerOutputter;
 import com.opengamma.web.MockUriInfo;
 import com.opengamma.web.WebResourceTestUtils;
@@ -93,7 +90,6 @@ public abstract class AbstractWebPositionResourceTestCase {
 
   @BeforeMethod(groups = TestGroup.UNIT)
   public void setUp() throws Exception {
-    TestUtils.initSecurity();
     _uriInfo = new MockUriInfo(true);
     _trades = getTrades();
     _secMaster = new InMemorySecurityMaster(new ObjectIdSupplier("Mock"));
diff --git a/projects/OG-Web/src/test/java/com/opengamma/web/security/AbstractWebSecurityResourceTestCase.java b/projects/OG-Web/src/test/java/com/opengamma/web/security/AbstractWebSecurityResourceTestCase.java
index 40eee1c..f75bc8b 100644
--- a/projects/OG-Web/src/test/java/com/opengamma/web/security/AbstractWebSecurityResourceTestCase.java
+++ b/projects/OG-Web/src/test/java/com/opengamma/web/security/AbstractWebSecurityResourceTestCase.java
@@ -32,7 +32,6 @@ import com.opengamma.master.security.SecurityMaster;
 import com.opengamma.master.security.impl.AbstractSecurityLoader;
 import com.opengamma.master.security.impl.InMemorySecurityMaster;
 import com.opengamma.util.test.TestGroup;
-import com.opengamma.util.test.TestUtils;
 import com.opengamma.web.FreemarkerOutputter;
 import com.opengamma.web.MockUriInfo;
 import com.opengamma.web.WebResourceTestUtils;
@@ -54,7 +53,6 @@ public abstract class AbstractWebSecurityResourceTestCase extends AbstractSecuri
 
   @BeforeMethod(groups = TestGroup.UNIT)
   public void setUp() throws Exception {
-    TestUtils.initSecurity();
     _uriInfo = new MockUriInfo(true);
     _secMaster = new InMemorySecurityMaster();
     _secLoader = new AbstractSecurityLoader() {
